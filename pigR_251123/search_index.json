[["index.html", "pigR: R, per pigri Cos’è pigR? Di cosa hai bisogno per leggere (e capire) questo libro. Chi siamo noi (noi, noi)? Se ti piace… Caveat Cookies La foto di copertina.", " pigR: R, per pigri E. Parente, Scuola SAFE, Università degli Studi della Basilicata 25 November 2023 Cos’è pigR? Questo materiale (pigR: R per pigri) nasce da qualche anno di esperienza (frustrante) di insegnamento di corsi di “Statistical computing con R”1 per dottorandi di ricerca. È destinato soprattutto a chi si occupa di scienze sperimentali e parte da una conoscenza limitata sia della statistica che dell’uso di linguaggi e ambienti di programmazione, e ha la necessità (per varie ragioni) di passare a qualcosa di più complesso, e di farlo nel minor tempo possibile. Il testo potrebbe anche essere utile a chi si occupa di digital humanities. L’idea è: fornire una visione di insieme di R come linguaggio/ambiente e della sua utilità aiutare gli utenti (potenziali) a individuare le proprie necessità fornire percorsi guidati per set di necessità “standard” e per livelli diversi di interazione, indicando agli utenti le risorse migliori (ovviamente, le migliori secondo me) L’approccio è quello di fornire il minimo indispensabile di informazioni per consentire un apprendimento rapido ed efficace, ma, al tempo stesso, tracciare una sorta di mappa (soprattutto con l’uso di hyperlink e note2) per navigare in quel Mare magnum che è la documentazione (libri, siti web, forum, etc.) su R come linguaggio e sull’analisi grafica e statistica con R per le scienze sperimentali e non solo. Si tratta quindi di un approccio sostanzialmente pragmatico che probabilmente farà arricciare più di un naso (e qualche coda), ma la mia sincera speranza è che risparmi qualche esperienza frustrante. Anche per queste ragioni ho preso la (sofferta) decisione di spostare il capitolo sul data wrangling e sulla programmazione alla fine del libro. Molti testi online (come Just enough R, YaRrr!, etc.) che hanno lo scopo di permettere agli utenti di iniziare a usare R per la grafica e per la statistica il più rapidamente possibile non hanno un capitolo specifico sulla programmazione e sul data wrangling. Al contrario, altri, con maggiore enfasi sulla scienza dei dati (come R for data science, o Statistical inference via data science) dedicano capitoli specifici a questi argomenti. Nella mia esperienza, gli utenti più inesperti e privi di un background in informatica trovano la parte sulla programmazione “respingente”, probabilmente perché non ne comprendono bene l’utilità. Per questo illustrerò, quando serve, qualche funzione essenziale per la manipolazione dei dati e la programmazione e lasciando alla fine il resto (che poi è tanta roba). Una nota finale sugli esempi: per comprendere l’uso di R occorre studiare degli esempi di codice, che includono l’uso di set di dati. R base e tutti i pacchetti includono questi set di dati che solo raramente sono dati collegati in qualche modo alle diverse branche della biologia. Per semplificare le cose e diminuire il rischio che i dati proposti in questo libro scompaiano, ho preferito usare set di dati inclusi nei pacchetti di R. Di cosa hai bisogno per leggere (e capire) questo libro. Alla fine, conto di rendere disponibile questo libro in vari formati (.html, .pdf, .epub), acessibili tramite qualsiasi sistema operativo, su un notebook, desktop o tablet (sconsiglierei l’uso di smartphone), ma dubito molto che ne esisterà mai un’edizione cartacea. Benché il codice sia chiaramente indicato, per imparare R bisogna usarlo. Il sistema migliore è fare pratica su un computer con uno schermo abbastanza grande da mostrare tutte le finestre e i pannelli di RStudio (l’interfaccia che utilizzeremo per lavorare con R). Tuttavia, se decidi di usare un tablet, puoi usare la versione cloud di RStudio3. Il codice per i diversi capitoli è disponibile sia nei file .Rmd che (in futuro, quanto tutto sarà finito) sul repository dedicato su GitHub4. Chi siamo noi (noi, noi)? Eugenio Parente: sono professore ordinario (appunto…) di Microbiologia agraria presso l’Università degli Studi della Basilicata. Procedo da sempre a tentoni nel mondo della statistica e della programmazione, riuscendo a far credere (talvolta con un certo successo) di essere competente e capace. Sono talmente tanto vecchio da associare il titolo di questa sezione non a un meme ma a una canzone. E, se vi domandate perché sto scrivendo questo libro, semplicemente è perché potevo farlo. Un’ultima cosa: qui e lì ho lasciato cadere uova di Pasqua. Spero mi scuserete, non ho potuto evitarlo. Se ti piace… Per quanto possibile farò in modo che accedere a questo libro sia gratuito. Io ci ho lavorato molto (un po’ ho faticato, un po’ mi sono divertito). Per quanto pigR tu possa essere, se questo libro ti piace e ti ha fatto risparmiare del tempo, ti chiedo di prendere in considerazione l’idea di fare una donazione ad Emergency, o se Emergency proprio non ti piace, ad un’organizzazione non governativa che ritieni possa fare qualcosa di utile. Oppure, meglio ancora, dona il tuo tempo ad un’organizzazione che fa volontariato. Un like sulla pagina Facebook di pigR (abbastanza facile da trovare, direi) è comunque gradito. Caveat R è un linguaggio dinamico: nuove funzioni sono aggiunge con le nuove versioni di R e di diversi pacchetti (il [tidyverse],(https://www.tidyverse.org) per esempio, continua ad evolversi). Alcuni comandi usati negli esempi di questo libro potrebbero diventare obsoleti, ma dovrebbero funzionare comunque: le nuove versioni mantengono in genere la compatibilità con i vecchi comandi. Cookies Questo libro non usa biscottini, nemmeno di terze parti. Strumenti, 2 ISSN: 2975-1721 ISBN: 978-88-31309-24-0 © 2023 BUP - Basilicata University Press Università degli Studi della Basilicata Biblioteca Centrale di Ateneo Via Nazario Sauro 85 I - 85100 Potenza https ://bup.unibas.it Published in Italy Prima edizione : novembre 2023 Gli E-Book della BUP sono pubblicati con licenza Creative Commons Attribution 4.0 International La foto di copertina. La figura usata per la copertina è di Mark Stebnicki. Purtroppo non tutti i maiali sono così sorridenti. credo si possa rozzamente tradurre in “Calcolo statistico con R” o forse meglio, in “Elementi di programmazione per il calcolo statistico con R”↩︎ questa, per l’appunto è una nota e serve per dirti che i link li ho controllati fra giugno e settembre 2023↩︎ RStudio, da pochissimo, è parte di posit↩︎ una sorta di social dei programmatori↩︎ "],["intro.html", "1 Introduzione 1.1 Cosa c’è da imparare in questo capitolo. 1.2 Convenzioni e guida alla lettura e all’uso del codice. 1.3 Tutti vogliono imparare a usare R. 1.4 L’altra faccia della medaglia: troppa fatica. 1.5 R, per pigri.", " 1 Introduzione v1.1.3 30/10/2023 1.1 Cosa c’è da imparare in questo capitolo. Questa è una breve introduzione a R. Ti suggerisco di scorrere velocemente questo capitolo per farti un’idea generale del linguaggio e delle sue potenzialità. 1.2 Convenzioni e guida alla lettura e all’uso del codice. Quando nel testo compare un blocco in grigio, come quello che segue &gt; demo(graphics) si tratta di un comando o di una serie di comandi, e deve essere scritto nella console5 così come appare, senza il carattere &gt;, se presente (questo carattere indica il prompt dei comandi, roba che risale a decine e decine di anni fa…). Quando ometto il carattere &gt; vuol dire che quell’insieme di comandi è pensato per essere eseguito come script (va copiato e incollato in uno script e eseguito in gruppo o comando per comando). &lt;esc&gt; indica che dovete pigiare (o sfiorare, o martellare) il tasto esc sulla vostra tastiera. Lo stesso vale per &lt;cmd&gt;, &lt;ctrl&gt; e simili. &lt;File -&gt; Open recent&gt; rappresenta una serie di click su menu e, eventualmente sottomenu, generalmente nella barra principale dei menu della GUI6 di R o RStudio. Un comando del tipo plotrix::fan.plot() indica che il comando (in questo caso fan.plot()) appartiene ad un determinato pacchetto (in questo caso plotrix). Linee orizzontali delimitano figure o tabelle I titoli dei paragrafi che costituiscono degli approfondimenti sono in corsivo. 1.3 Tutti vogliono imparare a usare R. Se sei un ricercatore (più o meno in erba) devi per forza aver usato qualche forma di analisi grafica e statistica dei dati che hai prodotto. Nella peggiore delle ipotesi, avrai usato qualcuno dei rudimentali strumenti offerti dalla maggior parte dei software per fogli di calcolo. Nel migliore dei casi, avrai già avuto un’esperienza più o meno estesa con veri software per l’analisi statistica (stand alone o, sempre più frequentemente, basati sul cloud computing). Tuttavia, se stai leggendo questo libro, stai più o meno seriamente considerando di imparare a usare R. R è, al tempo stesso un linguaggio (nel senso di linguaggio di programmazione), un ambiente, nel senso di ambiente di programmazione e un’applicazione, che puoi scaricare da uno dei siti del CRAN, che sta per Comprehensive R Archive Network7. R, abbastanza ovviamente, è il linguaggio e l’ambiente per l’analisi statistica e per la scienza dei dati, anche se altri linguaggi, come Python e Julia, possono essere più indicati per alcune applicazioni e, soprattutto, per l’analisi di big data. Ci sono diverse ragioni (4, 5, 6, 8, 10…, prova a cercare “reasons to learn R” con un motore di ricerca) per investire del tempo per imparare a usarlo: è un software gratuito, libero ed aperto, mantenuto e sviluppato da una grande comunità di statistici e programmatori è disponibile per diverse piattaforme: è possibile installarlo su sistemi basati su UNIX, MacOS, Windows8 è il software statistico più ricco di funzionalità: fra l’applicazione base, scaricabile dal CRAN e le migliaia di librerie (o pacchetti, o packages9), scaricabili dal CRAN, o da repository più o meno specializzati come Bioconductor o creati da singoli programmatori e disponibili su GitHub, offre il più incredibile insieme di funzionalità per la programmazione, la gestione e l’analisi statistica e grafica di dati. Insomma, se c’è uno strumento nuovo è probabile che sia disponibile su R anni prima che sia reso disponibile (se mai lo sarà) in altri software, commerciali o gratuiti. è potente: anche con un notebook relativamente poco performante è possibile eseguire in maniera efficace e rapida analisi molto complesse di set di dati relativamente grandi (alcuni GB). R, tuttavia, può essere usato su cluster di calcolo e gestire problemi veramente enormi10. è popolare, trasparente e riproducibile: la comunità degli utilizzatori di R ha una fortissima tradizione di condivisione e aiuto reciproco, come testimoniato dalle decine di blog, forum, siti web dedicati, in maniera più o meno specifica, a R. Inoltre, se scrivi bene il codice e fornisci tutti i dati necessari, le tue analisi possono essere ripetute esattamente come le hai “pensate” (e persino migliorate!): in un mondo in cui sempre più spesso viene richiesto di fornire dati e software in maniera aperta questo è un aspetto assolutamente fondamentale. Infine, per come la vedo io, ha strumenti potentissimi per la presentazione dei risultati dell’analisi sotto una miriade di formati, inclusi quelli interattivi11. può migliorare le tue prospettive di carriera: una buona conoscenza della programmazione in R sta diventando rapidamente un asset fondamentale per lavorare nella ricerca pubblica e privata e, in generale, nell’analisi dei dati. Vorrei poter aggiungere che saper usare R è una cosa fighissima e sexy (e migliora di molto la tua probabilità di rimorchiare ragazz*), ma non sono del tutto sicuro che sia vero. Quello che è vero è che programmare in R può essere molto soddisfacente. 1.3.1 Provare per credere: App, GUI, IDE e altre diavolerie. Installare R. Puoi scaricare l’applicazione (o software o app) R dal CRAN12. In alternativa, se ti fa piacere, puoi scaricare Microsoft R qui. Fai attenzione alla versione del tuo sistema operativo e in generale alle caratteristiche della tua macchina: non tutte le versioni di R sono supportate dalle macchine più “antiche”, ma puoi sempre trovare la versione “legacy” adatta alla tua macchina. Se hai già installato altro software sul tuo computer non dovresti avere difficoltà. Altrimenti, usando un motore di ricerca puoi trovare facilmente dei video tutorial, anche in italiano13. R GUI. Concluso il processo di installazione troverai l’icona di R sul tuo desktop o dovunque siano le icone delle applicazioni sul tuo sistema, e potrai aprire l’interfaccia grafica (Graphical User Interface o GUI). Quella che vedi qui sotto è la GUI di R 4.1 per MacOS. Figura 1.1: La Graphical User Interface di R per MacOS Anche se ho aperto qualche finestra in più, ti renderai conto che si tratta di un’interfaccia minimalista: pochi menu, tab, frame, pochissime finestre…14. E, soprattutto c’è un inquietante cursore lampeggiante vicino al segno &gt; nella console (lo spazio principale in cui è possibile inserire i comandi e il segno &gt; è il prompt). In R i comandi vengono scritti nella console (e per eseguirli è sufficiente premere &lt;invio&gt;), ed è nella console che appaiono molti dei risultati delle analisi, oltre che messaggi (inclusi quelli di errore). Proviamo ad eseguire un comando. Nella console, scrivi dopo il prompt: &gt;demo(graphics) e premi invio. Se segui le istruzioni sulla console15, vedrai apparire una serie di demo delle capacità grafiche di R (c’è molto di più, credimi). Ora, prova a scrivere: &gt;help(demo) Si aprirà una finestra con l’aiuto (le istruzioni) per l’uso della funzione/comando “demo”, che hai appena usato. Complimenti, hai scritto ed eseguito i tuoi due primi comandi in R!!. Altre GUI. Facciamo un salto in avanti e proviamo a scrivere ed eseguire un altro comando16. &gt;library(Rcmdr) Se appare un errore è perché il pacchetto non è ancora installato nel tuo sistema. Vedremo in dettaglio l’installazione dei pacchetti in un capitolo successivo, ma, per installare R commander e i pacchetti di cui ha bisogno per funzionare (le “dependencies”) puoi eseguire il comando: &gt;install.packages(\"Rcmdr\", dependencies = T) Se tutto va bene, sulla console appariranno un po’ di messaggi:17 Figura 1.2: Caricare R Commander Il risultato è l’apertura della GUI di R Commander, una graphical user interface piuttosto bruttina e minimalista che però consente di usare R in maniera simile a molti altri software di analisi grafica e statistica (ma credimi, non è quello che vuoi veramente, o, se lo vuoi, puoi smettere di leggere questo libro). Figura 1.3: La GUI di R Commander RStudio. RStudio è un ambiente di sviluppo integrato (IDE)18 disponibile sia come versione gratuita che con una serie di versioni professionali. L’installazione di RStudio richiede la presenza di R sul tuo sistema. Scaricare e installare RStudio è semplice. Scegli la versione che preferisci, scarica l’installer e segui le istruzioni19. Una volta scaricato e installato il software, aprilo, ed ecco qui: Figura 1.4: RStudio RStudio rende molto più facile lavorare con R ed è il software che useremo per tutto questo corso. Radiant. Radiant è una piattaforma interattiva per condurre analisi statistiche per l’analisi aziendale. In realtà, si tratta di un’interfaccia realizzata con RStudio, piuttosto completa. L’uso è abbastanza semplice e intuitivo. E’ sufficiente scaricare il pacchetto dal CRAN e installarlo, caricarlo in memoria e lanciare l’interfaccia (per uscire usa il tasto nella console: &gt;install.packages(&quot;radiant&quot;) &gt;require(radiant) &gt;radiant::radiant() In alternativa, dopo aver installato il pacchetto, è possibile lanciarlo da RStudio con &lt;Tools -&gt; Addins -&gt; Browse Addins...&gt;. Il software si apre di default nel vostro browser, ma può essere aperto nel Viewer di RStudio. 1.4 L’altra faccia della medaglia: troppa fatica. Beh, ma ancora una volta, se sei qui è perché non hai voglia di perdere tempo o perché, essendo pigr*, non vuoi fare troppa fatica per imparare a usare R, o perché ci hai già provato e hai lasciato perdere. Molti avranno cercato di scoraggiarti, proponendoti alternative più o meno valide. Fra i (tanti) difetti di R viene citata la lentezza, le limitazioni nell’uso della memoria, etc., ma il principale è sicuramente lo sforzo richiesto per raggiungere un ragionevole livello di padronanza dell’uso di questo linguaggio per l’analisi dei dati. “R has a steep learning curve”. Avrai sicuramente letto che “R has a steep learning curve”: è una frase che non ha molto senso (se si pensa alla forma di una curva di apprendimento) ma che vuole fondamentalmente dire che, all’aumentare dell’esperienza o del tempo speso nell’apprendimento i progressi iniziali sono relativamente lenti (una curva che compara diversi software è qui). D’altra parte, con R non si finisce mai di imparare e, sicuramente, l’esperienza di apprendimento di R, se sei motivat*, ripaga molto più degli sforzi comunque necessari per apprendere l’uso di molti software statistici professionali20. E’ certamente un processo frustrante, come puoi vedere dalla figura successiva21, ma se terrai duro, leggendo (beh, studiando, almeno un po’) questo libro arriverai sicuramente alla fase 2. Figura 1.5: La vera curva di apprendimento di R. Ma perché può essere difficile imparare a usare R? è un linguaggio22 e, fondamentalmente, devi “scrivere”, sotto forma di singole istruzioni o script o app quello che vuoi fare, e quindi ti tocca conoscere la sintassi (l’insieme di regole che ti permettono di comporre un comando che funzioni)23 (figura 1.6) e acquisire il vocabolario (R base ha centinaia di funzioni e migliaia di altre funzioni sono aggiunte dai pacchetti/librerie) la documentazione è quasi esclusivamente in inglese (e talvolta in un inglese decisamente tecnico) ci sono, letteralmente, molti modi di scuoiare un gatto: lo stesso risultato (in termini di operazioni preliminari di trasformazione e riorganizzazione dei dati, di analisi grafica e statistica) può essere ottenuto in molti modi diversi. Per esempio i pacchetti del tidyverse costituiscono in qualche modo un’evoluzione del linguaggio di base, basato su un concetto molto coerente di organizzazione della sintassi e delle strutture dei dati. Scegliere se concentrarsi sull’apprendimento della versione “base” di R o sugli equivalenti “tidy” di molte funzioni è un una scelta personale ma, per molte ragioni, è necessario avere una qualche conoscenza di entrambi i sistemi R può essere usato in molti modi: in modo “interattivo”, per se stessi: immettendo i comandi ad uno alla volta nella console ed eseguendoli uno per volta: il risultato del comando produrrà altri oggetti, un output (che andrà su file o alla console) o un “effetto collaterale” (p.es. il salvataggio di un file). Questo è ovviamente il modo più semplice per iniziare, ma più inefficiente per “comunicare” i risultati dell’analisi e meno ripetibile24, ma è anche il modo in cui “si provano” i comandi. in modo “programmatico”, per se stessi, o per altri: i comandi (probabilmente testati in modo interattivo) vengono raccolti in uno script e, se si organizza il tutto sotto forma di un documento in R Markdown e si usano altri accorgimenti (p.es. con l’uso di “progetti”) è possibile riprodurre e ripetere l’analisi (eventualmente con minime modificazioni) quante volte si vuole, generando report che includono i risultati delle analisi statistiche e grafiche, oltre che, eventualmente, il codice sotto forma di una varietà di formati (documenti in MS Word, html, pdf, slide, etc.). sviluppando applicazioni interattive: con R (e diversi pacchetti aggiuntivi) si possono sviluppare documenti e applicazioni interattive, che consentono ad utenti anche inesperti di controllare l’output dell’analisi, scegliendo per esempio cosa rappresentare in un grafico (e, in alcuni casi, come farlo). Molti pacchetti di R (Shiny, Plotly, learnr, bookdown25) consentono di sviluppare documenti, tutorial o applicazioni interattive, pronte per l’uso nel web. Questa enorme flessibilità è una della ragioni per cui chiunque voglia condurre analisi grafica e statistica in modo professionale dovrebbe imparare a usare R. Figura 1.6: Esempi di comandi scritti alla console. 1.5 R, per pigri. E quindi, eccoci qui: questo libro nasce proprio per aiutare te (che sei pigr* o non hai tempo) ad imparare ad usare R e condurre almeno il minimo indispensabile di analisi grafiche e statistiche tipicamente utilizzate nella ricerca biologica. L’approccio sarà sostanzialmente pragmatico, cercando di limitare al minimo le descrizioni formali e facendo il possibile per indirizzarti verso i percorsi di apprendimento più rapidi e verso le risorse (libri, siti web, etc.) più utili. Credo che questa sia, forse, la cosa più importante, anche se finirà per riflettere quelle che sono, inevitabilmente, inclinazioni personali: la documentazione su R è sterminata e non sempre molto efficace. Nelle note a piè di pagina e nei link troverai le risorse essenziali, ma anche ulteriori risorse per approfondire. Dal momento che tutto (beh, quasi tutto26 c’è qualcosa in altre lingue) il materiale interessante su R è in inglese, la scelta di scrivere in italiano potrebbe sembrare un po’ controintuitiva. Tuttavia, tu siete pigr* e io, per esperienza, so che il mix di inglese, informatica e statistica può essere decisamente letale. Nel caso la tua pigrizia ti spingesse a credere che imparare a fare analisi statistica con un qualsiasi altro software sia più semplice che farlo con R, vorrei dire un’altra volta che questo può essere vero, ma solo in parte. L’ultima volta che ho guardato i manuali d’uso di Systat erano qualcosa come 7 volumi e imparare ad usare bene un software professionale per l’analisi statistica non è sicuramente una passeggiata (per pigri). Quindi, iniziamo!! eh, ma che cos’è una console… un po’ di pazienza, arrivate almeno al capitolo 1↩︎ Graphical User Interface↩︎ se ti interessa un pistolotto abbastanza lungo sulla storia di R il migliore è qui, anche se è decisamente un tantino tecnico, ed è in inglese. Qualcosa in italiano la trovi qui. R è un linguaggio recente: la prima versione stabile appare nel 2000↩︎ esiste addirittura un’implementazione di Microsoft, Microsoft R e RStudio rende disponibile una versione cloud di R↩︎ al momento della revisione di questo capitolo, agosto 2023, nel solo CRAN sono disponibili oltre 20.000 pacchetti; il numero di pacchetti disponibili su varie fonti è ancora maggiore; clicca qui per delle statistiche aggiornate↩︎ qualche dettaglio in più, con un confronto con alcuni software commerciali, lo trovi qui↩︎ questo libro è scritto in RStudio sotto forma di documento Rmarkdown, usando comandi di R per generare analisi statistiche e grafiche↩︎ in realtà dallo stesso sito potresti voler scaricare varie utility necessarie per la compilazione delle librerie o pacchetti, ma questo non è strettamente necessario, perché quasi tutti i pacchetti sono o saranno disponibili in un formato immediatamente installabile↩︎ ecco un video di Federica web learning↩︎ puoi confrontarla con quella dei software statistici che conosci, o, semplicemente, cercare “SAS graphical user interface” su un motore di ricerca, sostituendo SAS con il tuo software favorito (beh, favorito fino all’altro ieri) e selezionando le immagini come risultati↩︎ se ti stanchi usa il tasto &lt;esc&gt;↩︎ questo particolare comando carica nell’“ambiente” un pacchetto già installato.↩︎ sono dei warning o avvisi, in rosso: richiedono l’attenzione dell’utente ma non indicano condizioni fatali, che non permetterebbero di portare a termine le operazioni↩︎ se vuoi saperne di più clicca qui↩︎ usa un motore di ricerca per cercare “installare RStudio video” e appariranno i link a decine di video, più o meno efficaci, un tributo alla necessità di essere rassicurati, immagino.↩︎ e ti spinge a pensare a quello che stai facendo, soprattutto in termini di analisi statistica, il che é un’ottima cosa↩︎ non sono riuscito a trovare la fonte originale dell’immagine, che comunque ho modificato; il candidato più probabile è qui↩︎ per quanto di alto livello, cioé relativamente vicino al linguaggio naturale↩︎ R può essere molto “sensibile”, basta usare male maiuscole o minuscole o non scrivere esattamente il nome di una funzione o di un parametro per ottenere soltanto un messaggio di errore, qualche volta molto criptico; fortunatamente RStudio ti aiuta con suggerimenti e altro, cosa che non fa la scontrosa GUI di R, che è progettata per i puri e duri↩︎ a meno che, come vedremo dopo, tu non conservi una traccia di quello che hai fatto sotto forma di uno script↩︎ incidentalmente questo libro è scritto con R markdown e trasformato in un libro con bookdown e, nel futuro, i tutorial saranno prodotti con learnr↩︎ sul sito di Bookdown↩︎ "],["inter.html", "2 Interfacce e ambienti 2.1 Cosa c’è da imparare in questo capitolo. 2.2 RStudio. 2.3 Esercizi. 2.4 Altre risorse.", " 2 Interfacce e ambienti v1.1 30/10/2023 2.1 Cosa c’è da imparare in questo capitolo. A questo punto dovresti già aver installato R e RStudio e la libreria Rcmdr, necessaria per eseguire l’interfaccia grafica di R Commander. Se non lo hai fatto, ti tocca tornare al capitolo 1 (senza passare dal via). In questo capitolo imparerai abbastanza dell’ambiente di sviluppo RStudio (nella sua versione gratuita) da poter eseguire i primi comandi, installare pacchetti, ottenere aiuto e cominciare ad esplorare set di dati o aprire file, tutti argomenti necessari per affrontare i prossimi capitoli. In questo capitolo NON descriverò la GUI di R né R Commander. Le ragioni di questa scelta sono state spiegate nel capitolo 1. Se vuoi saperne di più sulla GUI di R puoi consultare la Sezione 2.4. 2.2 RStudio. Mentre la GUI di R è sicuramente adatta ai puristi (e, incidentalmente fornisce un interfaccia minima che ti espone al minimo possibile di errori dovuti alla GUI piuttosto che al codice), RStudio è diventato l’ambiente più utilizzato per sfruttare al massimo le potenzialità di R: facilita moltissimo un gran numero di attività di routine (esecuzione di comandi e script, apertura e salvataggio di file, visualizzazione dei grafici, redazione di report, etc.) e attività per utenti più esperti (collegamanto a repositories come GitHub, pubblicazione in rete, accesso al terminale, etc.). 2.2.1 L’interfaccia principale di RStudio. All’apertura, RStudio mostra una finestra divisa in 3 o 4 pannelli (panes; il pannello del codice, source pane non è sempre presente e, in generale, la configurazione dei pannelli dipende dal contesto e dalle preferenze impostate dall’utente)27. Figura 2.1: L’interfaccia di RStudio per MacOS. La barra dei menu include elementi tipici di molti altri software (&lt;File&gt;, &lt;Edit&gt;, &lt;View&gt;, &lt;Window&gt;, &lt;Help&gt;) ed elementi specifici di RStudio, come &lt;Code&gt;, &lt;Plots&gt;, &lt;Session&gt;, &lt;Build&gt;, &lt;Debug&gt;, &lt;Profile&gt;, &lt;Tools&gt;. I menu sono contestuali, con elementi che possono variare in funzione del tab (o scheda) attivo e dei suoi contenuti. Molte funzionalità sono ovvie, altre le descriverò quando sarà necessario. I quattro pannelli principali28 sono: Source: il pannello del codice, dove verranno creati o aperti script, documenti di R Markdown (un formato per la creazione di rapporti) e altri documenti eseguibili e dove verranno visualizzati oggetti come tabelle (data frame, in R) Console: è l’equivalente della console di R, ma permette anche di accedere al Terminale (per l’esecuzione di comandi di sistema) e altri pannelli, come, fra le altre cose, quelli di debugging (per esplorare e correggere gli errori di esecuzione delle funzioni). E’ qui che il prompt dei comandi lampeggia sinistramente Environment: a sua volta contiene una serie di tab o schede che permettono di accedere, fra le altre cose: Environment: o ambiente, è dove appariranno gli oggetti, che potranno essere visualizzati o “interrogati” (vedi capitolo 3) History: storia, un registro dei comandi che sono stati eseguiti durante una sessione di lavoro29 Plots: a sua volta contiene una serie di tab che permettono di accedere, a: Files: un semplice browser della gerarchia dei file nella cartella di lavoro (vedi capitoli 1 e 4) Plots: è qui che vengono visualizzati i grafici generati durante un’analisi, sotto forma di uno stack (pila) navigabile. Discuteremo di questo aspetto nel capitolo 6 Packages: dove è possibile accedere ai pacchetti installati nel sistema, installarne altri o aggiornarli Help: permette di accedere alle funzioni di aiuto Viewer: permette di visualizzare documenti .html Tutti i pannelli e tab hanno menu contestuali a icone, che permettono di accedere rapidamente alle funzioni più importanti, e, in alcuni casi, campi che consentono di effettuare una ricerca di testo all’interno del pannello. E’ inoltre possibile personalizzare e ridimensionare i pannelli: portando il cursore sul bordo del pannello vedrai apparire una doppia freccia, cliccando e trascinato puoi ridimensionare; cliccando sui rettangoli in alto a destra in ogni pannello puoi collassarli o espanderli. RStudio è un’interfaccia complessa e molto ricca di funzionalità e non ha molto senso descriverle dettagliatamente tutte. Nella Sezione 2.4 troverai riferimenti a filmati, documenti e pagine web. Di seguito, esploreremo le funzioni più importanti dei pannelli principali, mentre altre saranno descritte ogni volta che sarà necessario. 2.2.2 Il pannello Source. Bene, ora tocca a te esplorare l’interfaccia. Apri un nuovo file di script. Puoi farlo via menu (&lt;File -&gt; New file -&gt; R script&gt;), con la sequenza di tasti &lt;cmd-shift-N&gt;, o usando l’icona ad accesso rapido per la creazione di nuovi file. Figura 2.2: Aprire un nuovo file di script. Il risultato è una finestra desolantemente (o promettentemente) vuota, nella quale puoi scrivere comandi che potranno essere eseguiti singolarmente o in batch (più righe o l’intero script) per automatizzare un flusso di analisi. La finestra non è altro che un piccolo editor di testi, con alcune funzioni che rendono particolarmente conveniente l’uso di RStudio rispetto alla GUI di R. Prova ora a scrivere i comandi visualizzati nella figura 2.3, uno per volta, premendo il tasto invio alla fine di ogni riga. Noterai, mentre scrivi, che RStudio offre una serie di suggerimenti (vedi l’esempio per mean()), che è possibile autocompletare premendo il tasto di tabulazione, generando ulteriori suggerimenti o facendo apparire dei piccoli “fumetti” che fungono da promemoria per la sintassi di una funzione o addirittura aprendo e chiudendo parentesi e virgolette per te. Prova con mean: inizia a scrivere lentamente, una lettera per volta, e vedrai che appare un piccolo menu a tendina, le cui opzioni si restringono man mano che vai avanti. Puoi usare i tasti freccia in basso o in alto per navigare nel menu e premere tab o cliccare con il mouse quando sei soddisfatt*30. La funzione verrà completata (compresa di parentesi), e il cursore verrà posizionato all’interno delle parentesi: nota come spostando il cursore dopo una parentesi chiusa sia possibile individuare la parentesi aperta corrispondente, una cosa utilissima quando ci sono molte parentesi annidate!. A questo punto, all’interno delle parentesi scrivi mtcars$mpg, senza premere invio31. Figura 2.3: Il mio primo script. Avrai notato che premendo invio non viene prodotto alcun output: il cursore si muove semplicemente alla riga successiva. La differenza fondamentale fra il pannello Source e la Console è che i comandi scritti nel primo non sono destinati ad essere eseguiti in modo interattivo, ma, appunto, in gruppi o tutti insieme. A questo punto dovresti avere nella console i seguenti comandi: data(mtcars) help(&quot;mtcars&quot;) View(mtcars) plot(mtcars$wt, mtcars$mpg) mean(mtcars$mpg) Prova a selezionarli tutti e a premere &lt;cmd-invio&gt; o ad usare l’icona di accesso rapido Run che vedi in alto nel pannello Source32. Il risultato è nella figura 2.4. Figura 2.4: L’output del mio primo script. Ed ecco qui l’output inserito direttamente in questo testo33: data(mtcars) help(&quot;mtcars&quot;) head(mtcars, 20) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 plot(mtcars$wt, mtcars$mpg) mean(mtcars$mpg) ## [1] 20.09062 Qui, per rendere l’output meno lungo, qui ho stampato solo 20 righe di mtcars usando il comando head(mtcars, 20). Come potrai notare: nel pannello Source è apparsa, in un nuovo tab, la tabella corrispondente all’oggetto mtcars; nella Console è apparso “l’eco” dei comandi (come se fossero stati scritti ed eseguiti lì) e il risultato della funzione mean(mtcars$mpg), che calcola appunto la media aritmetica della variabile mpg del data frame mtcars; nel pannello Environment è apparso l’oggetto mtcars; nel pannello Plot è apparso il grafico a dispersione delle due variabili weight e mpg; cliccando sul tab Help del pannello Plot è possibile vedere l’output della funzione help(\"mtcars\"), una descrizione di questo particolare set di dati, uno dei molti inclusi con la versione base e i pacchetti di R Nota inoltre che il nome del tab dello script è in rosso (Untitled1): puoi facilmente attivare questo tab cliccando sul titolo e salvare lo script con &lt;File-&gt;Save&gt;, che aprirà la caratteristica finestra di salvataggio del tuo sistema operativo34. Eccellente! Hai condotto la tua prima (micro)analisi grafica e statistica con R operando in modo “batch”. Adesso prenditi un po’ di tempo per esplorare il tab contenente i dati, cliccando sui nomi delle variabili, usando la barra di scrolling, provando ad usare l’icona filter o a scrivere qualcosa nel campo di ricerca (con la lente d’ingrandimento). Quando sei pront* chiudi questo tab cliccando sulla piccola x immediatamente a fianco del nome del tab35. Prova ora ad esplorare il tab dello script (che dovrebbe avere il nome Untitled1, o qualcosa di simile) e le icone di accesso rapido. Nota come le righe siano numerate e come una barra verticale grigia segni il limite di 80 caratteri.36 Dato che si tratta di un piccolo editor di testi puoi usare funzioni come trova e sostituisci, conta parole, (menu &lt;Edit&gt;) etc.: in realtà, potresti scrivere uno script di R in qualsiasi editor di testi e incollarlo in una finestra di script vuoto o salvarlo come testo e aprirlo in RStudio… Chiudendo questo tab (come per il precedente basta cliccare sulla x accanto al nome) apparirà un menu a comparsa che ti chiederà se vuoi salvare lo script. Puoi scegliere una qualsiasi delle opzioni: torneremo sul salvataggio degli script più avanti. 2.2.3 Il pannello Console. Prova ora a scrivere i comandi direttamente nella Console, premendo invio alla fine di ogni comando: &gt;data(mtcars) &gt;help(&quot;mtcars&quot;) &gt;View(mtcars) &gt;plot(mtcars$wt, mtcars$mpg) &gt;mean(mtcars$mpg) Stai ora operando in modo interattivo: l’effetto di ogni comando è immediato37, ma non è differente da quello che hai osservato prima38. Prova ora a scrivere, sempre nella Console, i seguenti comandi: &gt;1+2*log10(10)-3 &gt;a &lt;- 1L &gt;b = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) &gt;c &lt;- c(1, 2, 3) &gt;list(numero = a, vettore_string = b) -&gt; la_mia_prima_lista &gt;calcola_media &lt;- function(vettore_numerico){mean(vettore_numerico)} &gt;c &gt;calcola_media(c) Il primo comando permette di dimostrare come la console possa funzionare come una piccola calcolatrice, restituendo immediatamente il risultato di un calcolo, senza attribuirlo a nessun oggetto (il risultato è qui sotto). 1+2*log10(10)-3 ## [1] 0 Il secondo comando assegna un oggetto (un vettore di lunghezza 1, con valore 1, intero) al nome a. il terzo comando assegna al nome b il valore di un vettore carattere di lunghezza 3 (un oggetto). il quarto comando assegna al nome c un vettore di numeri (reali) di lunghezza 3 (un oggetto). il quinto comando assegna al nome la_mia_prima_lista una lista (un particolare oggetto di R vedi capitolo 3). il sesto comando assegna al nome calcola_media una funzione definita dall’utente. il settimo comando “stampa” nella console il valore dell’oggetto c.39 l’ottavo comando usa il vettore c come argomento della funzione calcola_media e invia il risultato alla console40 Ed ecco i risultati: 1+2*log10(10)-3 ## [1] 0 a &lt;- 1L b = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) c &lt;- c(1, 2, 3) list(numero = a, vettore_string = b) -&gt; la_mia_prima_lista calcola_media &lt;- function(vettore_numerico){mean(vettore_numerico)} c ## [1] 1 2 3 calcola_media(c) ## [1] 2 Della sintassi di questi comandi discuteremo più avanti. E’ importante notare come: il primo comando produce un output (il risultato del calcolo) nella console, ma non determina la creazione di nessun oggetto nell’ambiente. Il settimo comando usa un oggetto già creato per ottenere un output nella console. i comandi da 2 a 6 creano oggetti (che appaiono nel pannello Environment, vedi dopo) ma non producono un output nella Console. tre comandi (vedi sotto) usano tre modi, tutti validi, di attribuire valori, ma il preferito è sicuramente il secondo (c &lt;- c(1, 2, 3)) # assegnare con = b = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) # assegnare con &lt;-, il modo preferito c &lt;- c(1, 2, 3) # assegnare con -&gt; list(numero = a, vettore_string = b) -&gt; la_mia_prima_lista Bene!!!: con poco sforzo, sei riuscit* a scrivere i primi comandi in R, a creare oggetti e a fare calcoli!!! Incidentalmente, il pannello Console contiene altri tab, alcuni contestuali, come quelli relativi a RMarkdown41 o per il debugging42) e altri come Terminal43 e Jobs44 sono decisamente destinati a utenti meno “pigri”. 2.2.4 Il pannello Environment. E’ un pannello particolarmente importante, che può contenere diversi tab, che ti troverai ad usare di frequente. 2.2.5 Il tab Environment. Il tab Environment del pannello Environment permette di esplorare l’ambiente di lavoro e gli oggetti in esso contenuti, di salvare e importare oggetti di diverso tipo. Il piccolo spazio con la lente di ingrandimento in alto a destra, come di consueto, consente di condurre una ricerca per nome in ambienti particolarmente affollati. Figura 2.5: Il pannello Environment. Se hai seguito le istruzioni del paragrafo precedente, il tuo ambiente di lavoro dovrebbe contenere gli stessi oggetti riportati nella figura 2.5. Alcuni dei tasti di accesso rapido e dei menu contestuali possono variare in funzione di azioni precedenti o delle versioni di RStudio. Nel capitolo 4 descriverò in dettaglio come aprire e salvare file, ma, per iniziare possiamo fare una piccola prova: clicca sull’icona per il salvataggio dell’ambiente (il floppy disk), nella finestra di salvataggio che si apre scegli una destinazione e un nome per il file e clicca su &lt;Save&gt;. In questo modo hai salvato l’intero ambiente di lavoro sotto forma di file binario .Rdata: questo formato contiene sia gli oggetti che i loro nomi45. Contemporaneamente, vedrai apparire nella console l’eco di questo comando da menu. clicca sulla piccola icona a forma di scopa: questo comando richiede una conferma ed elimina tutti gli oggetti dall’ambiente di lavoro.46. Anche in questo caso lo stesso risultato poteva essere ottenuto con un comando.47 usa l’icona a forma di cartella per riaprire il file che avevi salvato al punto 1: vedrai riapparire esattamente gli stessi oggetti. Prova ora a “esplorare” gli oggetti, cliccando, dove esistono, sui piccoli triangoli bianchi su sfondo blu accanto ai nomi, o sui nomi degli oggetti: osserva l’effetto delle tue azioni e guarda cosa appare nella Console in seguito ad ogni azione… 2.2.6 Il tab History. Il tab History del pannello Environment consente di accedere rapidamente ai comandi eseguiti. La “storia” dei comandi può essere salvata48 e i file salvati possono essere aperti nel medesimo tab. Gruppi di comandi selezionati possono essere spostati nella Console o nello script attivo nel pannello degli Script, dove poi possono essere eseguiti. E’ inoltre possibile rimuovere singoli comandi, o, usando l’icona a forma di scopa, l’intera storia dei comandi. Incidentalmente, è possibile richiamare i comandi direttamente dalla Console, usando i tasti &lt;freccia su&gt; (richiama i comandi precedenti) o &lt;freccia giù&gt; (richiama quelli successivi al comando appena richiamato, se esistono). Figura 2.6: Il tab History. Prova tu stess*: attiva la Console cliccando al suo interno o con la combinazione di tasti &lt;ctrl-2&gt;; usa il tasto &lt;freccia su&gt; per scorrere fra i comandi, scegline uno e eseguilo premendo invio. prova a salvare tutta la History, cancellarla e importare quella salvata. 2.2.7 Il pannello Plots. Il pannello Plots dà accesso a diverse risorse importanti, tramite i tab Plots, Files, Packages, Help e Viewer. I primi 4 verranno descritti in maggiore dettaglio qui sotto; l’ultimo tab (Viewer) permette di esplorare documenti .html, come quelli generati a partire da RMarkdown. 2.2.8 Il tab Plots. Il tab Plots del pannello Plots, croce e delizia degli utenti di RStudio, è mostrato nella figura 2.7. Figura 2.7: Il tab Plots. La figura mostra l’output del comando plot(mtcars$wt, mtcars$mpg), con un grafico a dispersione un tantino minimalista49. Il tab accumula, sotto forma di stack (pila) i grafici prodotti dalla sessione. E’ possibile navigare in questo tab usando le icone ad accesso rapido o il menu &lt;Plots&gt;. Fra le icone ad accesso rapido di questo tab: le due frecce permettono di navigare fra i grafici prodotti; il tasto Zoom permette di ingrandire il grafico e di ridimensionarlo dinamicamente (trascinandone i bordi): questa caratteristica può generare confusione perché, se si salva il grafico, le dimensioni e il rapporto fra le proporzioni50 non sono quelle visibili nel pannello. Il tasto Export apre un menu a comparsa che consente di esportare il grafico in un formato immagine51; i due tasti successivi consentono di eliminare dallo stack il grafico corrente o tutti i grafici l’opzione Publish permette di pubblicare il grafico online52 Discuteremo in maggiore dettaglio della grafica con R nel capitolo 6. 2.2.9 Il tab Files. Il tab Files del pannello Plot permette di navigare il file system del tuo computer. La barra dei menu mostra il percorso di cartelle e sottocartelle (in genere a partire dalla Home). Cliccando sui file è possibile aprirli (in RStudio o con l’applicazione più adatta). Figura 2.8: Il tab Files. Prova (con un po’ di prudenza) a esplorare questo tab e, in particolare, il menu a comparsa disponibile sotto l’icona More. 2.2.10 Il tab Packages. Il tab Packages del pannello Plot è, indubbiamente, uno dei più utili: è qui che, con poco sforzo, puoi verificare quale pacchetti sono installati nella tua libreria, aggiornarli, caricarli nell’ambiente di lavoro, esplorarne l’aiuto, installarne di nuovi etc.53 I tasti di accesso rapido e le funzioni di questo tab sono molto intuitivi, e non necessitano di particolari spiegazioni, nemmeno per i più pigri. Figura 2.9: Il tab Packages. Per dimostrare l’uso di questo tab: osserva come i pacchetti caricati nell’ambiente hanno un segno di spunta; per ogni pacchetto è disponibile una breve descrizione; cliccando sul nome di un pacchetto è possibile accedere all’aiuto del pacchetto; le due piccole icone alla fine di ogni riga consentono di visualizzare un pacchetto sul repository del CRAN ed eliminarlo dalla libreria; il tasto Update richiama una lista dei pacchetti per i quali è disponibile una versione più aggiornata; il menu a comparsa che si apre è di uso molto intuitivo e non richiede particolari spiegazioni;54 il tasto Install ti consente di installare, in maniera interattiva, nuovi pacchetti; come si vede dalla figura 2.9 mentre digiti ti appariranno delle opzioni di autocompilazione; è inoltre possibile installare più di un pacchetto contemporaneamente. Prova ora a installare il pacchetto tidyverse: si tratta di un insieme di pacchetti per la scienza dei dati che useremo spessissimo in questo libro, basati sul concetto di tidy data, di cui parleremo ampiamente nel capitolo 955. Come sempre, è possibile utilizzare i comandi per: sapere quali pacchetti sono installati nella tua libreria; installare nuovi pacchetti; caricarli in memoria; Un esempio di codice è riportato di seguito (nota come tutte queste funzioni sono usate con le opzioni di default; nel capitolo 3, dedicato all’aiuto, esploreremo in dettaglio altre opzioni) # il comando successivo assegna l&#39;elenco dei pacchetti disponibili in libreria # (un vettore carattere) al nome mypckgs # i cui primi elementi vengono poi stampati a Console &gt; mypckgs &lt;- installed.packages() &gt; head(mypckgs, n = 5L) # installa il pacchetto car, un pacchetto di strumenti per la regressione &gt; install.packages(&quot;car&quot;, repos = &quot;https://cran.mirror.garr.it/CRAN/&quot;) # carica il pacchetto nell&#39;ambiente di lavoro: è anche possibile usare require() &gt; library(car) 2.2.11 Il tab Help. Anche questo tab è disponibile nel pannello Plots. Questo è probabilmente uno dei tab che “visiterai” più spesso. Le sue funzionalità verranno descritte nel capitolo 3. Le icone di accesso rapido e i campi di ricerca sono piuttosto intuitivi: prova a cercare aiuto sulle funzioni che sono state illustrate nei paragrafi precedenti o a raggiungere la “Home” e esplorare alcuni degli argomenti dell’aiuto, in particolare quelli relativi alla IDE di RStudio. Figura 2.10: Il tab Help. 2.3 Esercizi. Bene, come hai visto, qualche piccolo esercizio ti è stato proposto nei paragrafi precedenti. Per quanto pigri, senza pratica ed esercizio non c’è proprio modo di imparare ad usare R. Nei capitoli successivi ti proporrò qualche esercizio un pochino più complesso. Ricorda che sono disponibili risorse interattive, come learnR. Alcuni tutorial online sono disponibili qui. 2.4 Altre risorse. Come sempre, ti indicherò soltanto le risorse minime che ritengo migliori o più efficaci da un punto di vista didattico. Sentiti liber* di esplorare secondo il tuo estro il vasto mare della documentazione su R. 2.4.1 Risorse in italiano. Documenti e pagine web Purtroppo i documenti e le pagine su R in lingua italiana sono piuttosto rar* e spesso non aggiornat*. Un manuale vecchiotto sul linguaggio è qui. Francamente non sono riuscito a trovare altro che valga la pena di citare (se non forse il materiale, piuttosto formale, per qualche corso universitario). Video. Un video di Federica web learning sull’installazione di R e RStudio con una breve descrizione delle interfacce 2.4.2 Risorse in inglese. Documenti e pagine web. Ecco una selezione di eccellenti capitoli introduttivi da libri in inglese, tutti disponibili online e gratuiti (se siete pigri sceglietene uno qualsiasi): Il capitolo 1 di ModernDive Il capitolo 1 di Just enough R Il capitolo 3 di R and RStudio basics (un po’ più orientato al lavoro nel cloud) Il materiale didattico presente sul sito di RStudio Education è eccellente e prevede percorsi differenziati per utenti principianti, intermedi ed avanzati. Potete scaricare una cheat sheet per la IDE di RStudio qui. In generale le cheat sheet forniscono un riferimento rapido all’interfaccia e ai comandi ed è sempre utile averle a portata di mano. Molti altri eccellenti e dettagliati documenti sono disponibili nella sezione sulla documentazione del CRAN. In particolare un manuale (vecchiotto) per R commander è qui. Video. Ci sono probabilmente migliaia di video che descrivono l’installazione di R, RStudio e le relative GUI. Questo è un buon esempio (circa 50 min). Il video ufficiale di RStudio è qui. Un video di circa 30 minuti sulle GUI di R, R commander e RStudio con sottotitoli accettabili è qui Per diversi video è possibile attivare i sottotitoli in italiano (con pochissime garanzie sulla qualità delle traduzioni). incluso lo schema di colori, visita le &lt;Preferences&gt; sotto la voce &lt;Appearence&gt;, &lt;Pane layout&gt;, etc.↩︎ è possibile spostarsi rapidamente fra questi pannelli usando l’abbreviazione di tastiera &lt;ctrl-1&gt;, &lt;ctrl-2&gt;, &lt;ctrl-3&gt; o &lt;ctrl-4&gt;; nel menu &lt;View&gt; viene indicata come &lt;^1&gt; etc.↩︎ o persino una sessione precedente; R può ricaricare, all’apertura, l’ambiente e la storia della sessione precedente↩︎ Questo libro è assolutamente gender neutral, ma spero di riuscire a ricordarmelo sempre.↩︎ se premessi invio, semplicemente, la parentesi chiusa andrebbe a capo, provare per credere↩︎ in altri casi &lt;Run&gt; permette di aprire un menu contestuale con molte opzioni diverse↩︎ RMarkdown consente di integrare i risultati dell’analisi statistica e grafica in un testo come questo; ne parleremo diffusamente più avantiriferimento↩︎ in questo caso è possibile scegliere la destinazione del file↩︎ niente paura, potremo riaprire il tab View per l’oggetto mtcars in almeno due modi diversi↩︎ un residuo dell’era dei dinosauri↩︎ se il comando è completo ed interpretabile, altrimenti otterrai un cursore a forma di + che indica che R è in attesa del completamento del comando, o un messaggio di errore↩︎ e incidentalmente corrisponde a quello che sarebbe accaduto se avessi premuto &lt;cmd-invio&gt; al termine di ogni riga dello script, provare per credere.↩︎ è l’equivalente di scrivere print(c)↩︎ l’equivalente è scrivere mean(c)↩︎ la libreria di R usata per creare report, e, fra le altre cose, questo libro↩︎ la ricerca di errori in una funzione o, più in generale, nel codice↩︎ accesso diretto allo shell di sistema, per interagire con il sistema operativo tramite la linea di comando; può essere utile per lanciare programmi non accessibili tramite l’interfaccia grafica↩︎ consente di avviare l’esecuzione di script R o Python in “background”, permettendo di condurre calcoli lunghi o complicati mentre l’utente usa la sessione di RStudio per altri scopi↩︎ questo è equivalente a usare il comando save.image(); vedremo che è possibile salvare anche solo alcuni degli oggetti usando il comando save()↩︎ non preoccuparti, li recuperiamo fra un attimo o puoi eseguire i comandi descritti nei paragrafi precedenti↩︎ rm(list = ls())↩︎ con estensione .Rhistory↩︎ le opzioni del comando plot() sono formidabili, e difficili da ricordare…↩︎ che, di default, rispetta la sezione aurea, con un rapporto di 1,61 fra larghezza e lunghezza↩︎ è meglio non fare troppo conto su questa opzione, perché la risoluzione di esportazione è quella dello schermo, ampiamente insufficiente per una pubblicazione scientifica↩︎ se avete settato correttamente le opzioni nelle preferenze↩︎ naturalmente, è possibile fare tutte queste cose con i comandi, vedi dopo↩︎ in alcuni casi, durante il processo di aggiornamento ti verrà segnalato che esiste una versione “source” più aggiornata della versione “binary” e ti verrà offerta l’opzione se installare la versione più aggiornata, che potrebbe richiedere la compilazione; in questo caso potresti avere bisogno fi alcuni strumenti di sviluppo, installabili direttamente dal sito del CRAN (compilatori C++ o FORTRAN) se non sono già presenti sul tuo sistema; in linea di massima è più semplice installare le versioni binarie, che non richiedono compilazione↩︎ nota come la casella Install dependencies del menu a comparsa Install è selezionata di default: le “dependencies” sono i pacchetti da cui, letteralmente, dipende il pacchetto che stai installando, perché le funzioni del pacchetto, a loro volta, ne usano le funzioni; installando alcuni pacchetti vedrai installate numerosissime dependencies, quindi la tua libreria si arricchirà rapidamente↩︎ "],["aiuto.html", "3 Chiedere aiuto 3.1 Cosa c’è da imparare in questo capitolo. 3.2 L’aiuto di R. 3.3 Strategie per cercare aiuto (anche senza parere). 3.4 Esercizi. 3.5 Altre risorse.", " 3 Chiedere aiuto v1.2 30/10/2023 3.1 Cosa c’è da imparare in questo capitolo. Cercare aiuto in R è una necessità costante, anche per utenti esperti: la documentazione, prevalentemente in inglese, è dispersa in un gran numero di fonti e cercare una funzione che permetta di raggiungere un determinato scopo e poi impararne la sintassi e i valori che restituisce non è sempre facile. In questo capitolo cercherò di: dare il minimo di informazioni indispensabili per utilizzare le funzioni di aiuto (Help) di R e in particolare su come sfruttare al meglio il tab Help di RStudio fornire un elenco delle risorse (siti web, forum, blog, etc.) più utili dare qualche piccolo suggerimento per sviluppare una strategia di ricerca di aiuto efficace Non tutto il materiale di questo capitolo è essenziale, benché leggerlo con attenzione potrebbe facilitare l’apprendimento di R. Se proprio hai fretta, puoi leggere solo il paragrafo 3.2.1 sul tab Help di RStudio e quello sulle strategie per cercare aiuto, e magari tornare a questo capitolo in seguito. I paragrafi con il titolo in corsivo sono degli approfondimenti. 3.1.1 Premessa 1: nessuno legge i manuali (figuriamoci i pigRi)! Diciamo le cose come stanno: al giorno d’oggi ci aspettiamo che il software sia a prova di idiota (tipicamente noi) e che per imparare ad usarlo sia sufficiente fare qualche tentativo. Purtroppo, anche se molte funzioni di R sono abbastanza intuitive, anche nel nome56 e hanno parametri semplici da utilizzare, senza conoscerne l’ortografia (come si scrive il nome di una funzione o di un comando) e la sintassi (quali parametri sono necessari e come vanno forniti alla funzione) non si va proprio da nessuna parte. Insomma, un po’ di cose vi tocca leggerle. Prendi la figura 3.1 come un’amichevole esortazione: che tu sia pigR* o troppo occupat*, questo libro è il posto giusto per trovare il minimo indispensabile di informazioni su come cercare aiuto in R. Figura 3.1: Leggi il f*****o manuale. 3.1.2 Premessa 2: ci sono molti modi di pelare un gatto (e documentarlo). Un altro aspetto che può confondere le idee ai principianti è che in R lo stesso risultato può essere ottenuto in molti modi diversi. In pratica, anche per le cose più semplici, ci sono molti modi per pelare un gatto: questo dipende dal fatto che persone diverse hanno stili diversi di programmazione o usano per lo stesso scopo pacchetti diversi. Comprendere il codice scritto da altri è molto importante nell’apprendimento di R. Figura 3.2: La pelle del gatto. Immaginiamo di voler calcolare la mediana (un indicatore di tendenza centrale, adatto a descrivere un gran numero di distribuzioni continue, vedi capitolo 7) per un certo numero di vettori (vedi capitolo 4) della stessa lunghezza, riuniti in una tabella (in realtà un tipo particolare di data frame, una tibble, vedi capitolo 4). Si tratta di un’operazione banale, che richiede una sola funzione, ma il problema può essere approcciato in molti modi diversi, più o meno efficienti (in termini di tempo di calcolo) e più o meno leggibili (in termini di comprensibilità del codice). Un modo semplice per confrontare l’efficienza è quella di misurare il tempo necessario per svolgere un determinato calcolo. Nell’esempio successivo confronterò 5 modi diversi di calcolare la mediana sulle colonne di una tabella (qui di 8 colonne e 10.000 righe, ma puoi aumentare arbitrariamente sia il numero di righe che di colonne) usando funzioni di R base e del pacchetto tidyverse. Non preoccuparti ora di capire fino in fondo la sintassi, ma nota come nell’ouptput le mediane siano sempre uguali57, mentre cambia il tempo di esecuzione. # creo un data frame (in realtà una tibble) con numeri casuali # estratti da una distribuzione uniforme # installa il pacchetto e caricalo se necessario rimuovendo il segno di commento # ed eseguendo i due comandi successivi # install.packages (&quot;tidyverse&quot;) # require(tidyverse) # numero di righe o casi nella tabella df n_casi &lt;- 10000 # creo la tibble df &lt;- tibble( a = rnorm(n_casi), b = rnorm(n_casi), c = rnorm(n_casi), d = rnorm(n_casi), e = rnorm(n_casi), f = rnorm(n_casi), g = rnorm(n_casi), h =rnorm(n_casi)) # il data frame df ## # A tibble: 10,000 × 8 ## a b c d e f g h ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.613 -1.41 -0.648 2.07 -1.66 -0.209 0.565 1.13 ## 2 -0.467 1.23 1.17 -0.166 -0.553 -1.22 1.14 -0.961 ## 3 0.774 0.337 0.0334 -1.86 2.02 -1.36 0.547 -0.656 ## 4 -0.326 1.18 -0.609 -0.476 -0.717 -0.969 0.617 -2.35 ## 5 1.27 -0.676 0.480 -0.204 1.27 0.135 1.29 1.21 ## 6 -0.651 0.457 0.413 -0.789 -1.05 -0.286 -0.556 -2.30 ## 7 0.0842 -1.42 0.344 0.370 -0.212 2.57 0.529 -0.122 ## 8 0.840 -1.05 -0.394 -1.22 -0.838 0.393 1.95 1.33 ## 9 -2.48 0.253 0.331 -1.11 1.69 -0.340 0.338 0.753 ## 10 0.509 0.429 1.68 1.05 0.304 1.49 1.03 1.24 ## # ℹ 9,990 more rows tempo0 &lt;- Sys.time() # inizializza it tempo con il tempo di sistema # 1. uso la stessa funzione su ciascuna colonna e unisco i risultati # in un vettore con la funzione c() mediane &lt;- c(median(df$a), median(df$b), median(df$c), median(df$d), median(df$e), median(df$f), median(df$g), median(df$h)) # memorizzo il valore del tempo trascorso chiamate_multiple &lt;- Sys.time()-tempo0 # stampo a console un messaggio informativo con la funzione cat(); \\n crea # un ritorno a capo cat(&quot;mediane con chiamate singole\\n&quot;) ## mediane con chiamate singole # &quot;stampo&quot; a console il risultato mediane ## [1] 0.011721821 -0.003522343 0.008740360 0.021575367 0.007703442 ## [6] 0.007912362 0.003686531 0.012488419 # il risultato è un vettore, privo dell&#39;attributo nomi # (identificante ogni elemento del vettore), # che poteva essere aggiunto usando, per esempio a = median(df$a) # 2. uso di un loop sulle colonne tempo0 &lt;- Sys.time() # inizializzo un vettore che riceverà i risultati output &lt;- vector(&quot;double&quot;, length = ncol(df)) # creo l&#39;output con un loop for for (i in seq_along(df)) { # la sequenza output[[i]] &lt;- median(df[[i]]) # il corpo del loop } uso_un_loop &lt;- Sys.time()-tempo0 cat(&quot;mediane con loop for\\n&quot;) ## mediane con loop for output ## [1] 0.011721821 -0.003522343 0.008740360 0.021575367 0.007703442 ## [6] 0.007912362 0.003686531 0.012488419 # 3. uso di apply() tempo0 &lt;- Sys.time() # apply &quot;applica&quot; la funzione median alla dimensione 2 (le colonne) di df mediane_apply &lt;- apply(df, 2, median) uso_apply &lt;- Sys.time()-tempo0 cat(&quot;mediane con apply\\n&quot;) ## mediane con apply mediane_apply ## a b c d e f ## 0.011721821 -0.003522343 0.008740360 0.021575367 0.007703442 0.007912362 ## g h ## 0.003686531 0.012488419 # 4. uso la funzione map_dbl() del pacchetto purrr del tidyverse tempo0 &lt;- Sys.time() # map_dbl &quot;applica&quot; la funzione median alle colonne di df le_mie_mediane &lt;- map_dbl(df, median) con_purrr &lt;- Sys.time()-tempo0 cat(&quot;\\nmediane con purrr:map_dbl()\\n&quot;) ## ## mediane con purrr:map_dbl() le_mie_mediane ## a b c d e f ## 0.011721821 -0.003522343 0.008740360 0.021575367 0.007703442 0.007912362 ## g h ## 0.003686531 0.012488419 # creo un vettore con i tempi calcolati per ciascuna modalità tempi &lt;- c(multiple = chiamate_multiple, loop = uso_un_loop, apply = uso_apply, purrr = con_purrr) cat(&quot;\\ntempi di esecuzione\\n&quot;) ## ## tempi di esecuzione tempi ## Time differences in secs ## multiple loop apply purrr ## 0.003331900 0.006615162 0.003798962 0.003101110 Confronta la velocità di esecuzione dei diversi approcci (che potrebbe differire solo di pochi millisecondi).58 I diversi chunk di codice hanno una differente leggibilità: per alcuni è molto facile, anche per un principiante, capire qual’é l’intenzione di chi ha scritto il codice (e quindi è relativamente facile adattarlo alle proprie esigenze), altri (come l’uso di map_dbl()) sono piuttosto criptici ma molto concisi. Quindi, quando (fra pochissimo!) sarai un* programmat* espert* cerca di avere pietà del tuo io passato e futuro (o dei pigri come te) e cerca di scrivere codice chiaro e interpretabile. Nel frattempo vorrei rassicurare tutte e tutti che nessun gatto è stato scuoiato per realizzare questo libro. 3.2 L’aiuto di R. Disclaimer questa sezione è veramente noiosa ma ti tocca leggerla, anche se frettolosamente. R base e i diversi pacchetti sono documentati in molti modi diversi. Per ogni funzione è disponbile una descrizione, che comprende diversi elementi. Ogni pacchetto, sul sito del CRAN è accompagnato da un documento .pdf che descrive, in ordine alfabetico, tutte le funzioni. Per alcuni pacchetti, inoltre, sono disponibili dei documenti più descrittivi, generalmente disponibili come .pdf e/o .html, chiamati vignette. Tutti questi elementi possono essere raggiunti dall’interno di R o RStudio. La documentazione è tutta in inglese, ma usando Google translate in qualche caso è possibile ottenere una ragionevole traduzione. In realtà una conoscenza anche minima dell’inglese tecnico ti permetterà di comprendere abbastanza facilmente i documenti di aiuto. Tuttavia, devi tenere presente che i documenti di aiuto sono scritti da programmatori che possono essere più o meno capaci di comunicare in maniera semplice e efficace e sono, talvolta, pigRi e fRettolosi. 3.2.1 Il tab Help di RStudio. Il tab Help del pannello Plot di RStudio (in genere in basso a destra, vedi capitolo 2) è il punto di accesso principale all’aiuto di R facilita enormemente la ricerca di informazione sulle funzioni. Se clicchi sull’icona a forma di casetta in alto a sinistra nel tab (vedi figura 3.3) puoi raggiungere la home page dell’aiuto, con una serie di link utili. Figura 3.3: Il tab Help. In realtà, al di là dei suggerimenti contestuali che offre RStudio quando si digita qualcosa nella Console o in uno script, ti troverai frequentemente a cercare aiuto su una funzione specifica. È possibile farlo digitandone il nome nel campo di ricerca in alto a destra nel tab Help. Prova a digitare apply nel campo di ricerca, come mostrato nella figura 3.4.59. Figura 3.4: L’aiuto sulla funzione apply. Gli elementi importanti del testo che si ottiene invocando l’aiuto sono: il nome della funzione e il pacchetto cui appartiene (in alto a sinistra, in questo caso apply {base}) un titolo descrittivo una breve descrizione (Description) testuale della funzione la sezione Usage, con la sintassi della funzione la sezione Arguments con l’elenco degli argomenti della funzione, ed, eventualmente, dei loro nomi la sezione Details che fornisce dettagli sull’uso della funzione ed eventuali richiami ad altre funzioni la sezione Value, particolarmente importante perché descrive con precisione quello che la funzione restituisce60 la sezione References con riferimenti bligliografici per la funzione la sezione See Also con richiami ipertestuali ad altre funzioni correlate la sezione Examples, con esempi dell’uso della funzione61 un piè di pagina con la versione del pacchetto cui appartiene la funzione e un link ipertestuale all’indice del pacchetto62. 3.2.2 Funzioni per chiedere aiuto. Oltre che utilizzando il tab Help in RStudio è ovviamente possibile accedere all’aiuto usando una serie di comandi dalla Console. Il blocco di codice successivo mostra una serie di comandi che permettono di accedere: alla pagina di partenza dell’aiuto (help.start()) all’aiuto per una specifica funzione, il cui nome è noto (help() o ? seguito dal nome della funzione) ad una ricerca generale nelle pagine di aiuto (help.search() o ?? seguito dalla parola chiave) a tutte le funzioni che contengono una determinata parola chiave (apropos()) agli esempi per una determinata funzione (example()) ad una determinata vignetta di un dato pacchetto (vignette()) ad una ricerca sul sito di R, comprese le discussioni e i forum (RSiteSearch()) Prova a scrivere (o a copiare e incollare) i seguenti comandi in uno script e ad eseguirli uno alla volta (con command-invio alla fine di ogni comando): # aprire la pagina di aiuto help.start() # aprire la pagina di aiuto per una pagina specifica help(&quot;plot&quot;) # le virgolette sono opzionali; se non si usa l&#39;opzione package verrà mostrato # l&#39;aiuto per l&#39;ultimo pacchetto caricato in memoria (vedi capitolo 4) ?plot # cercare nell&#39;aiuto con una parola chiave help.search(&quot;array&quot;) # in questo caso le virgolette sono obbligatorie ??array # far girare il codice degli esempi di una funzione example(&quot;pretty&quot;) # caricare una vignetta vignette(&quot;embedding&quot;, package = &quot;car&quot;) # cercare le funzioni il cui nome contiene la parola (&quot;plot&quot;) apropos(&quot;plot&quot;, mode = &quot;function&quot;) # cercare nel sito di R una parola chiave RSiteSearch(&quot;scatterplot&quot;) # ottenere una lista dei data set presenti nei pacchetti caricati in memoria data() Ovviamente, in maniera piuttosto ricorsiva, puoi cercare aiuto su ciascuna di queste funzioni: prova a scrivere nella Console: &gt;help(help) Un caveat: il risultato della funzione help(), se non usi l’opzione package potrebbe dipendere dall’ordine con il quale sono caricati i pacchetti; per esempio help(\"filter\") restituirà un risultato diverso se è stato caricato, direttamente o indirettamente, il pacchetto dplyr; prova a scrivere ed eseguire le seguenti linee di codice (se library(dplyr) non funziona prova prima install.packages(\"tidyverse\")): library(dplyr) help(filter) help(filter, package =&quot;dplyr&quot;) help(filter, package =&quot;stats&quot;) 3.3 Strategie per cercare aiuto (anche senza parere). A seconda del tuo grado di “ignoranza” potrebbe essere opportuno usare strategie diverse per cercare aiuto: se conosci il nome della funzione sulla quale vuoi cercare aiuto e sai di che pacchetto fa parte: usa il tab Help o la funzione help(): in RStudio l’aiuto apparirà nel tab Help, leggi almeno le sezioni Description e Usage; è sicuramente utile leggere Arguments e Value e, se non sei certo di aver capito, provare a far girare gli esempi con example() se conosci il nome della funzione (anche approssimativamente) ma non sei cert* del pacchetto cui appartiene: in questo caso help() potrebbe non funzionare, perché restituisce un risultato solo se il pacchetto cui appartiene la funzione è caricato, cosa che è sempre vera con i pacchetti che vengono caricati con R base (base, datasets, graphics, grDevices, methods, stats, utils). In questo caso hai due opzioni: usare help.search() o apropos(): il risultato potrebbe essere difficile da gestire, con un output lungo e non sempre chiarissimo. usare siti di documentazione; ce ne sono due principali, che hanno i vantaggio di condurre la ricerca su praticamente tutti i pacchetti esistenti: RDocumentation ricerca il CRAN e Bioconductor e restituisce risultati sia per i pacchetti che per le funzioni; rdrr.io è molto più completo (ma afflitto da molti più banner pubblicitari) e, fra le altre cose, consente di far girare brevi scripts (snippets) direttamente nel browser. se non conosci nemmeno il nome della funzione che stai cercando ma hai almeno una vaga idea su cosa vuoi fare: qui le cose si fanno difficili, specialmente se non hai una buona conoscenza della lingua inglese, però non disperare, perché hai diverse opzioni: usare Google o il tuo motore di ricerca preferito per condurre una ricerca nel web; prova per esempio a digitare “ANOVA con R” o “aprire un file di testo con R” o “analisi dei network con R”: troverai un discreto numero di hits che, generalmente, ti rimanderanno ai pochi blog o siti su R in italiano o al materiale didattico di qualche corso universitario. Naturalmente la ricerca in inglese è decisamente più produttiva: prova con “ANOVA with R”, “importing text files with R”, “network analysis with R”. In entrambi i casi, con poco sforzo troverai probabilmente la soluzione che cerchi ed avrai il vantaggio di sfruttare l’algoritmo di Google per ottenere per primi i risultati più rilevanti condurre la ricerca su uno dei molti forum o blog su R (vedi la sezione 3.5): in generale i risultati saranno un tantino più pertinenti e le spiegazioni più dettagliate. studiare uno dei molti eccellenti libri (compreso questo) su R: lo so, richiede tempo, ma è un buon investimento In molti casi potresti avere necessità più specifiche, come capire il significato di un messaggio di errore o risolvere un problema di programmazione specifico: anche in questo caso, a parte la lettura di un buon libro, una ricerca libera sul web, specialmente se condotta in inglese, ti permetterà di trovare rapidamente quello che cerchi. Se non lo trovi, puoi persino provare ad avviare un nuovo argomento su un forum: il principale vantaggio di R è probabilmente quello di avere una vasta comunità di utenti, che rispondono (quasi sempre) con gentilezza anche alle domande più stupide. Una lista dei forum e blog più importanti è nella sezione 3.5. Ricorda però che riceverai delle risposte chiare se poni il tuo problema in maniera chiara, per esempio con quello che si chiama reproducible example. Un po’ di traduzioni in italiano di post su questo tema sono qui. 3.4 Esercizi. In attesa di tutorial e esercizi veri e propri realizzati con learnR prova a rispondere a queste domande: Cosa restituisce il comando &gt;help(\"library\")?63 Dove appare l’output in RStudio? In R? cosa succede se digiti nella Console &gt;??library. Come potrai notare l’output di questo comando è piuttosto lungo (dipende da quanti pacchetti hai installato). Ti viene in mente qualche strategia per cercare più rapidamente i risultati più rilevanti? quale comando useresti per trovare una funzione il cui nome contiene una determinata parola chiave (magari anche con una espressione regolare)? che importanti informazioni riporta la sezione Value di una determinata pagina di aiuto? Prova con ?mean, ?saveRDS, ?points e confronta i risultati. quale importante sito sulla documentazione di R consente anche di eseguire frammenti di codice? 3.5 Altre risorse. Come sempre, ti indicherò soltanto le risorse minime che, in maniera forse arbitraria, ritengo migliori o più efficaci da un punto di vista didattico. Sentiti liber* di esplorare secondo il tuo estro il vasto mare della documentazione su R. 3.5.1 Risorse in italiano. Documenti e pagine web Ci sono pochissimi forum e wiki in Italiano e, purtroppo, non vengono aggiornati molto di frequente. La ragione principale è, probabilmente, che anche i programmatori e gli utenti italiani preferiscono l’inglese (e non hanno tutti i torti). Prova con questi blog e Wiki: InsulaR: il sito della comunità cagliaritana degli utenti di R Una interessante wiki curata da una docente in scienze sociali 3.5.2 Risorse in inglese. Documenti e pagine web. I libri, documenti, pagine, forum e wiki su R in inglese sono talmente tanto numerosi che è difficile trovare la propria strada. A parte i due siti fondamentali sulla documentazione (RDdocumentation e rdrr.io), giusto per fare un po’ di ordine provo a citare almeno i 5 link principali per le categorie più importanti (tralasciando ovviamente la documentazione presente sul sito del CRAN). Il criterio di ordinamento è, semplicemente, quello del mio personale livello di gradimento. Libri: eh, sì, ci sono i libri prima di tutto; con un po’ di abilità potete cercare nell’indice quello che vi serve e trovare rapidamente soluzioni ben strutturate. Provate innanzitutto questi (l’ultimo è per utenti avanzati): R for data science: libro assolutamente fondamentale per introdurvi all’analisi dei dati (non necessariamente alla statistica) con R; disponibile on line gratuitamente ma anche come formato cartaceo e epub, ora anche nella versione italiana Just enough R: un approccio abbastanza minimalista all’apprendimento della statistica con R64 Statistical inference via data science: direi un ottimo approccio “tidy” all’inferenza statistica Statistical modelling with R: un libro di statistica con R decisamente più avanzato Advanced R probailmente la bibbia della programmazione con R, solo per avanzati Blog e forum: cito quelli che io visiterei (e visito) per primi se sto cercando risposte alle domande fondamentali; fra le altre cose, blog e forum hanno i “mi piace”65 R bloggers: il blog migliore su R con migliaia di contributori. Incidentalmente, qui trovate un interessante post sul cercare aiuto su R. RStudio community decisamente più specializzato su RStudio e tidyverse Stack Overflow: non è specifico su R ma qui potete trovare risposte alle vostre domande (se fate le domande giuste) Applied R: un blog per utenti decisamente più esperti siti web per l’apprendimento di R: Quick-R: decisamente completo ed efficace Cookbook for R: un pochino disordinato, ma utile 3.5.3 Niente video? Come avrai notato, da questo capitolo non metto più riferiementi a video didattici: sono troppo volatili e, soprattutto ce ne sono tanti di pessimi e la tortura di guardarli per trovare quelli “buoni” è davvero insopportabile. Canali YouTube come DataCamp(https://www.youtube.com/@DataCamp) e Posit offrono video di corsi e seminari gratuiti preparati in maniera professionale. Se ritieni che guardare video sia un buon modo di apprendere, puoi partire da lì. in realtà questo non è proprio vero per la versione di base di R: molti pacchetti, specialmente quelli del tidyverse (vedi capitolo 1 e 4)↩︎ cioé ciascuno dei modi di esecuzione restituisce lo stesso risultato; il realtà, se fai girare lo script diverse volte senza fissare il seme dei numeri casuali il data frame sarà sempre diverso, proprio perché è ottenuto estraendo, in modo casuale, numeri da una distribuzione uniforme!↩︎ un modo più efficace per fare il confronto è usare la funzione microbenchmark() del pacchetto omonimo↩︎ mentre digiti, se il pacchetto che contiene la funzione è caricato in memoria, vedrai apparire dei suggerimenti, che potrai completare scorrendo la lista con le frecce e premendo &lt;invio&gt; per confermare↩︎ alcune funzioni, come quelle che salvano oggetti in una posizione di memoria non restituiscono valori, ma hanno quelli che si chiamano effetti collatelari, come il salvataggio di un file o la “stampa” di qualcosa in Console↩︎ questo codice può essere fatto girare nella console usando la funzione example(), vedi dopo, anche se le versioni più recenti di RStudio forniscono un link Run example↩︎ prova a cliccare su Index e ad esplorare la finestra che appare seguendo i diversi link↩︎ ricordati che se digiti qualcosa nella console devi omettere il prompt, che già appare nella console…↩︎ se vi sentite più orientati alla pirateria provate YaRrr!, che ha un approccio simile↩︎ se è quello che usate per guidare la vostra vita↩︎ "],["datioggetti.html", "4 Dati, oggetti, funzioni (e tutto il resto) 4.1 Cosa c’è da imparare in questo capitolo. 4.2 R è un linguaggio funzionale che supporta la programmazione orientata a oggetti… 4.3 Il nome delle cose. 4.4 Strutture di dati. 4.5 Vettori atomici. 4.6 I data frame e le liste. 4.7 Altre cose strane: tabelle di conte, serie temporali, date e ore. 4.8 Indirizzare, selezionare. 4.9 attach(), with(), within(). 4.10 Funzioni “built-in” e funzioni definite dall’utente. 4.11 Programmare, con stile. 4.12 Un ambiente affollato. 4.13 Altre risorse.", " 4 Dati, oggetti, funzioni (e tutto il resto) v1.3.4 30/10/2023 4.1 Cosa c’è da imparare in questo capitolo. Che ti piaccia o no, R è un linguaggio e, se vuoi imparare ad usarlo bene, devi impararne almeno i rudimenti. Molti testi introduttivi recentissimi, inclusi R for data science, Just enough R, ModernDive, o anche cose più eterodosse come YaRrr! tendono a confinare gli elementi di base sulla struttura del linguaggio e la sua sintassi in pochi paragrafi, introducendo poi le funzioni più importanti man mano che se ne presenta la necessità. In effetti, soprattutto se si decide di usare quel particolare dialetto di R creato dal tidyverse, un insieme di pacchetti per la scienza dei dati, molto utilizzati, una volta compresi alcuni concetti di base sulle tabelle (data frame in R) e altre strutture di dati si possono certamente affrontare in maniera efficace aspetti come la visualizzazione grafica, le analisi statistiche di base, etc. senza troppe complicazioni. Come sempre, nella serena consapevolezza che i miei potenziali lettori sono fondamentalmente pigRi ho deciso di fare qualche piccolo compromesso e di strutturare il capitolo in modo che possa essere fruito per parti, e anche in momenti differenti. Quindi: se proprio hai fretta o, semplicemente, se hai voglia di lavorare il meno possibile: leggi (rapidamente, per carità!) la premessa 4.1.2, con qualche richiamo sulla terminologia relativa a dati, variabili, etc. leggi attentamente almeno la sezione 4.4 sulle strutture di dati: puoi saltare alcuni paagrafi se vuoi; saranno chiaramente indicati leggi, almeno superficialmente, la sezione 4.8 su indirizzamento e selezione di sottoinsiemi di dati (sono concetti che verranno richiamati più e più volte nei capitoli successivi) se hai tempo e voglia, e, soprattutto, se sei veramente interessat* a programmare in R, leggi con attenzione tutto il resto e sentiti liber* di ritornare a questo capitolo mano a mano che prosegui nella lettura. 4.1.1 Premessa 1: esperimenti e osservazioni. Questo materiale è destinato soprattutto a chi si occupa di scienze sperimentali e in particolare in campi legati alla biologia, biotecnologia, scienze naturali e scienze agrarie. Se sei quindi un* student* di magistrale (improbabile), un* dottorand* di ricerca, un assegnista o un* borsista di ricerca, un* ricercat* i tuoi dati saranno il risultato di esperimenti più o meno complessi. Lo stesso processo che porta alla raccolta dei dati e alla loro analisi è, o dovrebbe essere, ben strutturato e relativamente complesso (figura 4.1). Figura 4.1: Dall’ipotesi sperimentale alle conclusioni. Il risultato dell’esperimento sono in genere una o più tabelle di dati, più o meno grandi. Se ti occupi di bioinformatica o chemiometria è abbastanza probabile che le tabelle di dati siano veramente grandi o che, addirittura, tu ti trovi a condurre, in una prima fase, delle analisi sperimentali su flussi di dati, magari generati da complessi di sensori, che hanno le caratteristiche dei big data (volume, varietà, velocità, ma anche valore e veracità). Per, esempio, se ti stai occupando di sviluppare un metodo per identificare i determinanti della qualità dei formaggi66 potresti trovarti a disporre di tabelle contenenti dati di composizione bruta (grasso, proteine, etc., in genere da poche a poche decine di variabili), dati sulla composizione in composti volatili (centinaia di variabili), dati spettroscopici (NIR, FTIR, etc., centinaia o migliaia di potenziali variabili), dati sulla composizione del microbiota (potenzialmente centinaia di variabili) su un numero di osservazioni (i formaggi che analizzi) molto inferiore a quello delle variabili. Ammesso che tu abbia progettato ed eseguito correttamente l’esperimento (o, semplicemente, stia utilizzando un approccio più o meno descrittivo e quasi-sperimentale) i tuoi dati saranno invariabilmente affetti da bias (magari legati a strumenti mal calibrati), incertezza (magari dovuta a scarsa sensibilità degli strumenti o degli approcci sperimentali) e variabilità (i dati chimico-biologici sono, per loro natura variabili). Vorrai quindi rappresentare adeguatamente questi dati, riassumendoli, ed estrarne l’informazione rilevante relativamente all’ipotesi scientifica che hai formulato. Se stai usando approcci multivariati complessi, oltre a bias, incertezza e variabilità, le informazioni scientificamente e tecnologicamente irrilevanti potrebbero essere nascosti in mezzo ad una marea di informazioni irrilevanti o non interpretabili: il segnale che ti interessa potrebbe essere il classico ago nel pagliaio (figura 4.2). Figura 4.2: Big data e scienze sperimentali: l’ago nel pagliaio. La figura è modificata da Szymańska, E., 2018. Mentre l’analisi statistica e grafica possono aiutarti a rappresentare correttamente e onestamente i dati e a estrarne un senso, ricorda sempre che sono le ipotesi scientifiche (basate su una robusta conoscenza del campo d’indagine) a guidare la raccolta dei dati e la loro interpretazione e che non c’è analisi che possa migliorare dei dati di cattiva qualità o del tutto irrilevanti per l’ipotesi sperimentale. 4.1.2 Premessa 2. Misure e dati, osservazioni e variabili, tabelle. Credo di aver già detto che questo non è, e non aspira ad essere, un libro di statistica. Ma se ti trovi nella condizione di non aver mai letto un libro di statistica è bene definire alcuni termini senza i quali è difficile parlare di calcolo statistico con R. In questo libro cercherò di usare prevalentemente set di dati disponibili con la versione base di R o inclusi nei pacchetti più importanti. Per forza di cose, alcuni di essi non saranno dati legati alla biologia o alle biotecnologie, ma spero che un effetto secondario della lettura di questo libro possa essere quello di rendere un po’ più flessibile il tuo atteggiamento verso i dati in generale. Per iniziare cominciamo ad esplorare qualche semplice set di dati. iris è un dataset classico della statistica multivariata. Mostra alcune misure della lunghezza e larghezza di petali e sepali in tre specie del genere Iris. Il chunk di codice successivo mostra come aprire e visualizzare (nell’interno di questo documento) questo set di dati. # apre il dataset, che è incluso nell&#39;installazione di base data(&quot;iris&quot;) # mostra il dataset nel tab View del pannello Source in RStudio. Rimuovi il segno # del commento per eseguire il comando # View(iris) # mostra l&#39;aiuto del data set, in alternativa ?iris # help(iris) # stampa le prime 20 righe del data set nella Console o, in questo caso, nell&#39;interno del documento head(iris,20) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 11 5.4 3.7 1.5 0.2 setosa ## 12 4.8 3.4 1.6 0.2 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 18 5.1 3.5 1.4 0.3 setosa ## 19 5.7 3.8 1.7 0.3 setosa ## 20 5.1 3.8 1.5 0.3 setosa Useremo spesso il comando head(), che è un modo rapido per dare uno sguardo ad un data set senza riempire la console; se vuoi inviare alla console le ultime 20 righe puoi usare &gt;tail(iris, 20) nota che l’alternativa è print(iris); il comando print ha varie opzioni utili, fra cui alcune che regolano giustificazione e numero di cifre significative. Prova, per esempio: &gt; print(iris, digits = 2) Se vuoi visualizzare il set di dati in RStudio, vedere l’aiuto e “stampare” il data set nella console scrivi i seguenti comandi nella Console (ricordati che non devi scrivere &gt;, perché il prompt appare automaticamente nella Console ogni volta che premi invio e completi un comando). &gt;data(iris) &gt;View(iris) &gt;?iris &gt;iris 4.1.3 Anatomia di una tabella. Anche se magari queste cose sono scontate, è bene scendere un pochino più in dettaglio nella struttura di questa tabella. Figura 4.3: Anatomia di una tabella: alcune caratteristiche morfologiche dei fiori di tre specie di iris. Iris è un dataset storico, utilizzato, fra le altre cose per dimostrare alcune tecniche di analisi multivariata, come l’analisi discriminante lineare. E’ una semplice tabella che contiene 5 variabili67: quattro variabili quantitative continue68, per scala di rapporti69: lunghezza e larghezza dei petali, lunghezza e larghezza dei sepali; una variabile qualitativa nominale: il nome delle tre specie del genere Iris messe a confronto. Questa variabile può assumere un numero finito di valori o categorie che non hanno nessun ordine ovvio. In R questo tipo di variabile è chiamata “fattore”. Le variabili, quindi, corrispondono alle colonne della tabella e le singole osservazioni (eseguite in questo caso ciascuna su una singola unità campionaria) alle righe70. Una singola misura è identificata, in questo caso, dal numero di riga e di colonna o dal numero di riga e dal nome della variabile. Analogamente, ci possiamo riferire a sottoinsiemi di dati usando vettori di numeri di righe e colonne (vedi sezione 4.8. I dataset di R e delle sue librerie forniscono una messe enorme di esempi. Un dataset che utiizzeremo molto è Arthritis71. Arthritis appartiene alla libreria vcd: per renderlo disponibile è necessario installare e caricare prima questa libreria. # carica la libreria (in realtà questo avviene in maniera automatica nel setup # dello script usato per generare questo capitolo) library(vcd) # carica il dataset data(&quot;Arthritis&quot;) # stampa il data set nella Console o, in questo caso, nell&#39;interno del documento head(Arthritis,20) ## ID Treatment Sex Age Improved ## 1 57 Treated Male 27 Some ## 2 46 Treated Male 29 None ## 3 77 Treated Male 30 None ## 4 17 Treated Male 32 Marked ## 5 36 Treated Male 46 Marked ## 6 23 Treated Male 58 Marked ## 7 75 Treated Male 59 None ## 8 39 Treated Male 59 Marked ## 9 33 Treated Male 63 None ## 10 55 Treated Male 63 None ## 11 30 Treated Male 64 None ## 12 5 Treated Male 64 Some ## 13 63 Treated Male 69 None ## 14 83 Treated Male 70 Marked ## 15 66 Treated Female 23 None ## 16 40 Treated Female 32 None ## 17 6 Treated Female 37 Some ## 18 7 Treated Female 41 None ## 19 72 Treated Female 41 Marked ## 20 37 Treated Female 48 None # più avanti vedremo delle funzioni che permettono di personalizzare l&#39;aspetto # di una tabella in un documento, in un report o una presentazione Ricorda che se avessi voluto mostrare il data set nel pannello Source avresti potuto usare View(Arthritis) e se avessi voluto sapere di più su questo data set apresti potuto usare il comando ?Arthritis. In questo caso si tratta di un dataset che riporta i dati di un test clinico. La prima variabile, ID, nonostante sia in apparenza numerica (in questo caso si tratta di interi) non è altro che un numero che individua univocamente un singolo paziente; è quindi anch’essa una variabile qualitativa nominale (un fattore non ordinato), ma in questo caso i valori sono unici, e non ha senso usare un fattore (che ha un numero limitato di livelli che possono comparire più di una volta). La variabile Treatment è uno dei fattori del disegno sperimentale: è una variabile nominale che ha solo due valori. Lo stesso vale per la variabile Sex. La variabile Age è una variabile quantitativa; tecnicamente può assumere valori continui, ma qui è solo riportata l’età in anni e non, per esempio, in nanosecondi. Quando più avanti parleremo di disegni sperimentali, vedrai che questo è un esperimento sbilanciato (non c’è un uguale numero di pazienti per trattamento) e possiamo immaginare che pazienti, di diverso sesso e età siano stati assegnati in maniera casuale72 a due gruppi (Treated, che hanno ricevuto un trattamento per l’artrite che si immagina debba migliorare il quadro clinico del paziente e Placebo, che hanno ricevuto una sostanza innocua). L’ultima variabile, Improved, è una variabile qualitativa ordinale (un fattore ordinato) con tre livelli73. 4.1.4 Un piccolo esercizio. Usando lo stesso tipo di comandi prova ad aprire (e a stampare a console) i seguenti dataset e a leggerne l’aiuto: mtcars o, se preferisci, ggplot2::mpg74 DNase Orange InsectSprays CO2 Che tipi di variabili contengono? Ti sembra che siano dati ricavati da semplici osservazioni o risultati di un esperimento realizzato secondo un preciso disegno sperimentale? Più avanti vedremo anche strutture di dati più complesse, divise in varie tabelle o in oggetti a più di due dimensioni75 prova ad esplorare le tabelle contenute nel pacchetto nycflights13, un esempio di dati organizzati come un database relazionale76 dai uno sguardo al dataset Titanic, un esempio di tabella a più dimensioni, e airquality, che può essere organizzato come un array usando la variabile indice Month77 4.1.5 Tidy vs. untidy (tabelle ordinate e disordinate). Chiunque, come docente, abbia visto una tabella prodotta da uno studente durante lo svolgimento di una tesi di laurea sperimentale sa cosa voglia dire “dati disordinati” (“untidy”). I dati disordinati sono difficili da visualizzare e analizzare e molti dei comandi che userò in questo libro si “aspettano” dati ordinati (“tidy”). Il concetto di “tidy data” è stato descritto in maniera eccellente da Hadley Wickham, una sorta di semidio del mondo di R. Per metterla in modo semplice, in un set di dati tidy: ogni colonna è una variabile ogni riga è un’osservazione ogni cella è una misura Molto spesso, in un set di dati “tidy” è facile individuare sottotabelle di dati “tidy”, identificate da combinazioni di valori di variabili qualitative. Pensate per esempio ai due dataset iris e Arthritis. Osservate le seguenti tabelle, riordinate per mettere in evidenza la struttura “tidy”. # non badate ai comandi, tutti del pacchetto dplyr appartenente al tidyverse, # imparerete come usarli nei capitoli successivi # se non lo avete già fatto prima caricate il pacchetto dplyr con # require(dplyr) # qui head() è usato per stampare alcune righe Arthr &lt;- Arthritis %&gt;% arrange(Treatment, Sex, Improved) head(Arthr,20) ## ID Treatment Sex Age Improved ## 53 80 Placebo Female 23 None ## 54 12 Placebo Female 30 None ## 55 29 Placebo Female 30 None ## 57 38 Placebo Female 32 None ## 59 51 Placebo Female 37 None ## 60 54 Placebo Female 44 None ## 61 76 Placebo Female 45 None ## 62 16 Placebo Female 46 None ## 63 69 Placebo Female 48 None ## 64 31 Placebo Female 49 None ## 65 20 Placebo Female 51 None ## 66 68 Placebo Female 53 None ## 67 81 Placebo Female 54 None ## 68 4 Placebo Female 54 None ## 71 49 Placebo Female 57 None ## 76 48 Placebo Female 61 None ## 78 3 Placebo Female 64 None ## 80 32 Placebo Female 66 None ## 81 42 Placebo Female 66 None ## 56 50 Placebo Female 31 Some ir &lt;- iris %&gt;% dplyr::select(5, 1:4) head(ir,20) ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 setosa 5.1 3.5 1.4 0.2 ## 2 setosa 4.9 3.0 1.4 0.2 ## 3 setosa 4.7 3.2 1.3 0.2 ## 4 setosa 4.6 3.1 1.5 0.2 ## 5 setosa 5.0 3.6 1.4 0.2 ## 6 setosa 5.4 3.9 1.7 0.4 ## 7 setosa 4.6 3.4 1.4 0.3 ## 8 setosa 5.0 3.4 1.5 0.2 ## 9 setosa 4.4 2.9 1.4 0.2 ## 10 setosa 4.9 3.1 1.5 0.1 ## 11 setosa 5.4 3.7 1.5 0.2 ## 12 setosa 4.8 3.4 1.6 0.2 ## 13 setosa 4.8 3.0 1.4 0.1 ## 14 setosa 4.3 3.0 1.1 0.1 ## 15 setosa 5.8 4.0 1.2 0.2 ## 16 setosa 5.7 4.4 1.5 0.4 ## 17 setosa 5.4 3.9 1.3 0.4 ## 18 setosa 5.1 3.5 1.4 0.3 ## 19 setosa 5.7 3.8 1.7 0.3 ## 20 setosa 5.1 3.8 1.5 0.3 Notate come, scorrendo le tabelle, è possibile individuare facilmente le sottotabelle: in iris ogni valore della variabile Species definisce una sottotabella. In Arthritis ogni combinazione di una o più delle variabili Treated, Sex e Improved definisce una o più sottotabelle. Sfortunatamente, non tutti i dati sono “tidy”. Osservate il dataset billboard del pacchetto tidyr. library(tidyr) data(&quot;billboard&quot;) head(billboard,25) ## # A tibble: 25 × 79 ## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby… 2000-02-26 87 82 72 77 87 94 99 NA ## 2 2Ge+her The … 2000-09-02 91 87 92 NA NA NA NA NA ## 3 3 Doors D… Kryp… 2000-04-08 81 70 68 67 66 57 54 53 ## 4 3 Doors D… Loser 2000-10-21 76 76 72 69 67 65 55 59 ## 5 504 Boyz Wobb… 2000-04-15 57 34 25 17 17 31 36 49 ## 6 98^0 Give… 2000-08-19 51 39 34 26 26 19 2 2 ## 7 A*Teens Danc… 2000-07-08 97 97 96 95 100 NA NA NA ## 8 Aaliyah I Do… 2000-01-29 84 62 51 41 38 35 35 38 ## 9 Aaliyah Try … 2000-03-18 59 53 38 28 21 18 16 14 ## 10 Adams, Yo… Open… 2000-08-26 76 76 74 69 68 67 61 58 ## # ℹ 15 more rows ## # ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, ## # wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, ## # wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, ## # wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;, ## # wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, ## # wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, … Il database contiene i dati della posizione in classifica di diverse canzoni in diverse settimane a partire dal rilascio. E’ abbastanza ovvio che la variabile “tempo” non esiste e questo rende difficile, per esempio, rappresentare graficamente l’andamento della posizione della canzone nel tempo. tidyr contiene molti altri esempi illustrativi di altre situazioni di dati untidy. Talvolta, trasformare i dati da “untidy” a “tidy” è una vera e propria lotta (“data wrangling”) o meglio, una vera e propria arte78, e ce ne occuperemo nel capitolo 9. 4.1.6 Dati mancanti (missing data). In billboard, e in molti altri set di dati, ci sono dati mancanti (missing values). Nel dialetto di R i dati mancanti79 si indicano come NA, not available, e la loro presenza può impedire il calcolo di statistiche o l’analisi di modelli, se non sono opportunamente trattati o eliminati. Nelle scienze sperimentali i dati possono essere mancanti per diverse ragioni: in un esperimento, i dati per alcune ripetizioni di un trattamento possono andare perduti perché va perduto un campione, per il malfunzionamento di uno strumento, l’imperizia di un operatore: questo può rendere sbilanciati80 esperimenti che erano bilanciati o, nei casi peggiori, portare alla perdita di tutti i dati di un trattamento; in un’analisi descrittiva o in un set di dati quasi sperimentale possono mancare (perché non disponibili nel campione che è stato raccolto) i dati corrispondenti a determinate combinazioni di variabili esplicative, o, anche in questo caso, i dati possono andare perduti per il malfunzionamento di sensori e strumenti; in un sondaggio o in un esperimento di analisi sensoriale i partecipanti potrebbero non fornire alcune delle risposte attese; Inoltre, i dati possono essere mancanti in modo esplicito (sappiamo che ci sono dei dati mancanti e lo indichiamo esplicitamente nella nostra tabella, usando, appunto NA) o implicito (sappiamo che dei valori dovrebbero essere presenti, per esempio dai valori di altre osservazioni o variabili ma non ci sono, pur non essendo esplicitamente assenti)81. (espliciti &lt;-data.frame(anno = c(1999,2000,2001,2002), vendite=c(100, NA, 101,102))) ## anno vendite ## 1 1999 100 ## 2 2000 NA ## 3 2001 101 ## 4 2002 102 (impliciti&lt;-data.frame(anno = c(1999, 2001,2002), vendite=c(100, 101,102))) ## anno vendite ## 1 1999 100 ## 2 2001 101 ## 3 2002 102 Come vedi, nel secondo data frama manca l’anno 2000: questo è chiaro nel primo data frame, perché il valore NA compare nella colonna vendite, ma non qui. Proprio per l’importanza dei dati mancanti nelle analisi statistiche esistono varie tecniche per individuarli82, di studiarne la distribuzione (sono mancanti “a caso” o esiste un pattern?), di “tradurne” l’esistenza (diversi tipi di tabelle possono indicare i dati mancanti in modo diverso, per esempio come celle vuote, spazi, punti, etc.) durante l’importazione di file o addirittura di tentare un’imputazione. Come sempre, in R esistono funzioni e addirittura pacchetti dedicati83 a questo scopo. Ti consiglio almeno di leggere la voce dell’aiuto di R sui dati mancanti. Nota che NA non è la stessa cosa di NaN84 e NULL. Prova con questo codice nella console: ?NA sqrt(-2) ?NULL Si tratta di tre valori molto fastidiosi (generano warning o addirittura errori, che possono arrestare l’esecuzione di uno script) ma anche sorprendentemente utili nella programmazione. 4.2 R è un linguaggio funzionale che supporta la programmazione orientata a oggetti… Appunto, qualsiasi cosa questo voglia dire…85. Come me, probabilmente non sei un programmatore esperto, ma, per usare R, occorre imparare un po’ di terminologia sulle funzioni e sugli oggetti. In R, tutto quello che esiste (e cui può essere attribuito un valore) è un oggetto (e gli oggetti hanno classi e attributi che li descrivono), mentre tutto quello che accade, accade perché hai invocato una una funzione86. Fondamentalmente, per poter lavorare è importante capire (bene) alcune cose: per poter “trovare” un oggetto nell’ambiente di lavoro è necessario usare un nome (è l’oggetto che viene attribuito ad un nome e non viceversa, vedi l’esempio successivo) gli oggetti vengono assegnati ai nomi con l’operazione di assegnazione (usando le funzioni &lt;- -&gt; = esistono diverse classi di oggetti, incluse le strutture di dati (che sono quelle su cui operiamo nelle analisi); la classe è uno degli attributi degli oggetti, e gli attributi sono una sorta di metadati che aiutano a definirne proprietà e comportamenti di un oggetto la classe di un oggetto (che si può “interrogare” con la funzione class()) definisce il comportamento dell’oggetto quando quest’ultimo viene usato da diverse funzioni generiche (come per esempio print() o plot(), che si comportano in modo diverso quando hanno come argomento oggetti di classi diverse) oltre alla classe gli oggetti hanno altri attributi, come nomi, dimensioni, etc. che possono essere “interrogati” o definiti usando le funzioni appropriate # un oggetto di tipo numerico, intero # verrà solo stampato a console ma non assegnato 1L ## [1] 1 # 1L è un vettore intero di lunghezza 1 c(1, 2, 3) # un altro oggetto, un vettore numerico a precisione doppia di lunghezza 3 ## [1] 1 2 3 # l&#39;assegnazione dell&#39;oggetto al nome a, l&#39;istruzione assegna ma non stampa a console a &lt;- 1L # stampa a console il valore di a a ## [1] 1 # assegnare e stampare contemporaneamente (a &lt;- 1L) ## [1] 1 class(a) # la classe di a ## [1] &quot;integer&quot; typeof(a) # il tipo o modo di a ## [1] &quot;integer&quot; # tre modi validi, per assegnare, ma il primo è preferibile perché meno ambiguo # il metodo migliore b &lt;- c(1, 2, 3) # funziona anche questo ma si confonde con l&#39;assegnazione di valori a parametri di funzioni b = c(1, 2, 3) # funziona ma è difficile da leggere c(1, 2, 3) -&gt; b b ## [1] 1 2 3 # un po&#39; di magia (a prima è una cosa, poi diventa un&#39;altra) a ## [1] 1 a &lt;- b a ## [1] 1 2 3 # attributi importantissimi sono la classe e il tipo class(b) # la classe di a ## [1] &quot;numeric&quot; typeof(b) # il tipo o modo di a ## [1] &quot;double&quot; # altri attributi importanti sono la dimensione # che (ha senso per gli oggetti a 2 o più dimensioni) dim(Arthritis) ## [1] 84 5 # e la lunghezza (ha senso per oggetti a una dimensione) length(b) ## [1] 3 # alcuni oggetti hanno nomi per i singoli elementi o per le diverse dimensioni vettore_con_nomi &lt;- c(a = 1, b = 2, c = 3) names(vettore_con_nomi) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; colnames(Arthritis) ## [1] &quot;ID&quot; &quot;Treatment&quot; &quot;Sex&quot; &quot;Age&quot; &quot;Improved&quot; rownames(Arthritis) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; ## [16] &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; ## [31] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; ## [46] &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; &quot;73&quot; &quot;74&quot; &quot;75&quot; ## [76] &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; # queste funzioni possono essere usate per leggere o assegnare i nomi: names(vettore_con_nomi) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; vettore_con_nomi ## a b c ## 1 2 3 names(vettore_con_nomi) &lt;- c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;) vettore_con_nomi ## d e f ## 1 2 3 4.3 Il nome delle cose. In R ci sono poche limitazioni sui nomi degli oggetti87: possono contenere lettere, numeri, “_” e “-” in qualsiasi combinazione non possono contenere spazi non devono iniziare con un numero, “_” o “-” non devono corrispondere a un nome “riservato”, cioé a uno dei nomi utilizzati dal linguaggio R è un linguaggio case-sensitive (maiuscole e minuscole non sono la stessa cosa, quindi a e A o anova() e Anova() non sono la stessa cosa). In sostanza, puoi fare un po’ quello che ti pare anche se, ovviamente esistono delle guide di stile alle quali sarebbe bene uniformarsi, se non altro per coerenza e per aumentare la leggibilità del codice che scrivi (per gli altri e per il tuo io futuro). Due esempi sono la guida di Google e quella del tidyverse. Io, per ragioni religiose, cercherò di seguire quella del tidyverse (un universo ordinato di pacchetti molto utili), ma, siccome sono smemorato e incoerente potrei dimenticarmene di quando in quando. Quelli che seguono sono alcuni esempi di convenzioni sull’assegnazione di oggetti a nomi: # un nome valido: è bene che i nomi siano descrittivi e che dal nome si possa capire # per quanto possibile, che cos&#39;é l&#39;oggetto: questo aiuta molto nella lettura del codice il_mio_nome &lt;- &quot;Maurizio&quot; # ma va bene anche il_mio_nome &lt;- c(1,2,3) # in fondo, R che ne sa? # lo stesso oggetto con 2 nomi c &lt;- d &lt;- 3L # maiuscole e minuscole non sono la stessa cosa C &lt;- 4L # cat() è una funzione molto utile per documentare ciò che va in console # \\n permette di inserire un daccapo; cat(&quot;\\nil valore di c piccolo è\\n&quot;) ## ## il valore di c piccolo è c ## [1] 3 cat(&quot;\\nil valore di C grande è\\n&quot;) ## ## il valore di C grande è C ## [1] 4 # è bene dare nomi descrittivi agli oggetti il_mio_nome &lt;- &quot;Maurizio&quot; # questo va bene e l&#39;uso di _ per separare parole di chiama &quot;snake case&quot; # questi funzionano ma vanno meno bene ilmionome &lt;- &quot;Silvio&quot; ILMIONOME &lt;- &quot;Giorgia&quot; IlMioNome &lt;- &quot;Matteo&quot; # questo si chiama &quot;camel case&quot; perché le maiuscole assomigliano # alle gobbe di un cammello # per le funzioni è meglio usare verbi fai_la_somma &lt;- function(a=1, b=2, c=3) a+b+c cat(&quot;\\nla somma di 5, 6 e 7 è\\n&quot;) ## ## la somma di 5, 6 e 7 è fai_la_somma(5,6,7) ## [1] 18 Come vedrai più avanti \\ è il segno di escape e si può usare per individuare caratteri speciali; \\t, per esempio, è una tabulazione. Per sperimentare con i nomi non sintattici prova a scrivere ed eseguire questo script: # un nome sbagliato, non sintattico 1schifodinome &lt;- 1 # restituisce un errore `1schifodinome` &lt;- 1 `1schifodinome` # questo funziona, ma è uno schifo # questo piccolo trucco può venire comodo nell&#39;importazione di dati da altri # software che non hanno questo tipo di limitazioni Pensa a quante tabelle, fatte male, hanno intestazioni di colonna (e quindi nomi di variabili) non sintattici, e ai dolori di pancia per importarle… In questo libro, per coerenza, farò il possibile per usare nomi in italiano. E’ abbastanza ovvio che se vuoi che il tuo codice sia letto e compreso da altri, devi assegnare nomi che abbiano senso in inglese. Descrivere il modo in cui R cerca i valori associati ad un determinato nome (sia esso il nome di una funzione o il nome di una struttura di dati) è troppo complesso per un libro introduttivo come questo. Probabilmente, quando imparerai a programmare meglio dovrai approfondire questo argomento. Come al solito, un ottimo punto di partenza è Advanced R. Qui ti basti ricordare che, per quanto in generale non sia necessario essere molto specifici, quando esiste un’ambiguità (è possibile per esempio che diversi pacchetti abbiano funzioni con lo stesso nome, o è possibile che una variabile con lo stesso nome sia presente in tabelle diverse) bisogna stare attenti ad indicare con precisione dove cercare. Vedremo alcuni esempi in seguito. 4.4 Strutture di dati. Le strutture di dati sono quelle che importerai, aprirai, userai per le analisi, salverai, etc. e, che, per l’appunto contengono dati. Possiamo distinguerle in vettori atomici (atomic vectors): contengono dati di un solo tipo (vedi dopo) a una dimensione: vettori (vectors) a due dimensioni: matrici (matrices) a n dimensioni: array vettori generici (generic vectors): possono contenere più tipi di dati data frames: possono contenere vettori di diverso tipo, con il vincolo che tutti siano della stessa lunghezza. I data frames sono, in realtà, liste con alcuni vincoli (tutti gli elementi devono avere la stessa lunghezza). Vedremo più avanti che è anche possibile avere data frame annidati, con colonne che contengono altri data frame. Come hai già visto i data frame sono il tipo di tabella che userai più frequentemente, per la loro versatilità. Esiste una versione “aggiornata” dei data frame, fornita dal pacchetto tibble, che a sua volta fa parte del tidyverse, chiamata appunto tibble. liste (lists): sono gli oggetti più flessibili di tutti, perché possono contenere oggetti di qualsiasi tipo e lunghezza, incluse altre liste; come vedrai, oltre a contenere dati, possono contenere risultati di analisi e persino grafici. 4.5 Vettori atomici. La struttura di base per i dati in R è il vettore, un insieme ordinato di dati, che, nei vettori atomici, sono necessariamente dello stesso tipo. In R non esistono scalari: gli scalari sono vettori di lunghezza 1. 4.5.1 Vettori ad una dimensione. Gli elementi di un vettore ad una dimensione sono messi insieme dalla funzione c(), che, appunto, concatena elementi. Ogni vettore atomico contiene elementi dello stesso tipo (type) o modo (mode). I tipi più frequentemente utilizzati sono: numerici: interi, p.es. c(1L, 2L, 3L); doppi, p. es. c(1.25, -3.14, 999)88 logici: con elementi che possono assumere solo i valori TRUE (o T) o FALSE (o F)89 carattere: contengono per l’appunto, simboli che sono interpretati come caratteri, e che devono essere inseriti fra virgolette, singole o doppie: c(\"a\", \"Apple\", \"1\", \"TRUE\"); nota come il terzo elemento di questo vettore è un numero, ma è interpretato come carattere; il quarto è un valore logico ma, essendo fra virgolette, viene interpretato come carattere. Una classe particolare di vettori sono i fattori (factors). I fattori sono particolarmente utili per le variabili nominali o ordinali con un numero limitato di valori diversi (vedi il paragrafo 4.1.3). I fattori sono in realtà conservati in memoria come vettori di interi, cui sono associati dei nomi dei livelli e, eventualmente, il loro ordine. Esistono comandi specifici per creare i diversi tipi di vettori, e li vedrai negli esempi successivi.90 E’ possibile “interrogare” un oggetto usando diverse funzioni, come nell’esempio successivo. E’ anche possibile usare alcune funzioni per “costringere” un oggetto a cambiare tipo (si chiama coercizione e, qualche volta, R la fa in automatico). Interrogare oggetti e cambiarne il tipo possono sembrare operazioni futili se ci si immagina di lavorare con R solo in modo interattivo: in fondo, se siamo lì a guardare dovremmo sapere benissimo quello che sta succendendo, no? Tuttavia, la potenza di R si scatena veramente solo quando lo usiamo per creare programmi e script e per automatizzare operazioni: in questo caso, potrebbe essere necessario che R chieda per conto nostro ad un’oggetto di che tipo è e lo converta se necessario in un altro tipo. Infatti, alcune funzioni accettano solo oggetti di un certo tipo e non è sempre ovvio o noto con che tipo di oggetto abbiamo a che fare91. # riprendiamo alcuni dei vettori creati precedentemente e &quot;interroghiamoli&quot; a ## [1] 1 2 3 # la classe class(a) ## [1] &quot;numeric&quot; # il tipo o modo (che è il modo con cui R conserva in memoria l&#39;oggetto) typeof(a) ## [1] &quot;double&quot; # la lunghezza length(a) ## [1] 3 # i nomi, se esistono (altrimenti restituisce NULL) names(a) ## NULL # proviamo con un altro vettore_con_nomi ## d e f ## 1 2 3 class(vettore_con_nomi) ## [1] &quot;numeric&quot; names(vettore_con_nomi) ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; # nota che il risultato di names() può essere assegnato i_nomi &lt;- names(vettore_con_nomi) # che vettore abbiamo creato? di che classe, lunghezza, tipo? # un modo semplice per conoscere gli attributi attributes(vettore_con_nomi) ## $names ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; # che tipo di oggetto restituisce attributes()? Prova ad usare l&#39;aiuto... # con la funzione c() possiamo anche concatenare vettori. Vediamo che succede: vettori_concatenati &lt;- c(a,b) class(vettori_concatenati) ## [1] &quot;numeric&quot; typeof(vettori_concatenati) ## [1] &quot;double&quot; # nota come questo sia un vettore carattere; eccone altri il_mio_TESTO &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) il_mio_testo &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) # nota che questo non è lo stesso oggetto e che anche i nomi sono diversi # naturalmente è possibile creare un vettore logico direttamente logico &lt;- c(TRUE, FALSE, FALSE) # ma anche logico &lt;- c(T, F, F) # alcune funzioni usate per interrogare oggetti restituiscono valori logici is.numeric(a) ## [1] TRUE is.logical(logico) ## [1] TRUE is.logical(a) ## [1] FALSE # i fattori sono molto importanti, sia per ragioni storiche, sia perché sono il # prototipo delle variabili categoriche # creiamo un fattore non ordinato (il default) fattore_non_o &lt;- factor(c(&quot;vowel&quot;,&quot;consonant&quot;,&quot;consonant&quot;)) # la funzione str() ci dice qualcosa sulla struttura di quest&#39;oggetto str(fattore_non_o) ## Factor w/ 2 levels &quot;consonant&quot;,&quot;vowel&quot;: 2 1 1 # come vedi, di default R ha assegnato il livello in ordine alfabetico # nota anche come, in realtà, i valori siano conservati come interi (1, 2) # mentre i nomi dei livelli sono attributi # prova a leggere l&#39;aiuto di factor() e as-factor() # guarda cosa succede con una variabile ordinale, se non stiamo attenti quanto &lt;- factor(c(&quot;molto&quot;, &quot;molto&quot;, &quot;poco&quot;, &quot;moltissimo&quot;, &quot;abbastanza&quot;)) quanto ## [1] molto molto poco moltissimo abbastanza ## Levels: abbastanza moltissimo molto poco str(quanto) ## Factor w/ 4 levels &quot;abbastanza&quot;,&quot;moltissimo&quot;,..: 3 3 4 2 1 # sarebbe ovviamente desiderabile che ci fosse un ordine logico: # in fondo poco è meno abbastanza, che è meno di molto che è meno di moltissimo # a questo punto i default della funzione factor() non bastano, e dobbiamo essere # più specifici, indicando i livelli: quanto_ord &lt;-factor(c(&quot;molto&quot;, &quot;molto&quot;, &quot;poco&quot;, &quot;moltissimo&quot;, &quot;abbastanza&quot;), levels = c(&quot;poco&quot;, &quot;abbastanza&quot;, &quot;molto&quot;, &quot;moltissimo&quot;), ordered = T) quanto_ord ## [1] molto molto poco moltissimo abbastanza ## Levels: poco &lt; abbastanza &lt; molto &lt; moltissimo str(quanto_ord) ## Ord.factor w/ 4 levels &quot;poco&quot;&lt;&quot;abbastanza&quot;&lt;..: 3 3 1 4 2 # nota che i fattori sono conservati in memoria come interi, con attributi typeof(quanto_ord) ## [1] &quot;integer&quot; attributes(quanto_ord) ## $levels ## [1] &quot;poco&quot; &quot;abbastanza&quot; &quot;molto&quot; &quot;moltissimo&quot; ## ## $class ## [1] &quot;ordered&quot; &quot;factor&quot; Vedremo più avanti come lavorare con i fattori non sia sempre semplicissimo e che, ancora una volta per ragioni storiche, possa capitare che un vettore di caratteri venga convertito in un fattore in maniera esplicita o “dietro le quinte”. Nota che è buona pratica di programmazione dividere in maniera logica su più linee un singolo comando molto lungo; se non sei cert* come farlo, prova a selezionare il comando o la parte di codice che vuoi formattare correttamente e poi usa il menu Reformat Code&gt; (in alcuni casi può essere utile ) per quanto il codice diventi più lungo è più facile leggerlo. L’esempio successivo illustra alcuni aspetti dell’uso di caratteri speciali nei vettori a carattere e fornisce qualche dettaglio in più sulla coercizione. Potrebbe essere utile in diverse situazioni ma, se vuoi, puoi saltarlo. # caratteri speciali # in alcuni casi potrebbe essere necessario aggiungere caratteri speciali al testo # aggiungere esplicitamente delle virgolette virgolettato &lt;- c(&quot;&#39;A&#39;&quot;, &quot;&#39;B&#39;&quot;, &quot;&#39;C&#39;&quot;) virgolettato ## [1] &quot;&#39;A&#39;&quot; &quot;&#39;B&#39;&quot; &quot;&#39;C&#39;&quot; (virgolettato_doppio &lt;- c(&#39;&quot;A&quot;&#39;, &#39;&quot;B&quot;&#39;, &#39;&quot;C&quot;&#39;)) ## [1] &quot;\\&quot;A\\&quot;&quot; &quot;\\&quot;B\\&quot;&quot; &quot;\\&quot;C\\&quot;&quot; # degli a capo (per inserire tabulazioni puoi usare \\t) a_capo &lt;- &quot;A\\nB\\nC&quot; # altri modi di stampare # nota come diversi comandi possano stampare contenuto o contenuto &quot;grezzo&quot; print(virgolettato) ## [1] &quot;&#39;A&#39;&quot; &quot;&#39;B&#39;&quot; &quot;&#39;C&#39;&quot; cat(virgolettato) ## &#39;A&#39; &#39;B&#39; &#39;C&#39; writeLines(a_capo) ## A ## B ## C cat() e writelines() possono anche inviare il risultato a altre “connessioni”, cioé ad un file piuttosto che alla console; è in qualche maniera un residuo dei bei vecchi tempi, non credo che valga la pena parlarne, ma, se vuoi leggi qui o qui. Vediamo ora qualche esempio di coercizione. Che succede se provo a concatenare oggetti di tipo diverso (uno numerocio e uno a caratteri)? due_vettori &lt;- c(vettori_concatenati, i_nomi) due_vettori ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; class(due_vettori) ## [1] &quot;character&quot; typeof(due_vettori) ## [1] &quot;character&quot; Il risultato è un vettore di tipo carattere: R ha esercitato quella che si chiama coercizione; è possibile convertire praticamente tutto in caratteri, ma non viceversa. as.character(vettori_concatenati) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; typeof(as.character(vettori_concatenati)) ## [1] &quot;character&quot; Nota come posso annidare due funzioni una dentro l’altra; il risultato del comando typeof(as.character(vettori_concatenati)) É trasformare un vettore numerico in un vettore carattere (senza assegnarlo a un nome) e, contemporaneamente, leggerne il tipo. Nota che questa non è buona pratica di programmazione perché il codice potrebbe essere poco leggibile. Prova a scrivere a console il seguente comando as.numeric(i_nomi) La coercizione può avvenire anche come risultato di operazioni, guarda che succede qui sotto: # controlliamo se il contenuto dei due oggetti è identico, elemento per elemento, con la funzione == il_mio_TESTO == il_mio_testo ## [1] FALSE FALSE FALSE # cosa restituisce quest&#39;operazione? Che lunghezza ha il risultato? # Controlliamo, assegnando il risultato ad un vettore risultato &lt;- (il_mio_TESTO == il_mio_testo) class(risultato) ## [1] &quot;logical&quot; typeof(risultato) ## [1] &quot;logical&quot; length(risultato) ## [1] 3 # il risultato è un vettore logico di lunghezza 3, perché sono stati fatti 3 confronti # oppure possiamo usare le funzioni as.xxxx() as.factor(il_mio_testo) ## [1] a b c ## Levels: a b c as.numeric(logico) ## [1] 1 0 0 as.character(b) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; as.character(quanto) ## [1] &quot;molto&quot; &quot;molto&quot; &quot;poco&quot; &quot;moltissimo&quot; &quot;abbastanza&quot; as.logical(c(1,0,1,0)) ## [1] TRUE FALSE TRUE FALSE 4.5.2 Vettori atomici a 2 o più dimensioni: matrici e array. Nella pratica incontrerai prevalentemente strutture di dati a 2 (righe = osservazioni, colonne = variabili) o più (per esempio, righe = osservazioni, colonne = variabili, strati = tempo o luogo nel quale sono state eseguite le misure, identità del soggetto su cui sono state eseguite le misure). Vedrai in seguito come gli oggetti a più di due dimensioni possano essere facilmente trasformati, usando una o più variabili indice per individuare le sottotabelle, in oggetti a 2 dimensioni corrispondenti agli strati degli oggetti a più dimensioni. In R i vettori atomici a due dimensioni sono chiamati matrici e vengono creati: con il comando matrix() estraendo colonne dello stesso tipo da un data frame e usando as.matrix()92 come risultato di analisi statistiche: per esempio la funzione cor() accetta una matrice numerica e restituisce una matrice di correlazione sempre numerica Il comando matrix() prende come input un insieme di dati della dimensione opportuna e lo trasforma in una matrice con un numero di righe e colonne specificato, riempiendo la matrice per colonne (il default) o per righe, e assegna opzionalmente i nomi di righe e colonne. Il comando array() fa lo stesso per gli array. Prova a esplorare l’aiuto scrivendo nella console: &gt;?matrix &gt;?array Oppure studia con attenzione questo esempio (anche se sei pigr*). Introduco rapidamente il comando seq(), che crea una sequenza numerica. Il comando ha molte opzioni ed è molto flessibile. Nella versione più semplice # crea una sequenza di uno in 1. # Questi comandi sono equivalenti, e creano una sequenza da 1 a 9 1:9 ## [1] 1 2 3 4 5 6 7 8 9 seq(1,9) ## [1] 1 2 3 4 5 6 7 8 9 seq(from = 1, to = 9, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 # una matrice 3x3 riempita per colonne per_colonne &lt;- matrix(seq(1,9), nrow =3, ncol= 3, dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;))) per_colonne ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 # che succede se il vettore ha la dimensione sbagliata? per_colonne_sbagliato &lt;- matrix(seq(1,10), nrow =3, ncol= 3, dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;))) ## Warning in matrix(seq(1, 10), nrow = 3, ncol = 3, dimnames = list(c(&quot;A&quot;, : data ## length [10] is not a sub-multiple or multiple of the number of rows [3] per_colonne_sbagliato_2 &lt;- matrix(seq(1,8), nrow =3, ncol= 3, dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;))) ## Warning in matrix(seq(1, 8), nrow = 3, ncol = 3, dimnames = list(c(&quot;A&quot;, : data ## length [8] is not a sub-multiple or multiple of the number of rows [3] warnings() Nota come nel primo caso un valore è rimasto fuori e nel secondo il primo valore della sequenza è stato riciclato: questo è un comportamento frequente di R, che cerca di effettuare, per quanto possibile, le operazioni richieste, anche se gli argomenti sono errati o incompleti: quando comunque è possibile restituire un valore, viene restituito anche un warning che non arresta l’eventuale esecuzione di un programma, altrimenti viene restituito un errore. Ora proviamo a riempire la stessa matrice per righe: per_righe &lt;- matrix(seq(1:9), nrow =3, ncol= 3, byrow = T, dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;))) per_righe ## D E F ## A 1 2 3 ## B 4 5 6 ## C 7 8 9 # ovviamente è possibile creare matrici di valori carattere o logici o interi matrice_logica &lt;- matrix(c(logico, logico, logico), nrow =3, ncol= 3, byrow = T, dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;))) matrice_logica ## D E F ## A TRUE FALSE FALSE ## B TRUE FALSE FALSE ## C TRUE FALSE FALSE L’argomento data della funzione matrix() può essere anche un vettore definito in precedenza o estratto dall’ambiente di lavoro. Nota l’uso della funzione rep(), che crea ripetizioni con pattern anche complessi. si9 &lt;- rep(&quot;Yes&quot;,9) dimmi_di_si &lt;- matrix(si9, nrow= 3, ncol = 3) mantra &lt;- rep(c(&quot;amore&quot;,&quot;pace&quot;),6) matrice_carattere &lt;- matrix(mantra, nrow =3, ncol= 2, byrow = T, dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;A&quot;,&quot;B&quot;))) ## Warning in matrix(mantra, nrow = 3, ncol = 2, byrow = T, dimnames = list(c(&quot;A&quot;, ## : data length differs from size of matrix: [12 != 3 x 2] Nota in che modo vengono stampate le matrici: per_colonne ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 matrice_carattere ## A B ## A &quot;amore&quot; &quot;pace&quot; ## B &quot;amore&quot; &quot;pace&quot; ## C &quot;amore&quot; &quot;pace&quot; matrice_logica ## D E F ## A TRUE FALSE FALSE ## B TRUE FALSE FALSE ## C TRUE FALSE FALSE Le matrici hanno come attributi importanti i nomi di riga e colonna (devono essere unici ma una colonna può avere lo stesso nome di una riga) e le dimensioni. class(matrice_carattere) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(matrice_carattere) ## [1] &quot;character&quot; str(matrice_carattere) ## chr [1:3, 1:2] &quot;amore&quot; &quot;amore&quot; &quot;amore&quot; &quot;pace&quot; &quot;pace&quot; &quot;pace&quot; ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ..$ : chr [1:2] &quot;A&quot; &quot;B&quot; dim(matrice_carattere) ## [1] 3 2 Cosa restituisce la funzione dim()? Anche se non lo sai, puoi determinarlo con una delle funzioni che abbiamo già usato? Il funzionamento della funzione array() è simile: # creo un array 3x4x3 array_per_colonne &lt;- array(seq(1:36), dim = c(3,4,3), dimnames = list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),c(&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;), c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;))) # nota come viene riempito e stampato: # strato 1, colonna 1, righe 1-n, etc. array_per_colonne ## , , X ## ## D E F G ## A 1 4 7 10 ## B 2 5 8 11 ## C 3 6 9 12 ## ## , , Y ## ## D E F G ## A 13 16 19 22 ## B 14 17 20 23 ## C 15 18 21 24 ## ## , , Z ## ## D E F G ## A 25 28 31 34 ## B 26 29 32 35 ## C 27 30 33 36 # è anche possibile non specificare i nomi array_senza_nomi &lt;- array(rep(c(1,2,3), each = 6), dim = c(3,3,2)) array_senza_nomi ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 1 2 ## [2,] 1 1 2 ## [3,] 1 1 2 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 2 3 3 ## [2,] 2 3 3 ## [3,] 2 3 3 Nota come sia le matrici che gli array sono vettori che sono conservati in memoria con attributi addizionali (dimensioni, nomi) as.matrix() e as.array() possono essere usati per trasformare altri oggetti in matrici o array (se possible). Guarda che succede # head() permette di stamparìe solo alcune righe head(Arthritis[,c(2,3)], 10) ## Treatment Sex ## 1 Treated Male ## 2 Treated Male ## 3 Treated Male ## 4 Treated Male ## 5 Treated Male ## 6 Treated Male ## 7 Treated Male ## 8 Treated Male ## 9 Treated Male ## 10 Treated Male class(Arthritis[,c(2,3)]) ## [1] &quot;data.frame&quot; class(as.matrix(Arthritis[,c(2,3)])) ## [1] &quot;matrix&quot; &quot;array&quot; is.matrix() e is.array() possono essere usati per determinare se un oggetto è una matrice o un array. df_a &lt;- Arthritis[,c(2,3)] is.matrix(df_a) ## [1] FALSE m_a &lt;- as.matrix(df_a) is.matrix(m_a) ## [1] TRUE is.array(per_colonne) ## [1] TRUE Nota che, le matrici, in effetti, sono array. 4.6 I data frame e le liste. Matrici e array sono oggetti utili, ma il vincolo che debbano contenere valori dello stesso tipo è piuttosto stringente e la loro organizzazione in righe e colonne è, essa stessa, rigida. Come hai visto nella Premessa 2 (paragrafo 4.1.2) una tabella contiene normalmente variabili di tipo diverso: ogni colonna è, o dovrebbe essere, una variabile, e ogni riga è una singola osservazione; tutte le colonne hanno la stessa lunghezza. In R, questi tipi di oggetti sono chiamati data frame e ne abbiamo già visto diversi esempi (Arthritis, Iris, Billboard). 4.6.1 I data frame, nel bene e nel male. È possibile creare nuovi data frame in diversi modi: con il comando data.frame() convertendo oggetti a 2 dimensioni esistenti (p.es. una matrice) con as.data.frame() unendo colonne della stessa lunghezza con il comando cbind() I pacchetti del tidyverse operano sui data frame e, spesso, operano su oggetti simili ai data frame, le tibbles, con default e proprietà sensibilmente migliorate.93. I data frame sono oggetti molto flessibili (possono addirittura avere colonne che contengono altri data frame!) e, come vedrai, sono gli oggetti che usiamo più frequentemente per trattare tabelle di dati. In passato (versioni precedenti alla 4.0.0)94 avevano una noiosissima opzione di default che trasformava le colonne di variabili nominali in fattori. Il modo in cui vengono stampati è un tantino ridondante95 e poco informativo. Le tibbles hanno proprietà migliori. Prova anche la funzione pillar::glimpse(), come modo alternativo per esplorare un data frame o una tibble. Per saperne di più su data frames e tibbles scrivi nella console: ?data.frame ?tibble::tibble Vediamo un po’ di creare dei data frame. data_frame_4 &lt;- data.frame(rep(1:4,2), rep(1:4, each = 2), mantra[1:8]) data_frame_4 ## rep.1.4..2. rep.1.4..each...2. mantra.1.8. ## 1 1 1 amore ## 2 2 1 pace ## 3 3 2 amore ## 4 4 2 pace ## 5 1 3 amore ## 6 2 3 pace ## 7 3 4 amore ## 8 4 4 pace Approfitta per esplorare il comportamento della funzione rep(). Le colonne hanno nomi? Di che tipo è la terza colonna? Di che tipo era il vettore usato per crearla? Qual’è il default del parametro stringsAsFactors nel comando data.frame()? Puoi assegnare nomi a righe e colonne dopo la creazione del dataframe: # assegno nomi alle colonne: colnames(data_frame_4) &lt;- c(&quot;quattro&quot;,&quot;quattro_coppie&quot;,&quot;mantra&quot;) data_frame_4 ## quattro quattro_coppie mantra ## 1 1 1 amore ## 2 2 1 pace ## 3 3 2 amore ## 4 4 2 pace ## 5 1 3 amore ## 6 2 3 pace ## 7 3 4 amore ## 8 4 4 pace Nota come: ho usato un vettore per assegnare nomi; se tu avessi fatto girare i comandi in R un oggetto di nome mantra esisterebbe ora come oggetto isolato e come colonna del data frame Quali sono i nomi delle righe? Possiamo assegnarli? # i nomi di riga: rownames(data_frame_4) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; # ora li assegno rownames(data_frame_4) &lt;- letters[1:nrow(data_frame_4)] data_frame_4 ## quattro quattro_coppie mantra ## a 1 1 amore ## b 2 1 pace ## c 3 2 amore ## d 4 2 pace ## e 1 3 amore ## f 2 3 pace ## g 3 4 amore ## h 4 4 pace Nota la costante letters e la funzione nrow(). Puoi creare un data frame convertendo una matrice: tre_per_tre &lt;- as.data.frame(per_colonne) O puoi usare cbind, che unisce per colonne tre_per_sei &lt;- cbind(tre_per_tre, per_colonne) tre_per_sei ## D E F D E F ## A 1 4 7 1 4 7 ## B 2 5 8 2 5 8 ## C 3 6 9 3 6 9 O rbind che unisce per righe sei_per_tre &lt;- rbind(tre_per_tre, per_colonne) sei_per_tre ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 ## A1 1 4 7 ## B1 2 5 8 ## C1 3 6 9 Quando si uniscono molti data frame o data frame di grandi dimensioni si possono usare i comandi equivalenti di dplyr. Prova a eseguire i seguenti comandi nella console: molta_artrite &lt;- dplyr::bind_rows(Arthritis, Arthritis) sei_per_tre &lt;- dplyr::bind_cols(tre_per_tre, tre_per_tre) Ricordati che puoi omettere dplyr:: se non c’è ambiguità nel nome della funzione mentre non puoi farlo se una funzione con lo stesso nome lo ha “mascherato” durante il caricamento dei pacchetti; nota come i nomi delle due funzioni bind_rows() e bind_cols() siano più intuitivi di rbind() e cbind(): questa è una caratteristica di molte funzioni e parametri di funzioni del tidyverse. Le tibbles sono una versione “migliorata” dei data frame. Le puoi creare trasformando un data frame on con il comando tibble(): # creare una tibble con as_tibble tib_Arthritis &lt;- as_tibble(Arthritis) tib_Arthritis ## # A tibble: 84 × 5 ## ID Treatment Sex Age Improved ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;ord&gt; ## 1 57 Treated Male 27 Some ## 2 46 Treated Male 29 None ## 3 77 Treated Male 30 None ## 4 17 Treated Male 32 Marked ## 5 36 Treated Male 46 Marked ## 6 23 Treated Male 58 Marked ## 7 75 Treated Male 59 None ## 8 39 Treated Male 59 Marked ## 9 33 Treated Male 63 None ## 10 55 Treated Male 63 None ## # ℹ 74 more rows class(tib_Arthritis) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Nota che il modo in cui viene stampata una tibble è diverso e prende meno spazio in console. Le tibbles mantengono la classe data.frame. Puoi anche creare una tibble da 0 con il comando tibble, del pacchetto tibble la_mia_tibble &lt;- tibble::tibble(B = b, F = fattore_non_o) Se ti va, puoi esplorare il comando tribble() del pacchetto tibble: è un modo semplice per creare piccolissimi data frame scrivendoli in modo più naturale, per righe invece che per colonne. Un’ultima cosa: in genere è una pessima idea inserire direttamente in formato interattivo un data frame in R. Tecnicamente puoi farlo creando un data frame nullo e invocando l’editor (che è piattaforma-specifico e molto, molto lento). Prova ad eseguire questo script: df &lt;- data.frame(NULL) # ci vuole un po&#39; per aprire l&#39;editor df &lt;- edit(df) Sostituendo df con un nome di un data frame esistente puoi editarlo manualmente. 4.6.2 Le liste. Le liste sono gli oggetti più flessibili in R. Possono contenere tipi di oggetti diversi e non ci sono vincoli al tipo e alla lunghezza (tranne, suppongo, la memoria). Sono importanti perché sono gli oggetti che molte funzioni statistiche restituiscono come risultati.96 Il comando per creare una lista è, abbastanza prevedibilmente, list(). Se hai tempo, esplora l’aiuto. # creiamo la nostra prima lista la_mia_prima_lista &lt;- list(b, due_vettori, mantra, per_colonne) # nota in che modo viene stampata; la_mia_prima_lista ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## ## [[3]] ## [1] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; ## [10] &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ## ## [[4]] ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 str(la_mia_prima_lista) ## List of 4 ## $ : num [1:3] 1 2 3 ## $ : chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; ... ## $ : chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## $ : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## .. ..$ : chr [1:3] &quot;D&quot; &quot;E&quot; &quot;F&quot; is.list(la_mia_prima_lista) ## [1] TRUE # i data frame sono liste! is.list(Arthritis) ## [1] TRUE # le liste possono avere nomi, e possono essere annidate, cioé contenere altre liste la_mia_prima_lista_con_nomi &lt;- list(a = b, b = due_vettori, c = mantra, d = per_colonne, e = la_mia_prima_lista) str(la_mia_prima_lista_con_nomi) ## List of 5 ## $ a: num [1:3] 1 2 3 ## $ b: chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; ... ## $ c: chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## $ d: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## .. ..$ : chr [1:3] &quot;D&quot; &quot;E&quot; &quot;F&quot; ## $ e:List of 4 ## ..$ : num [1:3] 1 2 3 ## ..$ : chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; ... ## ..$ : chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## ..$ : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## .. .. ..$ : chr [1:3] &quot;D&quot; &quot;E&quot; &quot;F&quot; # si può anche creare una lista e poi riempirla la_mia_lista &lt;- list() la_mia_lista[[1]] &lt;- i_nomi Vedremo dopo il significato di [[]]. Imparare ad usare le liste è molto importante e dovresti esercitarti nella loro creazione e sul modo in cui si selezionano ed estraggono elementi dalle liste (4.8). 4.7 Altre cose strane: tabelle di conte, serie temporali, date e ore. Ci sono alcuni altre strutture di dati che hanno proprietà speciali: potrebbero servirti, ma, se hai fretta puoi saltare questo paragrafo. In particolare, R ha classi particolari per: le tabelle di conte: si ottengono come risultato della funzione table(), che restituisce tabelle di frequenza o di contingenza (vettori, matrici e array) di numeri interi, derivati dalle conte dell’occorrenza di combinazioni di variabili quantitative le serie temporali: si creano con la funzione ts() e contenogno solo i valori e l’indicazione della frequenza (annuale, mensile, etc.) gli oggetti di tipo data (date) e data/tempo (date-time) sono particolarmente importanti, sia perché richiedono la possibilità di stampa in formati diversi, sia perché i fusi orari possono introdurre delle complicazioni nel confronto delle ore97 Prova a esplorare l’aiuto sulle funzioni scrivendo (o copiando e incollando) nella tua console: ?table ?ts ?DateTimeClasses ?as.Date Oppure studia questi semplici esempi: # Tabelle # ecco una tabella che conta il numero di casi con nessun miglioramento (None) # qualche miglioramento (Some) e un deciso miglioramento (Marked), # in funzione del trattamento (Placebo o Treated) e del sesso tabella_artrite &lt;- table(Arthritis$Treatment, Arthritis$Improved, Arthritis$Sex) tabella_artrite ## , , = Female ## ## ## None Some Marked ## Placebo 19 7 6 ## Treated 6 5 16 ## ## , , = Male ## ## ## None Some Marked ## Placebo 10 0 1 ## Treated 7 2 5 # ha classe tabella ma è anche un array di interi! class(tabella_artrite) ## [1] &quot;table&quot; is.array(tabella_artrite) ## [1] TRUE is.integer((tabella_artrite)) ## [1] TRUE Le serie temporali (time series) sono importanti in molti campi, ma specialmente in economia. R ha oggetti speciali per le serie temporali, che sono generati dalla funzione ts(). # un oggetto di classe time series: data(&quot;AirPassengers&quot;) # sono i totali, in migliaia, dei passaggeri delle linee aeree mondiali dal 1949 al 1960, per mese AirPassengers ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 112 118 132 129 121 135 148 148 136 119 104 118 ## 1950 115 126 141 135 125 149 170 170 158 133 114 140 ## 1951 145 150 178 163 172 178 199 199 184 162 146 166 ## 1952 171 180 193 181 183 218 230 242 209 191 172 194 ## 1953 196 196 236 235 229 243 264 272 237 211 180 201 ## 1954 204 188 235 227 234 264 302 293 259 229 203 229 ## 1955 242 233 267 269 270 315 364 347 312 274 237 278 ## 1956 284 277 317 313 318 374 413 405 355 306 271 306 ## 1957 315 301 356 348 355 422 465 467 404 347 305 336 ## 1958 340 318 362 348 363 435 491 505 404 359 310 337 ## 1959 360 342 406 396 420 472 548 559 463 407 362 405 ## 1960 417 391 419 461 472 535 622 606 508 461 390 432 # nota come sia formattato come una matrice # creiamo una serie fittizia con frequenza annuale i_miei_anni &lt;-ts(1:50, start = 1960, frequency = 1) # per frequency 1 rappresenta gli anni, 4 i trimestri, 12 i mesi, # 6 groups di 10 minuti in un&#39;ora, 7 i giorni, 24 le ore in un giorno # 30 i mesi in un anno print(i_miei_anni) ## Time Series: ## Start = 1960 ## End = 2009 ## Frequency = 1 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # ora una serie mensile, dal 1960 al 1968 (i_miei_mesi &lt;- ts(c(1:50,50:1), start = c(1960,2), frequency = 12)) ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1960 1 2 3 4 5 6 7 8 9 10 11 ## 1961 12 13 14 15 16 17 18 19 20 21 22 23 ## 1962 24 25 26 27 28 29 30 31 32 33 34 35 ## 1963 36 37 38 39 40 41 42 43 44 45 46 47 ## 1964 48 49 50 50 49 48 47 46 45 44 43 42 ## 1965 41 40 39 38 37 36 35 34 33 32 31 30 ## 1966 29 28 27 26 25 24 23 22 21 20 19 18 ## 1967 17 16 15 14 13 12 11 10 9 8 7 6 ## 1968 5 4 3 2 1 # un calendario settimanale, che parte dal 12° giorno della 12° settimana i_miei_giorni &lt;- ts(c(1:7,7:1,1:7,7:1), start = c(12,2), frequency = 7) print(i_miei_giorni, calendar = T) ## p1 p2 p3 p4 p5 p6 p7 ## 12 1 2 3 4 5 6 ## 13 7 7 6 5 4 3 2 ## 14 1 1 2 3 4 5 6 ## 15 7 7 6 5 4 3 2 ## 16 1 Anche gli oggetti di tempo e data hanno comandi dedicati. Ecco per esempio un vettore di variabili di tipo carattere, nel formato di default per le date: anno, mese, giorno le_mie_date &lt;- c(&quot;1962/02/14&quot;,&quot;1964/12/07&quot;) typeof(le_mie_date) ## [1] &quot;character&quot; le_mie_date_sbagliate &lt;- c(&quot;14/02/1962&quot;,&quot;07/12/1964&quot;) # convertiamo in date le_mie_Date &lt;- as.Date(le_mie_date) typeof(le_mie_Date) ## [1] &quot;double&quot; # uso la coercizione per trasformare in numero as.numeric(le_mie_Date) ## [1] -2878 -1851 Nota come si tratti di interi: il numero di giorni dal 1/1/1970 (negativi se la data è precedente). Fornendo a R la formattazione corretta è possibile convertire diversi formati le_mie_Date_formattate &lt;- as.Date(le_mie_date_sbagliate, &quot;%d/%m/%Y&quot;) le_mie_Date_formattate ## [1] &quot;1962-02-14&quot; &quot;1964-12-07&quot; Esplora l’aiuto di as.Date per i diversi codici di formattazione. Ovviamente il formato si può cambiare: le_mie_Date_formattate &lt;- format(le_mie_Date_formattate, format = &quot;%A %d %B %y&quot;) le_mie_Date_formattate ## [1] &quot;Wednesday 14 February 62&quot; &quot;Monday 07 December 64&quot; format(le_mie_Date_formattate, format = &quot;%a %d %b %y&quot;) ## [1] &quot;Wednesday 14 February 62&quot; &quot;Monday 07 December 64 &quot; le_mie_Date_formattate ## [1] &quot;Wednesday 14 February 62&quot; &quot;Monday 07 December 64&quot; Ci sono funzioni speciali per ottenere l’ora e la data di sistema e si possono fare operazioni su date: oggi &lt;- Sys.time() ora &lt;- date() Si possono calcolare differenze fra date, in diverse unità. Scrivi questo nella console: &gt;?difftime difftime(le_mie_Date[2], le_mie_Date[1], units = &quot;weeks&quot;) ## Time difference of 146.7143 weeks Se vuoi saperne di più sui formati di data e tempo leggi Advanced R o la vignetta per il pacchetto lubridate. 4.8 Indirizzare, selezionare. Un’attività fondamentale in R è quella di selezionare singoli elementi o gruppi di elementi appartenenti ad oggetti più complessi, in modo da poterli visualizzare, utilizzare come input in altri comandi, o cambiarne il valore. Anche se nel capitolo 9 vedremo alcuni comandi piuttosto intuitivi usati per estrarre colonne, righe o sottoinsiemi da un data frame o una tibble, è indispensabile conoscere gli operatori di base, come [], [[]] e $. 4.8.1 Indirizzare per posizione. Per tutti i tipi di vettori di R è possibile indirizzare singoli elementi per posizione usando []. Ogni elemento di un vettore ha un indice e in R gli indici partono da 1 (l’ho già detto?). Nei vettori a una dimensione sarà possibile indirizzare un singolo elemento indicandone la posizione, o gruppi di elementi usando una sequenza o un vettore di posizioni, adiacenti o non adiacenti. Nei vettori a 2 o più dimensioni (matrici, array, data frame) è possibile indirizzare singole posizioni (usando gli indici del singolo elemento per tutte le dimensioni) o gruppi di elementi appartenenti a diverse righe, colonne, strati. # partiamo da un singolo vettore ad una dimensione due_vettori ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; # ed estraiamo il 3° elemento due_vettori[3] ## [1] &quot;3&quot; # i primi 3 due_vettori[1:3] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; # i primi tre, ma in ordine inverso due_vettori[3:1] ## [1] &quot;3&quot; &quot;2&quot; &quot;1&quot; # con un vettore di posizioni (adiacenti o meno) due_vettori[c(1,2,4,7)] ## [1] &quot;1&quot; &quot;2&quot; &quot;1&quot; &quot;d&quot; # naturalmente possiamo usare queste espressioni per assegnare l&#39;oggetto # risultante a un nome quattro_elementi &lt;- due_vettori[c(1,2,4,7)] # ripetere l&#39;indice di una posizione è l&#39;equivalente di duplicare o # triplicare l&#39;elemento nel vettore che ne risulta due_vettori[c(1,1,1,2,2,2)] ## [1] &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; # possiamo usare gli indici per cambiare singoli elementi o elementi multipli # di un vettore esistente a ## [1] 1 2 3 a[3] &lt;- 4 a ## [1] 1 2 4 a[c(1,3)] &lt;- c(3,1) a ## [1] 3 2 1 Ovviamente, indirizzare e selezionare in oggetti a due o più dimensioni è più complesso, ma abbastanza intuitivo. In un oggetto a due dimensioni, come una matrice o un data frame, se usiamo un solo indice indirizziamo le colonne. tre_per_tre ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 tre_per_tre[2] ## E ## A 4 ## B 5 ## C 6 tre_per_tre[c(1,2)] ## D E ## A 1 4 ## B 2 5 ## C 3 6 Per indirizzare le righe possiamo usare la notazione [n,]: “,” seleziona tutte le colonne o, analogamente, tutte le righe: tre_per_tre[2,] ## D E F ## B 2 5 8 tre_per_tre[,2] ## [1] 4 5 6 Possiamo indirizzare un singolo elemento usando entrambi gli indici, di riga e colonna o indirizzare un gruppo di elementi, adiacenti o meno, usando vettori di posizioni: # indici di riga e colonna tre_per_tre[1,1] ## [1] 1 # vettori di posizioni tre_per_tre[c(1,2),c(1,2)] ## D E ## A 1 4 ## B 2 5 tre_per_tre[c(1,3),c(1,3)] ## D F ## A 1 7 ## C 3 9 Vale quanto detto in precedenza: possiamo usare questa procedura per attribuire gli oggetti risultanti ad altri nomi o per assegnare nuovi valori a elementi singoli o multipli: # usare indici per assegnare due_per_due &lt;- tre_per_tre[c(1,3),c(1,3)] due_per_due ## D F ## A 1 7 ## C 3 9 due_per_due[1,1] &lt;- 2 due_per_due ## D F ## A 2 7 ## C 3 9 # lo stesso vale per i data frame iris[1:5,1:5] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa Principi analoghi valgono per gli array: array_senza_nomi ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 1 2 ## [2,] 1 1 2 ## [3,] 1 1 2 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 2 3 3 ## [2,] 2 3 3 ## [3,] 2 3 3 # un vettore di un elemento array_senza_nomi[1,2,1] ## [1] 1 # un vettore composto dalle prime tre righe della 2° colonna del 2° strato array_senza_nomi[1:3,2,2] ## [1] 3 3 3 # la , può essere usata per intere righe o colonne iris[1,] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa array_senza_nomi[,1,1] ## [1] 1 1 1 array_senza_nomi[1,2,] ## [1] 1 3 Anche per le liste (e per le liste annidate) è possibile usare l’indirizzamento per posizione con [], ma gli elementi vengono estratti come liste. Per estrarre un elemento di una lista con la sua classe di origine è necessario usare l’operatore [[]]. E’ importante ricordare bene l’uso di [] e [[]] per le liste, perché altrimenti si possono ottenere risultati erronei o inattesi. Infine, per i vettori atomici a più di una dimensione (matrici e array), bisogna fornire indici per tutte le dimensioni. Che succede se usi una sola dimensione? prova da solo con array_senza_nomi. # una lista annidata la_mia_prima_lista_con_nomi ## $a ## [1] 1 2 3 ## ## $b ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## ## $c ## [1] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; ## [10] &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ## ## $d ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 ## ## $e ## $e[[1]] ## [1] 1 2 3 ## ## $e[[2]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## ## $e[[3]] ## [1] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; ## [10] &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ## ## $e[[4]] ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 # il primo elemento, come lista la_mia_prima_lista_con_nomi[1] ## $a ## [1] 1 2 3 class(la_mia_prima_lista_con_nomi[1]) ## [1] &quot;list&quot; # con la sua classe originale la_mia_prima_lista_con_nomi[[1]] ## [1] 1 2 3 class(la_mia_prima_lista_con_nomi[[1]]) ## [1] &quot;numeric&quot; # un elemento di un elemento # come lista # prima troviamo la lunghezza della lista length(la_mia_prima_lista_con_nomi) ## [1] 5 # il quinto elemento, oltre ad essere un bel film, è una lista, # il cui 4° elemento è una matrice la_mia_prima_lista_con_nomi[[5]][[4]] ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 # estraggo la prima colonna la_mia_prima_lista_con_nomi[[5]][[4]][,1] ## A B C ## 1 2 3 # questo funziona, e calcola la somma degli elementi del primo vettore sum(la_mia_prima_lista_con_nomi[[1]]) ## [1] 6 Questo invece non funzionerebbe, prova a scrivrlo nella console: &gt;sum(la_mia_prima_lista_con_nomi[1]) 4.8.2 Usare i nomi. I nomi98 sono attributi particolarmente importanti per le operazioni di indirizzamento e di filtraggio. L’operatore $ permette di indirizzare per nome le colonne (in data frame e tibble99) o gli elementi (nelle liste)100. E’ importante ricordare due proprietà di questo operatore: se usato per le colonne di data frame o tibble $, se non c’è ambiguità funziona anche con corrispondenze parziali101 nelle liste estrae gli elementi con la loro classe originale E’ possibile combinare l’indirizzamento con $ con quello con []. # i primi 5 elementi della colonna Improved in Arthritis Arthritis$Improved[1:5] ## [1] Some None None Marked Marked ## Levels: None &lt; Some &lt; Marked # gli stessi elementi, riordinati usando un vettore di posizioni Arthritis$Improved[c(4,5,3,2,1)] ## [1] Marked Marked None None Some ## Levels: None &lt; Some &lt; Marked # i nomi delle variabili in Arthritis colnames(Arthritis) ## [1] &quot;ID&quot; &quot;Treatment&quot; &quot;Sex&quot; &quot;Age&quot; &quot;Improved&quot; Che succede se uso solo la A? Dal momento che viene trovata anche una corrispondenza parziale, restituirà Age (per brevità uso head() per ottenere solo i primi elementi): head(Arthritis$A) ## [1] 27 29 30 32 46 58 # non funziona con iris # questo funziona head(iris$Petal.Length,10) ## [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 # questo no head(iris$P,10) ## NULL Nelle liste $ estrae l’elemento con la sua classe originale. Proviamo innanzitutto a dare nomi a elementi dell’elemento e della lista la_mia_prima_lista_con_nomi names(la_mia_prima_lista_con_nomi$e) &lt;- c(&quot;aa&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;ad&quot;) # e ora vediamo che succede la_mia_prima_lista_con_nomi$a ## [1] 1 2 3 class(la_mia_prima_lista_con_nomi$a) ## [1] &quot;numeric&quot; la_mia_prima_lista_con_nomi$e ## $aa ## [1] 1 2 3 ## ## $ab ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## ## $ac ## [1] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; ## [10] &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ## ## $ad ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 class(la_mia_prima_lista_con_nomi$e) ## [1] &quot;list&quot; la_mia_prima_lista_con_nomi$e$aa ## [1] 1 2 3 4.8.3 Usare valori logici. Infine, il modo forse più flessibile per indirizzare elementi è quello di usare valori logici, sia come il risultato di operazioni e confronti, che come vettori o matrici logiche. Alcuni esempi chiariranno meglio il concetto. Per queste operazioni sono molto utili: l’operatore %in% che permettono di trovare corrispondenze di un vettore in un altro, restituendo un vettore logico la funzione which() che restituisce un vettore delle posizioni con valore T in un vettore logico la funzione subset() che permette di estrarre elementi da vettori, matrici o data frame sulla base di condizioni logiche Per selezionare, attribuire o sostituire elementi è possibile usare vettori logici creati per l’occasione o ottenuti come risultato di altre funzioni: tre_selezioni &lt;- c(T,F,T) # estrae il 1° e terzo elemento da vettore_con_nomi e li # attribuisce a un altro vettore due_elementi &lt;- vettore_con_nomi[tre_selezioni] Naturalmente è possibile fare lo stesso con matrici: prova a capire cosa succede negli esempi successivi. tre_per_tre_logica &lt;- matrix(rep(c(T,T,F),3), nrow = 3, ncol = 3, byrow = F) per_colonne ## D E F ## A 1 4 7 ## B 2 5 8 ## C 3 6 9 per_colonne[tre_per_tre_logica] ## [1] 1 2 4 5 7 8 per_colonne&gt;3 ## D E F ## A FALSE TRUE TRUE ## B FALSE TRUE TRUE ## C FALSE TRUE TRUE maggiore_di_tre &lt;- per_colonne&gt;3 per_colonne[per_colonne&gt;3] ## [1] 4 5 6 7 8 9 per_colonne[maggiore_di_tre] ## [1] 4 5 6 7 8 9 which(per_colonne&gt;3) ## [1] 4 5 6 7 8 9 # cosa restituiscono? # cosa succede qui? colnames(Arthritis) ## [1] &quot;ID&quot; &quot;Treatment&quot; &quot;Sex&quot; &quot;Age&quot; &quot;Improved&quot; colnames(Arthritis) == &quot;ID&quot; ## [1] TRUE FALSE FALSE FALSE FALSE # che vettore restituisce l&#39;espressione precedente? # individuare le posizioni di due colonne in Arthritis sulla base dei nomi # nota l&#39;uso dell&#39;operatore |, che rappresenta un OR logico, # sono selezionate le condizioni per cui è vera l&#39;una o l&#39;altra espressione colnames(Arthritis) == &quot;ID&quot; | colnames(Arthritis) == &quot;Age&quot; ## [1] TRUE FALSE FALSE TRUE FALSE # oppure potrei usare %in% # creo un vettore dei nomi che voglio cercare i_nomi &lt;- c(&quot;ID&quot;,&quot;Age&quot;) colnames(Arthritis) %in% i_nomi ## [1] TRUE FALSE FALSE TRUE FALSE # e ne estraggo le posizioni con which() which(colnames(Arthritis) %in% i_nomi) ## [1] 1 4 head(Arthritis[which(colnames(Arthritis) %in% i_nomi)]) ## ID Age ## 1 57 27 ## 2 46 29 ## 3 77 30 ## 4 17 32 ## 5 36 46 ## 6 23 58 La funzione subset() consente invece di filtrare righe sulla base di condizioni logiche e di selezionare opzionalmente solo alcune variabili subset(Arthritis, Age &gt; 67, select = Sex:Improved) ## Sex Age Improved ## 13 Male 69 None ## 14 Male 70 Marked ## 37 Female 68 Some ## 38 Female 68 Marked ## 39 Female 69 None ## 40 Female 69 Some ## 41 Female 70 Some ## 83 Female 68 Some ## 84 Female 74 Marked Gli stessi risultati possono essere ottenuti con gli operatori e i metodi descritti prima, ma in maniera decisamente più complessa. Vuoi provarci? Molte altre utili funzioni per selezionare e estrarre elementi con una sintassi molto più intuitiva sono disponibili in pacchetti del tidyverse, come dplyr, ed avremo modo di parlarne nei capitoli successivi per poi descriverle in maniera più sistematica nel capitolo 9. 4.9 attach(), with(), within(). R è piuttosto pignolo come linguaggio: bisogna indicare specificamente dove cercare l’oggetto su cui eseguire una operazione. Nell’esempio seguente, la colonna Age compare in più di un data frame e, se vogliamo utilizzarla in una funzione, dobbiamo indicare esplicitamente dove si trova. Questo rende molto verbosi i comandi. Alcune funzioni del pacchetto base permettono di aggirare questo problema, che, a dire la verità, è gestito molto meglio nell’insieme dei pacchetti del tidyverse (vedi capitolo 9). Anche se lo abbiamo già fatto, apriamo il data set Arthritis e creiamone una copia (bisogna aver caricato il pacchetto vcd): # library(vcd) data(Arthritis) Arthr1 &lt;- Arthritis[1:20,] Arthr2 &lt;- Arthritis[21:40,] La variabile Age è in entrambi; usare solo il nome di colonna non funzionerebbe, prova tu a inserire nella console: &gt; head(Age) Per permettere a R di “trovare” Age dobbiamo dire dove cercare: head(Arthr1$Age, 5) ## [1] 27 29 30 32 46 head(Arthr2$Age, 5) ## [1] 48 55 55 56 57 Questo rende i comandi “verbosi”. Qui cerco i valori di Age per Sex == “Female” Arthr1$Age[Arthr1$Sex == &quot;Female&quot;] ## [1] 23 32 37 41 41 48 Naturalmente questi valori sarebbero diversi per Arthr2 Arthr2$Age[Arthr2$Sex == &quot;Female&quot;] ## [1] 48 55 55 56 57 57 57 58 59 59 60 61 62 62 66 67 68 68 69 69 attach() semplifica alcune di queste operazioni; tuttavia, per evitare ambiguità, è sempre opportuno usare detach() per “staccare” l’oggetto dal percorso di ricerca: attach(Arthr1) head(Treatment,5) ## [1] Treated Treated Treated Treated Treated ## Levels: Placebo Treated summary(Treatment) ## Placebo Treated ## 0 20 detach(Arthr1) Arthr2$Age[Arthr2$Sex == &quot;Female&quot;] ## [1] 48 55 55 56 57 57 57 58 59 59 60 61 62 62 66 67 68 68 69 69 La funzione summary() fornisce alcune statistiche riassuntive per un oggetto; le statistiche variano con il tipo di variabile. In alternativa è possibile usare with() with(Arthr1, sum(Age)) ## [1] 955 Gli oggetti creati all’interno di with() non sono disponibili nel global environment; per questo bisogna usare il comando &lt;&lt;- per l’assegnazione with(Arthr1, somma_età &lt;- sum(Age)) print(somma_età) restituirebbe un errore mentre questi due comandi funzionano: with(Arthr1, somma_età_2 &lt;&lt;- sum(Age)) somma_età_2 ## [1] 955 4.10 Funzioni “built-in” e funzioni definite dall’utente. In R tutto quello che accade, accade perché hai invocato una funzione: lo ho già detto, no? Abbiamo già visto moltissime funzioni e moltissime altre ne incontrerai nella tua carriera di programmatore. Se vuoi puoi saltare questo paragrafo: in fondo, puoi imparare le funzioni “sul campo”, usandole man mano che ti servono. Tuttavia, è bene mettere alcuni punti fermi. 4.10.1 Semplici funzioni matematiche, trigonometriche, statistiche, logiche, etc. R base ha moltissime funzioni matematiche, statistiche, logiche e molte altre sono aggiunte dai pacchetti contribuiti da utenti. Qui ne richiamerò solo alcune, aggiungendo qualche altro piccolo elemento sulla priorità delle operazioni, etc., giusto nel caso tu non abbia mai avuto nessuna esperienza di programmazione. Per maggiori informazioni sugli operatori puoi visitare questa pagina, mentre per le funzioni più comuni puoi visitare questa. 4.10.2 Operatori. Gli operatori matematici e logici in R non sono molto diversi da quelli che si usano in altri linguaggi, o, se per questo, nelle formule dei più comuni fogli di calcolo. Operatori matematici Operatore Cosa fa? Uso + addizione 1 + 2 - sottrazione 2 - 1 * moltiplicazione 3 * 1 / divisione 4 / 2 ^ o ** elevazione a potenza 2^2 x%%y modulo 7%%3 (=1) x%/%y divisione intera 7%/%3 (=2) Gli operatori matematici sono, a tutti gli effetti, delle funzioni102. Ricorda che puoi usare la console come se fosse una calcolatrice: prova a scrivere nella console il seguente codice (ricorda di rimuovere il prompt e premere invio alla fine di ogni riga): &gt;1+2 &gt;2^5 &gt;7%%2 &gt;5/0 &gt;0/0 La priorità delle operazioni è quella solita (^,/ e *, + e -) e, per modificarla, occorre usare le parentesi tonde. Inoltre in R le operazioni sono vettorializzate. Guarda questi semplici esempi per capire meglio il funzionamento degli operatori matematici. # attenzione alla priorità nelle operazioni x &lt;- 1+4/2 x ## [1] 3 x &lt;- (1+4)/2 x ## [1] 2.5 # le operazioni sono vettorializzate; guarda che succede se aggiungo # uno scalare a un vettore o se moltiplico uno scalare per un vettore y &lt;- c(1,2,3,4) (y+1) ## [1] 2 3 4 5 (y*1.1) ## [1] 1.1 2.2 3.3 4.4 # attenzione all&#39;effetto degli NA z &lt;- c(1,2,3,4,NA) (z/2) ## [1] 0.5 1.0 1.5 2.0 NA # nelle operazioni fra vettori, il vettore più corto viene riciclato, # se necessario con un warning w &lt;- c(1,2) # è un vettore di lunghezza inferiore a y length(w) &lt; length(y) ## [1] TRUE w ## [1] 1 2 y ## [1] 1 2 3 4 (w+y) ## [1] 2 4 4 6 k&lt;-c(1,2,3) (y+k) ## Warning in y + k: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 5 # qui solo i primo elemento viene riciclato Nota che le operazioni a virgola mobile potrebbero dare risultati sorprendenti: quindi (sqrt(2))^2==2 è falso; la funzione near()di dplyrserve proprio per affrontare questo problema: dplyr::near((sqrt(2)^2),2). Nota inoltre che la moltiplicazione fra matrici è un’operazione diversa da quella condotta con l’operatore *: x %*% y. Come probabilmente ricorderai dai corsi di matematica e algebra lineare che hai frequentato perché l’operazione sia possibile il numero di colonne di x deve essere uguale al numero di righe di y; se x è una matrice nxm e y è mxp il risultato è una matrice nxp. una_matrice &lt;- matrix(c(1.1,1.2,1.3,2.1,2.2,2.3), nrow = 2, ncol=3, byrow = T) una_matrice ## [,1] [,2] [,3] ## [1,] 1.1 1.2 1.3 ## [2,] 2.1 2.2 2.3 # guarda quello che succede con operazioni con vettori di diversa # lunghezza una_matrice+0.05 ## [,1] [,2] [,3] ## [1,] 1.15 1.25 1.35 ## [2,] 2.15 2.25 2.35 una_matrice*0.5 ## [,1] [,2] [,3] ## [1,] 0.55 0.6 0.65 ## [2,] 1.05 1.1 1.15 (una_nuova_matrice &lt;- una_matrice+c(0.01,0.02,0.03)) ## [,1] [,2] [,3] ## [1,] 1.11 1.23 1.32 ## [2,] 2.12 2.21 2.33 (una_matrice + c(0.1,0.05)) ## [,1] [,2] [,3] ## [1,] 1.20 1.30 1.40 ## [2,] 2.15 2.25 2.35 # le operazioni avvengono per colonna e i vettori più corti vengono # riciclati La coercizione può dare risultati interessanti. Prova ad eseguire le seguenti operazioni nella console: &gt;un_logico &lt;- c(T,T,F) &gt;3*un_logico &gt;un_fattore &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;)) &gt;3*un_fattore &gt;3*as.numeric(un_fattore) Come ti spieghi i risultati? Operatori logici. L’uso di operatori logici è molto frequente in R. Gli operatori logici, prevedibilmente, restituiscono vettori di valori logici (che sono equivalenti agli interi 1 per TRUE e 0 per FALSE). Operatore Description Esempio &lt; minore di 5 &lt; 4 è FALSE &gt; maggiore di 5 &gt; 4 è TRUE &lt;= minore o uguale a 5 &lt;= 5 è TRUE &gt;= maggiore o uguale a 5 &gt;= 4 è TRUE == esattamente uguale a 2 == 2 è TRUE != diverso da 2 != 2 è FALSE !x non x !(2 != 2) è TRUE x y x OR y x &amp; y x AND y (5&lt;4) isTRUE(x) verifica se X è TRUE isTRUE(5&lt;=5) è TRUE Gli operatori logici sono abbastanza semplici da usare e da comprendere e possono essere combinati in vari modi soprattutto per filtrare i dati (vedi capitolo 9). Se vuoi vedere una rappresentazione grafica del loro funzionamento guarda qui. 4.10.3 Funzioni built-in. R base fornisce numerosissime funzioni matematiche, trigonometriche e statistiche, oltre a funzioni che operano su caratteri. La lista è decisamente troppo lunga per citarla qui. Mi limiterò a presentare alcuni semplici esempi. Per una lista (più o meno) completa guarda qui. Ricorda che ogni funzione è caratterizzata da un nome e da una serie di argomenti, e può restituire un valore o avere un effetto collaterale (la stampa di qualcosa nella console, il salvataggio di un file). Molte funzioni prendono vettori o scalari come input; ecco come si calcola la radice quadrata sqrt(c(1,4,9)) ## [1] 1 2 3 Nota che l’argomento di una funzione può essere un’altra funzione, come in effetti accade nella riga precedente: c() è essa stessa una funzione. Il calcolo del logaritmo neperiano (attent* agli errori!, possono bloccare il flusso di uno script): log(10) ## [1] 2.302585 Logaritmo in base 10 di e log10(exp(1)) ## [1] 0.4342945 Un modo per “intrappolare” un errore: try(log(-1)) ## Warning in log(-1): NaNs produced ## [1] NaN Cerca try() e tryCatch() nell’aiuto. Alcune funzioni che prendono vettori come input # calcola la somma della colonna Age in Arthritis sum(Arthritis$Age) ## [1] 4482 # calcola la media mean(Arthritis$Age) ## [1] 53.35714 Alcune funzioni restituiscono un vettore di valori, come il calcolo del range, o la statistica a 5 numeri di Tukey (minimum, lower-hinge, median, upper-hinge, maximum: lower hing e upper hinge corrispondono al primo e terzo quartile) range(Arthritis$Age) ## [1] 23 74 with(Arthritis, fivenum(Age)) ## [1] 23 46 57 63 74 Ecco un po’ di esempi di funzioni che operano su caratteri: # incollare più valori di testo, con uno spaziatore paste(&quot;questo&quot;, &quot;capitolo&quot;, &quot;è un po&#39; lungo&quot;, sep =&quot; &quot;) ## [1] &quot;questo capitolo è un po&#39; lungo&quot; # trovare gli elementi di un vettore che contengono una lettera # o un pattern di caratteri # la lettera e in qualsiasi posizione grep(&quot;e&quot;, c(&quot;Teresa&quot;,&quot;Mario&quot;,&quot;Adele&quot;)) ## [1] 1 3 # la lettera e alla fine grep(&quot;e$&quot;, c(&quot;Teresa&quot;,&quot;Mario&quot;,&quot;Adele&quot;)) ## [1] 3 # restituire un valore logico che indica se un pattern è presente in # un vettore grepl(&quot;e&quot;, c(&quot;Teresa&quot;,&quot;Mario&quot;,&quot;Adele&quot;)) ## [1] TRUE FALSE TRUE Le funzioni base di R che si applicano a vettori di caratteri sono decisamente scomode da ricordare e da usare. Il pacchetto stringr del tidyverse è decisamente migliore (vedi capitolo 9). Per lavorare bene con le stringhe è opportuno imparare almeno qualcosa delle “espressioni regolari” (regex, regular expression): sono un modo conciso e flessibile per individuare insiemi di caratteri in una stringa. Potete trovare delle buone introduzioni in “R for data science” e in questa vignetta. Infine attent* a come scrivi il codice: R in effetti si legge dall’interno verso l’esterno e da destra a sinistra e questo può creare confusione. Guarda che succede in questo chunk di codice, che attribuisce ad un oggetto la media del logaritmo dei valori della variabile Arthritis$Age: # più sintetico, ma difficile da leggere (media_log_age &lt;- mean(log10(Arthritis$Age))) ## [1] 1.712026 # meno sintetico ma più facile da leggere logAge &lt;- log10(Arthritis$Age) media_log_age &lt;- mean(logAge) media_log_age ## [1] 1.712026 4.10.4 Funzioni definite dall’utente. Le funzioni definite dall’utente sono molto importanti nella scrittura di codice in R: permettono di semplificare operazioni, renderle più efficienti e flessibili e meno soggette ad errore. Le funzioni vengono create con il comando function() ed è possibile assegnare (o meno) un nome ad una funzione. Come le funzioni di R e le funzioni disponibili nei pacchetti, le funzioni possono avere un certo numero di parametri opzionali, con dei valori di default. Quello che segue è un semplice esempio di funzione che restituisce media (eventualmente una media sfrondata o trimmed mean) e deviazione standard o, in alternativa, mediana e deviazione assoluta mediana. Le prime due misure sono più adatte a variabili quantitative continue con una distribuzione che si approssima a quella normale, le altre due a distribuzioni che si discostano significativamente da quella normale e che presentano valori estremi. Se non ricordi cosa sono queste statistiche guarda l’aiuto delle funzioni e consulta un libro di statistica. stat_descrittive &lt;- function(x, parametriche=TRUE, stampa=FALSE, trm = 0.05, narm = T) { if (parametriche) { valore_centrale &lt;- mean(x, trim = trm, na.rm = narm) dispersione &lt;- sd(x, na.rm = narm) } else { valore_centrale &lt;- median(x, na.rm = narm) dispersione &lt;- mad(x, na.rm = narm) } if (stampa &amp; parametriche) { cat(&quot;Media=&quot;, valore_centrale, &quot;\\n&quot;, &quot;SD=&quot;, dispersione, &quot;\\n&quot;) } else if (stampa &amp; !parametriche) { cat(&quot;Median=&quot;, valore_centrale, &quot;\\n&quot;, &quot;MAD=&quot;, dispersione, &quot;\\n&quot;) } risultato &lt;- c(valore_centrale, dispersione) if (parametriche){ names(risultato) &lt;- c(&quot;media&quot;,&quot;SD&quot;) } else { names(risultato) &lt;- c(&quot;mediana&quot;,&quot;MAD&quot;) } return(risultato) } stat_età &lt;- stat_descrittive(Arthritis$Age) print(stat_età, digits = 4) ## media SD ## 53.91 12.77 # non parametriche, con stampa stat_età &lt;- stat_descrittive(Arthritis$Age, parametriche = F, stampa = T) ## Median= 57 ## MAD= 10.3782 # parametriche, media sfrondata (o trimmed mean, vengono eliminati il 10% dei valori estremi, # niente stampa) stat_età &lt;- stat_descrittive(Arthritis$Age, parametriche = T, trm = 0.1) print(stat_età, digits = 4) ## media SD ## 54.44 12.77 Prenditi qualche minuto per capire come funziona la funzione prima di leggere il testo che segue il prossimo esempio, che mostra come il codice che sarebbe necessario scrivere senza la funzione sarebbe più verboso. # voglio calcolare media e deviazione standard su la stessa # variabile in tre data frame e creare un vettore con nomi con i risultati stat_età_1 &lt;- c(media = mean(Arthritis$Age, trm = 0.1), SD = sd(Arthritis$Age)) stat_età_1 ## media SD ## 53.35714 12.76917 stat_età_2 &lt;- c(media = mean(Arthr1$Age, trm = 0.1), SD = sd(Arthritis$Age)) stat_età_2 ## media SD ## 47.75000 12.76917 stat_età_3 &lt;- c(media = mean(Arthr2$Age, trm = 0.1), SD = sd(Arthritis$Age)) stat_età_3 ## media SD ## 60.65000 12.76917 # lo stesso con la funzione stat_descrittive(Arthritis$Age, trm = 0.1) ## media SD ## 54.44118 12.76917 stat_descrittive(Arthr1$Age, trm = 0.1) ## media SD ## 47.87500 15.75094 stat_descrittive(Arthr2$Age, trm = 0.1) ## media SD ## 60.750000 5.705722 Bene, la funzione, di default (parametriche = TRUE fra le opzioni), calcola media e deviazione standard per un vettore (che si spera sia numerico, altrimenti la funzione restituirebbe un errore), con una media sfrondata con una soglia di 0.05. Se cambiassimo parametriche = FALSE otterremmo invece mediana e MAD e se indicassimo stampa = TRUE il risultato verrebbe anche mandato in console come testo. La funzione restituisce come risultato un vettore con nomi (anche questi cambiano in funzione dell’opzione parametriche) che può essere assegnato ad un nome. Nota come la funzione faccia uso di strutture di controllo (if … else) che valutano una condizione per scegliere fra uno o più gruppi di comandi alternativi. E’ chiaramente possibile copiare e incollare il codice stat_età_1 &lt;- c(media = mean(Arthritis$Age, trm = 0.1), SD = sd(Arthritis$Age)) molte volte e modificarlo per ottenere lo stesso risultato. Questo tuttavia è poco efficiente e soggetto a errori. Discuteremo meglio dei vantaggi dell’uso delle funzioni nel Capitolo 9. 4.11 Programmare, con stile. Questo è un libro per pigri e per persone con poca esperienza di programmazione. Per questa ragione ho deciso, molto a malincuore, di spostare tutto il materiale che riguarda più strettamente la programmazione in R nel Capitolo 9. È in quel capitolo che insieme alle tecniche per manipolare (in senso buono, per selezionare, filtrare, trasformare, unire, etc.) i dati (in inglese: data wrangling) tratterò in maniera sistematica dell’uso di strutture come i loop (for, while, repeat), di altre strutture di controllo come if e if ... else e le alternative per “applicare” funzioni a vettori. Come hai già visto, è inevitabile introdurre alcune di queste strutture nel testo: alcune sono piuttosto intuitive, per le altre puoi fare riferimento, quando necessario, al capitolo 9 o alle diverse fonti che ho citato alla fine di questo capitolo. Spero vivamente che alla fine ti renderai conto che ogni minuto speso a imparare a programmare bene, e soprattutto, a scrivere codice leggibile e riproducibile, è un minuto (o un’ora, o un giorno) ben speso, che ti farà risparmiare molto tempo in futuro. 4.12 Un ambiente affollato. Bene, in questo capitolo abbiamo creato parecchi oggetti, che sono finiti in quello che si chiama “Global environment”: se stai usando gli script creati per questo libro prova a vedere in quale pannello appaiono i vari oggetti in RStudio man mano che li crei e che succede cliccando sugli oggetti nel pannello Environment. Oltre ad esaminare l’ambiente di lavoro in modo interattivo usando la GUI di RStudio è possibile “interrogare” l’ambiente con delle funzioni. # elencare gli oggetti nell&#39;ambiente di lavoro e assegnare # l&#39;elenco ad un oggetto i_miei_oggetti &lt;- ls() head(i_miei_oggetti,10) ## [1] &quot;a&quot; &quot;a_capo&quot; &quot;AirPassengers&quot; ## [4] &quot;array_per_colonne&quot; &quot;array_senza_nomi&quot; &quot;Arthr&quot; ## [7] &quot;Arthr1&quot; &quot;Arthr2&quot; &quot;Arthritis&quot; ## [10] &quot;b&quot; # che tipo di oggetto ho creato? Per ottenere informazioni sulla struttura di tutti gli oggetti scrivi nella console (l’output è molto lungo) &gt;ls.str() Il risultato può essere assegnato a una lista di classe ls_str Per ottenere informazioni sugli oggetti che hanno nomi riconducibili ad un determinato pattern è possibile usare delle espressioni regolari: # in questo esempio quelli che hanno un nome che inizia per A maiuscola ls.str(pattern=&quot;^A&quot;) ## AirPassengers : Time-Series [1:144] from 1949 to 1961: 112 118 132 129 121 135 148 148 136 119 ... ## Arthr : &#39;data.frame&#39;: 84 obs. of 5 variables: ## $ ID : int 80 12 29 38 51 54 76 16 69 31 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Age : int 23 30 30 32 37 44 45 46 48 49 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 1 1 1 1 1 1 1 1 1 1 ... ## Arthr1 : &#39;data.frame&#39;: 20 obs. of 5 variables: ## $ ID : int 57 46 77 17 36 23 75 39 33 55 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Age : int 27 29 30 32 46 58 59 59 63 63 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 2 1 1 3 3 3 1 3 1 1 ... ## Arthr2 : &#39;data.frame&#39;: 20 obs. of 5 variables: ## $ ID : int 82 53 79 26 28 60 22 27 2 59 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Age : int 48 55 55 56 57 57 57 58 59 59 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 3 3 3 3 3 3 3 1 3 3 ... ## Arthritis : &#39;data.frame&#39;: 84 obs. of 5 variables: ## $ ID : int 57 46 77 17 36 23 75 39 33 55 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Age : int 27 29 30 32 46 58 59 59 63 63 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 2 1 1 3 3 3 1 3 1 1 ... # o il cui nome contiene &quot;a&quot; o &quot;A&quot;, ls.str(pattern=&quot;A|a&quot;) ## a : num [1:3] 3 2 1 ## a_capo : chr &quot;A\\nB\\nC&quot; ## AirPassengers : Time-Series [1:144] from 1949 to 1961: 112 118 132 129 121 135 148 148 136 119 ... ## array_per_colonne : int [1:3, 1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ... ## array_senza_nomi : num [1:3, 1:3, 1:2] 1 1 1 1 1 1 2 2 2 2 ... ## Arthr : &#39;data.frame&#39;: 84 obs. of 5 variables: ## $ ID : int 80 12 29 38 51 54 76 16 69 31 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Age : int 23 30 30 32 37 44 45 46 48 49 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 1 1 1 1 1 1 1 1 1 1 ... ## Arthr1 : &#39;data.frame&#39;: 20 obs. of 5 variables: ## $ ID : int 57 46 77 17 36 23 75 39 33 55 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Age : int 27 29 30 32 46 58 59 59 63 63 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 2 1 1 3 3 3 1 3 1 1 ... ## Arthr2 : &#39;data.frame&#39;: 20 obs. of 5 variables: ## $ ID : int 82 53 79 26 28 60 22 27 2 59 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Age : int 48 55 55 56 57 57 57 58 59 59 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 3 3 3 3 3 3 3 1 3 3 ... ## Arthritis : &#39;data.frame&#39;: 84 obs. of 5 variables: ## $ ID : int 57 46 77 17 36 23 75 39 33 55 ... ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Age : int 27 29 30 32 46 58 59 59 63 63 ... ## $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 2 1 1 3 3 3 1 3 1 1 ... ## billboard : tibble [317 × 79] (S3: tbl_df/tbl/data.frame) ## calcola_media : function (vettore_numerico) ## chiamate_multiple : &#39;difftime&#39; num 0.00333189964294434 ## data_frame_4 : &#39;data.frame&#39;: 8 obs. of 3 variables: ## $ quattro : int 1 2 3 4 1 2 3 4 ## $ quattro_coppie: int 1 1 2 2 3 3 4 4 ## $ mantra : chr &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## df_a : &#39;data.frame&#39;: 84 obs. of 2 variables: ## $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## fai_la_somma : function (a = 1, b = 2, c = 3) ## fattore_non_o : Factor w/ 2 levels &quot;consonant&quot;,&quot;vowel&quot;: 2 1 1 ## i_miei_anni : Time-Series [1:50] from 1960 to 2009: 1 2 3 4 5 6 7 8 9 10 ... ## la_mia_lista : List of 1 ## $ : chr [1:3] &quot;d&quot; &quot;e&quot; &quot;f&quot; ## la_mia_prima_lista : List of 4 ## $ : num [1:3] 1 2 3 ## $ : chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; ... ## $ : chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## $ : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## la_mia_prima_lista_con_nomi : List of 5 ## $ a: num [1:3] 1 2 3 ## $ b: chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; ... ## $ c: chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## $ d: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## $ e:List of 4 ## la_mia_tibble : tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## le_mie_date : chr [1:2] &quot;1962/02/14&quot; &quot;1964/12/07&quot; ## le_mie_Date : Date[1:2], format: &quot;1962-02-14&quot; &quot;1964-12-07&quot; ## le_mie_Date_formattate : chr [1:2] &quot;Wednesday 14 February 62&quot; &quot;Monday 07 December 64&quot; ## le_mie_date_sbagliate : chr [1:2] &quot;14/02/1962&quot; &quot;07/12/1964&quot; ## le_mie_mediane : Named num [1:8] 0.01172 -0.00352 0.00874 0.02158 0.0077 ... ## logAge : num [1:84] 1.43 1.46 1.48 1.51 1.66 ... ## m_a : chr [1:84, 1:2] &quot;Treated&quot; &quot;Treated&quot; &quot;Treated&quot; &quot;Treated&quot; &quot;Treated&quot; ... ## maggiore_di_tre : logi [1:3, 1:3] FALSE FALSE FALSE TRUE TRUE TRUE ... ## mantra : chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## matrice_carattere : chr [1:3, 1:2] &quot;amore&quot; &quot;amore&quot; &quot;amore&quot; &quot;pace&quot; &quot;pace&quot; &quot;pace&quot; ## matrice_logica : logi [1:3, 1:3] TRUE TRUE TRUE FALSE FALSE FALSE ... ## media_log_age : num 1.71 ## mediane : num [1:8] 0.01172 -0.00352 0.00874 0.02158 0.0077 ... ## mediane_apply : Named num [1:8] 0.01172 -0.00352 0.00874 0.02158 0.0077 ... ## mtcars : &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... ## n_casi : num 10000 ## opar : List of 66 ## $ xlog : logi FALSE ## $ ylog : logi FALSE ## $ adj : num 0.5 ## $ ann : logi TRUE ## $ ask : logi FALSE ## $ bg : chr &quot;white&quot; ## $ bty : chr &quot;o&quot; ## $ cex : num 1 ## $ cex.axis : num 1 ## $ cex.lab : num 1 ## $ cex.main : num 1.2 ## $ cex.sub : num 1 ## $ col : chr &quot;black&quot; ## $ col.axis : chr &quot;black&quot; ## $ col.lab : chr &quot;black&quot; ## $ col.main : chr &quot;black&quot; ## $ col.sub : chr &quot;black&quot; ## $ crt : num 0 ## $ err : int 0 ## $ family : chr &quot;&quot; ## $ fg : chr &quot;black&quot; ## $ fig : num [1:4] 0 1 0 1 ## $ fin : num [1:2] 7 5 ## $ font : int 1 ## $ font.axis: int 1 ## $ font.lab : int 1 ## $ font.main: int 2 ## $ font.sub : int 1 ## $ lab : int [1:3] 5 5 7 ## $ las : int 0 ## $ lend : chr &quot;round&quot; ## $ lheight : num 1 ## $ ljoin : chr &quot;round&quot; ## $ lmitre : num 10 ## $ lty : chr &quot;solid&quot; ## $ lwd : num 1 ## $ mai : num [1:4] 1.02 0.82 0.82 0.42 ## $ mar : num [1:4] 5.1 4.1 4.1 2.1 ## $ mex : num 1 ## $ mfcol : int [1:2] 1 1 ## $ mfg : int [1:4] 1 1 1 1 ## $ mfrow : int [1:2] 1 1 ## $ mgp : num [1:3] 3 1 0 ## $ mkh : num 0.001 ## $ new : logi FALSE ## $ oma : num [1:4] 0 0 0 0 ## $ omd : num [1:4] 0 1 0 1 ## $ omi : num [1:4] 0 0 0 0 ## $ pch : int 1 ## $ pin : num [1:2] 5.76 3.16 ## $ plt : num [1:4] 0.117 0.94 0.204 0.836 ## $ ps : int 12 ## $ pty : chr &quot;m&quot; ## $ smo : num 1 ## $ srt : num 0 ## $ tck : num NA ## $ tcl : num -0.5 ## $ usr : num [1:4] 0 1 0 1 ## $ xaxp : num [1:3] 0 1 5 ## $ xaxs : chr &quot;r&quot; ## $ xaxt : chr &quot;s&quot; ## $ xpd : logi FALSE ## $ yaxp : num [1:3] 0 1 5 ## $ yaxs : chr &quot;r&quot; ## $ yaxt : chr &quot;s&quot; ## $ ylbias : num 0.2 ## ora : chr &quot;Sat Nov 25 08:18:09 2023&quot; ## per_colonne_sbagliato : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## per_colonne_sbagliato_2 : int [1:3, 1:3] 1 2 3 4 5 6 7 8 1 ## play_audio : logi TRUE ## quanto : Factor w/ 4 levels &quot;abbastanza&quot;,&quot;moltissimo&quot;,..: 3 3 4 2 1 ## quanto_ord : Ord.factor w/ 4 levels &quot;poco&quot;&lt;&quot;abbastanza&quot;&lt;..: 3 3 1 4 2 ## quattro_elementi : chr [1:4] &quot;1&quot; &quot;2&quot; &quot;1&quot; &quot;d&quot; ## risultato : logi [1:3] FALSE FALSE FALSE ## somma_età_2 : int 955 ## stat_descrittive : function (x, parametriche = TRUE, stampa = FALSE, trm = 0.05, narm = T) ## stat_età : Named num [1:2] 54.4 12.8 ## stat_età_1 : Named num [1:2] 53.4 12.8 ## stat_età_2 : Named num [1:2] 47.8 12.8 ## stat_età_3 : Named num [1:2] 60.6 12.8 ## tabella_artrite : &#39;table&#39; int [1:2, 1:3, 1:2] 19 6 7 5 6 16 10 7 0 2 ... ## tib_Arthritis : tibble [84 × 5] (S3: tbl_df/tbl/data.frame) ## tre_per_tre_logica : logi [1:3, 1:3] TRUE TRUE FALSE TRUE TRUE FALSE ... ## una_matrice : num [1:2, 1:3] 1.1 2.1 1.2 2.2 1.3 2.3 ## una_nuova_matrice : num [1:2, 1:3] 1.11 2.12 1.23 2.21 1.32 2.33 ## uso_apply : &#39;difftime&#39; num 0.0037989616394043 ## vettori_concatenati : num [1:6] 1 2 3 1 2 3 ## virgolettato : chr [1:3] &quot;&#39;A&#39;&quot; &quot;&#39;B&#39;&quot; &quot;&#39;C&#39;&quot; ## virgolettato_doppio : chr [1:3] &quot;\\&quot;A\\&quot;&quot; &quot;\\&quot;B\\&quot;&quot; &quot;\\&quot;C\\&quot;&quot; # o finisce per &quot;i&quot;, ls.str(pattern=&quot;i$&quot;) ## array_senza_nomi : num [1:3, 1:3, 1:2] 1 1 1 1 1 1 2 2 2 2 ... ## dimmi_di_si : chr [1:3, 1:3] &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; ## due_elementi : Named num [1:2] 1 3 ## due_vettori : chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## espliciti : &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ anno : num 1999 2000 2001 2002 ## $ vendite: num 100 NA 101 102 ## i : int 8 ## i_miei_anni : Time-Series [1:50] from 1960 to 2009: 1 2 3 4 5 6 7 8 9 10 ... ## i_miei_giorni : Time-Series [1:28] from 12.1 to 16: 1 2 3 4 5 6 7 7 6 5 ... ## i_miei_mesi : Time-Series [1:100] from 1960 to 1968: 1 2 3 4 5 6 7 8 9 10 ... ## i_miei_oggetti : chr [1:106] &quot;a&quot; &quot;a_capo&quot; &quot;AirPassengers&quot; &quot;array_per_colonne&quot; ... ## i_nomi : chr [1:2] &quot;ID&quot; &quot;Age&quot; ## impliciti : &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ anno : num 1999 2001 2002 ## $ vendite: num 100 101 102 ## la_mia_prima_lista_con_nomi : List of 5 ## $ a: num [1:3] 1 2 3 ## $ b: chr [1:9] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;1&quot; ... ## $ c: chr [1:12] &quot;amore&quot; &quot;pace&quot; &quot;amore&quot; &quot;pace&quot; ... ## $ d: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## $ e:List of 4 ## n_casi : num 10000 ## oggi : POSIXct[1:1], format: &quot;2023-11-25 08:18:09&quot; ## quattro_elementi : chr [1:4] &quot;1&quot; &quot;2&quot; &quot;1&quot; &quot;d&quot; ## tempi : &#39;difftime&#39; Named num [1:4] 0.00333189964294434 0.00661516189575195 0.0037989616394043 0.00310111045837402 ## tre_per_sei : &#39;data.frame&#39;: 3 obs. of 6 variables: ## $ D: int 1 2 3 ## $ E: int 4 5 6 ## $ F: int 7 8 9 ## $ D: int 1 2 3 ## $ E: int 4 5 6 ## $ F: int 7 8 9 ## tre_selezioni : logi [1:3] TRUE FALSE TRUE ## vettore_con_nomi : Named num [1:3] 1 2 3 ## vettori_concatenati : num [1:6] 1 2 3 1 2 3 # o inizia con &quot;per&quot; ls.str(pattern=&quot;^per&quot;) ## per_colonne : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## per_colonne_sbagliato : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## per_colonne_sbagliato_2 : int [1:3, 1:3] 1 2 3 4 5 6 7 8 1 ## per_righe : int [1:3, 1:3] 1 4 7 2 5 8 3 6 9 # contains &quot;tre&quot; 1 o più volte ls.str(pattern=&quot;tre+&quot;) ## maggiore_di_tre : logi [1:3, 1:3] FALSE FALSE FALSE TRUE TRUE TRUE ... ## sei_per_tre : &#39;data.frame&#39;: 6 obs. of 3 variables: ## $ D: int 1 2 3 1 2 3 ## $ E: int 4 5 6 4 5 6 ## $ F: int 7 8 9 7 8 9 ## tre_per_sei : &#39;data.frame&#39;: 3 obs. of 6 variables: ## $ D: int 1 2 3 ## $ E: int 4 5 6 ## $ F: int 7 8 9 ## $ D: int 1 2 3 ## $ E: int 4 5 6 ## $ F: int 7 8 9 ## tre_per_tre : &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ D: int 1 2 3 ## $ E: int 4 5 6 ## $ F: int 7 8 9 ## tre_per_tre_logica : logi [1:3, 1:3] TRUE TRUE FALSE TRUE TRUE FALSE ... ## tre_selezioni : logi [1:3] TRUE FALSE TRUE Per fare un po’ di pulizia è possibile usare la funzione rm(). rm() prende come argomento i nomi degli oggetti da rimuovere come nomi (senza virgolette), come vettori di caratteri o come lista (per esempio generata da ls()). Prova nella console questi comandi: copia_Arthritis &lt;- Arthritis rm(Arthritis) # salvo l&#39;abiente come immagine (vedi capitolo 5) save.image(file = &quot;lambiente.Rdata&quot;) # gli oggetti che iniziano con la A rm(ls(pattern = &quot;^A&quot;)) # tutti gli oggetti rm(list = ls()) # ricarico tutto load(file = &quot;lambiente.Rdata&quot;) 4.13 Altre risorse. Riporto, per comodità (tua), risorse già citate in altri capitoli. 4.13.1 Risorse in italiano. Documenti e pagine web. Questa wiki di Agnese Vardanega mi pare la cosa migliore. 4.13.2 Risorse in inglese. Documenti e pagine web. Riporto qui alcuni libri disponibili online nei quali potrai trovare capitoli rilevanti per il contenuto di questo capitolo: Libri: provate questi (il secondo è per utenti avanzati) R for data science: libro assolutamente fondamentale per introdurvi all’analisi dei dati (non necessariamente alla statistica) con R; disponibile on line gratuitamente ma anche come formato cartaceo e epub. Ne esiste anche una traduzione italiana, disponibile qui Advanced R probabilmente la bibbia della programmazione con R, solo per avanzati Hands-on programming with R: anche questo un buon libro sulla programmazione in R, più semplice del precedente. R programming for data science: anche questo bel libro dedicato alla programmazione, corredato da video efficaci documenti e siti web: Quick-R: guida di riferimento rapido a strutture di dati e funzione di base Cookbook for R: un pochino disordinato, ma utile che c’è di male, è quello che faccio io, fra le varie cose↩︎ la terminologia utilizzata per descrivere i caratteri soggetti a variabilità varia molto da un ambito disciplinare all’altro. Se volete utilizzare la terminologia inglese e leggere un’interessante discussione sulle variabili e sulla variabilità in biologia leggete qui↩︎ si tratta di misure in centimetri, riportate con una sola cifra significativa dopo il separatore decimale; la scelta potrebbe essere dovuta sia a limitazioni dello strumento usato per la misura (per esempio un calibro a nonio, che può apprezzare, al meglio, differenze di 0,05 cm) sia a considerazioni di ripetibilità della singola misura. E’ da notare che per queste misure non sono, ovviamente, possibili valori negativi.↩︎ nelle variabili per scala di rapporti la posizione dello 0 non è arbitraria e quindi ha senso usare confronti basati sia sulle differenze che sui rapporti: 4 cm è il doppio di 2 cm, e così via; di conseguenza è possibile per esempio usare statistiche basate sui rapporti, come il coefficiente di variazione↩︎ questo non è sempre vero; in molti casi, specialmente nella statistica multivariata le tabelle, quando composte da un unico tipo di dati, possono essere trasposte, scambiando righe con colonne↩︎ è importante il corretto uso di maiuscole e minuscole, come vedrai dopo R è un linguaggio “case sensitive”. Arthritis e ‘arthritis’ non sono la stessa cosa…↩︎ e probabilmente con un sistema chiamato a doppio cieco, in cui né chi rileva lo stato del paziente né il paziente sanno a che gruppo il paziente appartiene↩︎ in R, un fattore ordinato; i tre livelli (None, nessun miglioramento; Some: qualche miglioramento; Marked: evidenti miglioramenti) hanno un ordine. Tuttavia non è possibile usare una scala continua, ma solo una scala per ranghi: Marked è certamente “migliore” di Some etc.↩︎ questa notazione indica che mpg appartiene alla libreria ggplot2, che a sua volta appartiene al gruppo di pacchetti del tidyverse↩︎ mentre una tabella è un oggetto matrix-like, simile ad una matrice, un array può avere 3 o più dimensioni↩︎ in un database relazionale diverse tabelle sono collegate da “relazioni”: per esempio la tabella flights è collegata alla tabella airlines tramite l’abbreviazione a due lettere carrier, che compare in entrambe le tabelle: è una cosiddetta variablile chiava (key variable), che può essere usata per unire i dati delle due tabelle in un’unica tabella.↩︎ incidentalmente la temperatura, in questo caso in gradi °F, è un esempio di variabile continua per scala ad intervallo, nella quale la posizione dello 0 è arbitraria ed è possibile fare confronti per sottrazione ma non per rapporti: un oggetto a 212°F non è due volte più caldo di un oggetto a 106°F. Diverso è il caso della scala °K, che è una variabile continua per scala di rapporti, perché la posizione dello 0 non è arbitraria.↩︎ ed è, incidentalmente, la ragione per cui R, con le sue potenti capacità di data wrangling, è probabilmente il miglior linguaggio per la data science. Come potrai facilmente constatare in brevissimo tempo, ci sono molti e fantasiosissimi modi di produrre tabelle sostanzialmente inutilizzabili per l’analisi dei dati.↩︎ quelli mancanti in modo esplicito, vedi dopo↩︎ con un numero di repliche diverso di repliche per ciascun trattamento↩︎ anche se alcune operazioni di riarrangiamento dei dati, come il passagio da tabelle in formato “largo” o “wide” a tabelle in formato “lungo” o “long” potrebbe evidenziare il problema, vedi più avanti in questo libro↩︎ può sembrare banale in una tabella piccola, ma immaginate di avere tabelle di milioni di osservazioni↩︎ prova a leggere questa vignette ↩︎ not a number, può essere generato da operazioni come sqrt(-2)↩︎ se vuoi sapere di più paradigma della programmazione orientata ad oggetti, che è supportata da linguaggi molto popolari come C++, Python e Java, leggi questo articolo su Wikipedia o puoi studiare il libro Advanced R↩︎ che è una parafrasi di “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.” — John Chambers; anche le funzioni sono oggetti!↩︎ in realtà è possibile violare queste limitazioni mettendo i nomi “proibiti” o meglio, non sintattici, fra virgolette singole↩︎ esistono anche i tipi complex e raw↩︎ in realtà NA ha come tipo logical, provare per credere; per creare specificamente valori mancanti a carattere o numerici occorre usare NA_character_ o, per i numerici, NA_real_ o NA_integer_↩︎ più avanti vedrai che esiste un comando generico, vector() che permette di produrre un vettore di una data lunghezza e tipo↩︎ lo vedrai quando parlerò di importazione di dati: non è sempre ovvio in che modo una colonna di dati verrà importata↩︎ è importante capire che alcune funzioni restituiscono sempre un data frame, e non una matrice e che non sempre le funzioni che richiedono matrici come input accettano data frame assimilabili o trasformabili in matrici: per questo è necessario leggere bene la sezione value dell’aiuto di una funzione↩︎ se tutti i data frame fossero tibble il mondo sarebbe più ordinato, tidy, e semplice; per quanto pigr* ti imbatterai presto nei tanti difettucci dei data frame. Se vuoi saperne di più su alcune proprietà speciali delle tibble, clicca qui ↩︎ nota che se il tuo sistema operativo è vecchiotto potresti dover installare R 3.2!↩︎ mandare un data frame di 1.000.000 di righe in stampa in console può essere piuttosto dispersivo↩︎ in realtà sono liste con classi particolari, che ne determinano il modo di stampa↩︎ il pacchetto lubridate fornisce molte funzioni convenienti e facili da ricordare per questo tipo di oggetti↩︎ dei singoli elementi in vettori con una dimensione o liste, delle righe o delle colonne o degli strati in elementi in 2 o più dimensioni↩︎ non funziona con i vettori atomici, come matrici e array↩︎ nota che in RStudio, quando si scrive nella console o in uno script, appariranno suggerimenti man mano che si scrive; per prova a scrivere Arthritis$: vedrai che apparirà una lista delle variabili del data frame, che si restringerà man mano che si scrivono altri caratteri, o nella quale si può navigare con i trasti freccia e accettare con tab, o invio)↩︎ altrimenti restituisce NULL↩︎ in effetti si chiamano “infix functions”; puoi verificare facilmente che +(1,2) funziona (e domandarti perché ho dovuto usare quel particolare tipo di virgolette intorno al +)!↩︎ "],["dentroefuoriR.html", "5 Dentro e fuori R 5.1 Cosa c’è da imparare in questo capitolo. 5.2 Ogni cosa al suo posto: working directory, progetti, etc. 5.3 Facciamola semplice: il menu Import Dataset. 5.4 Gestire file di testo con readr. 5.5 Tutti i comandi (o quasi) per importare file di testo… 5.6 Altri formati di dati. 5.7 Lavorare con i nomi dei file e le directory. 5.8 Appendice 1. Un piccolo dettaglio sulla sintassi. 5.9 Appendice 2. Se sei arrivat* fin qui… 5.10 Altre risorse.", " 5 Dentro e fuori R v1.2.1 3/11/2023 5.1 Cosa c’è da imparare in questo capitolo. Aprire, salvare e condividere file di dati è una necessità costante per chi si occupa di statistica e analisi dei dati. Le tabelle di dati possono essere salvate in una varietà di formati, alcuni gestibili da tutti i software (file di testo, a spaziatura fissa o delimitati, come i file .dat, .txt, .tab, .tsv, .csv)103 e altri proprietari (.xlsx, .numbers, etc., ma anche fogli di calcolo on line come Google Fogli). Nella tua vita precedente ti sei abituat* a usare le funzioni e i menu del sistema operativo del tuo computer o del tuo programma preferito per fogli di calcolo per navigare nel file system, creare, aprire e chiudere cartelle, cercare, aprire e salvare file. Per quanto tu possa sfruttare molte delle funzioni di RStudio per fare praticamente le stesse cose (vedi dopo), se hai deciso di fare lo sforzo di leggere questo libro è per fare qualcosa di più e, soprattutto per poterlo fare in maniera riproducibile e, se possibile, automatizzata. Come al solito, sei liber* di scegliere il tuo percorso. Se non hai tempo, o voglia, leggi solo le prime tre sezioni (5.2; 5.3; 5.4) e lascia il resto per dopo. Nei capitoli successivi troverai diversi esempi di comandi per leggere e salvare file di testo. Se sei interessat* ad operazioni più complesse, leggi anche le Appendici 5.8 e 5.9. 5.2 Ogni cosa al suo posto: working directory, progetti, etc. Quando inizi una sessione di R (aprendo direttamente R o aprendo RStudio), il software sceglie automaticamente una cartella di lavoro (working directory), che diventerà il luogo in cui verranno cercati o salvati i file, a meno che tu non fornisca indicazioni diverse. Di default la tua working directory è la tua home come utente104. Per conoscere quale è la tua working directory scrivi nella console105: &gt;getwd() Nel mio caso (uso un progetto, vedi dopo), il risultato è: &gt;&quot;/Users/eugenio/pigR&quot; Quindi, la cartella su cui sto lavorando è pigR, che è contenuta nella mia home, eugenio, che a sua volta è contenuta nella cartella Users del mio file system. Io uso MacOS, quindi il delimitatore è /, mentre nei sistemi Windows è \\. Puoi cambiare la working directory con il comando setwd(). Guarda cosa succede usando questi comandi: copiali e incollali in uno script vuoto o scrivili nella console (ho già omesso il prompt) ed eseguili per vedere l’effetto che fa: # stampo a console la wd e attribuisco il nome lamiawd all&#39;oggetto restituito # dalla funzione getwd() lamiawd &lt;- getwd() # che tipo di oggetto è? # cambio la wd. Il comando non è specifico per il mio sistema, perché .. indica la # cartella che contiene la cartella su cui sto lavorando setwd(&quot;..&quot;) getwd() # riporto al wd a quella originale setwd(lamiawd) Ovviamente, puoi anche fare le stesse operazioni usando i menu di R studio (figura 5.1), che ti consentono di scegliere la working directory usando dei semplici menu interattivi. Figura 5.1: Scegliere la working directory da menu. Mentre quando si lavora in modo interattivo è abbastanza facile fare queste operazioni, quando si lavora con uno script, un documento interattivo o un rapporto R Markdown (vedi capitoli successivi) questo non è possibile. Inoltre, diventa laboriosissimo indicare con chiarezza dove si è lavorato o riprodurre il flusso di analisi o, peggio ancora, farlo riprodurre a qualcun altro. Fortunatamente, RStudio mette a disposizione un sistema molto più efficiente: la creazione di progetti. Un progetto è fondamentalmente una cartella in cui è contenuto tutto il materiale (script, file di dati, file di immagini, storia, etc.) per un determinato progetto di lavoro. RStudio si occupa di creare tutta una serie di cartelle e file nascosti che, quando riapriamo un progetto, ci permette di riprendere esattamente dal punto dove avevamo lasciato (specialmente se ci ricordiamo di salvare l’ambiente di lavoro quando usciamo da R). Basta trasferire l’intera cartella a qualcun altro perché all’apertura del progetto tutto ritorni esattamente nello stato in cui lo hai lasciato tu. Geniale!!!! Ci sono 3 modi diversi di creare un progetto: usando il menu in alto a destra in RStudio (vedi figura 5.2) usando l’icona di accesso rapido in alto a sinistra (un piccolo cubo con la lettera R e un + bianco in campo verde) usando il menu File -&gt; New project Il progetto può essere creato in una cartella (directory) esistente o in una nuova cartella106. Figura 5.2: Il menu progetti. Una volta creato un progetto, il suo nome comparirà sotto la voce File -&gt; Open Recent Projects e nel menu progetti (figura 5.2). E’ anche possibile aprire un progetto semplicemente con un doppio click. 5.3 Facciamola semplice: il menu Import Dataset. Come ho già detto da qualche parte, se sei fortunat* lavorerai prevalentemente con tabelle di dati, create da te con un programma di foglio di calcolo e potrai salvarle sia in formato testo (sai farlo, vero?) che nel formato proprietario della app che stai usando (o in formato MS Excel, magari creato usando Fogli di Google, o Numbers, o chissà che). In questo caso, dovresti sapere come è fatto il tuo file e non dovresti avere troppi problemi a importarlo, perché sicuramente avrai seguito i miei consigli sulla struttura delle tabelle (4.1.3) e sui nomi delle variabili (4.3). In altri casi potresti trovarti ad aprire file di cui non conosci la struttura, non sai se contengono o meno righe di commento, come sono indicati i missing data, etc. Fortunatamente per te, RStudio mette a disposizione nel pannello dell’ambiente un po’ di menu semplici e diretti per aprire file in formato .RData o in formato testo o Excel. Proviamo subito con un semplice esercizio. Per sicurezza esporterai prima un dataset di R in diversi formati (è semplice, basta seguire le istruzioni) e poi lo importerai in maniera interattiva. Crea un progetto in una cartella esistente o in una nuova cartella107 Crea un nuovo script con File-&gt;New-&gt;R Script Copia e incolla questo codice (dovresti già aver installato i pacchetti necessari nei capitoli precedenti, altrimenti segui le istruzioni presentate nel Paragrafo 2.2.10) library(tidyverse) library (readxl) library(vcd) library(openxlsx) data(&quot;Arthritis&quot;) # salva un file delimitato da , con . come separatore decimale write_csv(Arthritis, file = &quot;Arthritis_comma.csv&quot;) # salva un file delimitato da ; con . come separatore decimale write_csv2(Arthritis, file = &quot;Arthritis_semicolon.csv&quot;) # salva un file delimitato da tabulazioni con . come separatore decimale write_tsv(Arthritis, file = &quot;Arthritis_tab.txt&quot;) # salva un file .xlsx write.xlsx(Arthritis, file = &quot;Arthritis.xlsx&quot;) Ora fai girare lo script seguendo uno dei metodi descritti nel Capitolo 2. Come risultato, i file che hai salvato dovrebbero apparire nella tua working directory. Useremo questi file per provare a importare i dati con la funzionalità ‘Import Dataset’ di RStudio. E’ possibile anche aprire lo stesso menu da File-&gt;Import Dataset. Ora proviamo a importare uno qualsiasi dei file. Nell’esempio successivo userò Arthritis_semicolon.csv, ma tu puoi sceglierne un altro, ovviamente scegliendo di conseguenza le opzioni migliori. Nelle Figure 5.3 e 5.4 sono illustrati i passaggi da seguire. Figura 5.3: Aprire il menu Import Dataset. Prima di tutto seleziona Import Dataset -&gt; From Text (readr). readr è uno dei pacchetti dei tidyverse ed è ottimizzato per aprire e salvare in modo veloce ed efficiente file di testo. La finestra che otterrai è mostrata nella figura 5.4. puoi scegliere il file che vuoi aprire navigando fra le cartelle con il tasto 108. Successivamente, selezionando le opzioni dei campi, dei checkbox e dei menu a tendina, sarà possibile impportare correttamente il file. Figura 5.4: Importare file di testo. Le funzioni dei campi, checkbox e menu dovrebbero essere abbastanza intuitive. Ad ogni modo: Name consente di assegnare un nome all’oggetto importato Skip consente di selezionare il numero di righe da scartare all’inizio del file: alcuni file di testo contengono commenti seguiti poi dai dati FirstRow as Names indica, se selezionato, che la prima riga contiene i nomi delle variabili (di solito è così; in alternativa R userà dei nomi di default) Trim spaces se selezionato eliminerà eventuali spazi vuoti prima o dopo il contenuto delle celle Open data viewer, se selezionato, aprirà la tabella nel Viewer dopo l’importazione Delimiter consente di scegliere il delimitatore delle colonne: se non siete certi provate e vedrete come il contenuto si distribuisce in colonne con le diverse opzioni Quotes permette di determinare come vengono trattate le virgolette contenute nei campi Locale consente di selezionare le opzioni che determineranno lingua, sistemi di data, delimitatore decimale etc.109 Escape consente di scegliere il carattere di escape, che serve per importare correttamente caratteri speciali, come / Comment consente di scegliere il carattere che precede i commenti NA consente di scegliere il modo in cui sono codificati, nel file di importazione, i missing data; anche qui, potete fare un po’ di prove e vedere che succede, magari usando la barra di scorrimento verticale per dare un’occhiata. I comandi corrispondenti a queste azioni sono generati in automatico e possono essere copiati ed incollati in uno script (per rendere riproducibile l’azione). library(readr) Arthritis_semicolon &lt;- read_delim(&quot;Arthritis_semicolon.csv&quot;, delim = &quot;;&quot;, escape_double = FALSE, trim_ws = TRUE) View(Arthritis_semicolon) Se non lo si indica specificamente con un’opzione110, readr determina automaticamente il tipo delle colonne dalle prime 1.000 osservazioni. In realtà le opzioni di readr sono molto più numerose e forniscono un’enorme flessibilità nell’importazione dei dati. Le funzioni di readr sono in genere superiori alle corrispondenti funzioni di R base (vedi qui il perché). Tuttavia, è importante ricordare che le funzioni di readr creano o usano tibbles e le tibbles non hanno, fra le altre cose, nomi di riga. Sono quindi inadatte ad alcune strutture di dati, come le matrici e gli array o i data frame con nomi di riga, che possono essere utili in diverse situazioni. Lo stesso menu Import Dataset permette di importare molti altri tipi di file e di usare, se preferite, le funzioni di base. Sentitevi liberi di sperimentare, magari con i file che avete appena creato. 5.4 Gestire file di testo con readr. Lavorare in maniera interattiva con il menu Import Dataset va bene finché non devi automatizzare il tuo flusso di lavoro o condividerlo con altri. In questo caso, devi abituarti a usare i comandi generati da questo menu in maniera programmatica111. Rispetto alle funzioni di base è veloce ed efficiente e può leggere direttamente file da posizioni sul web. Prova a scrivere nella console: study_metadata &lt;- read_tsv(&quot;https://tinyurl.com/34u6a9md&quot;) Il comando importa la tabella presente all’indirizzo indicato e assegna l’oggetto112 al nome study_metadata. E’ addirittura possibile decomprimere e aprire file compressi. readr offre una serie di comandi per importare file di testo delimitati in tibble e per salvare tibble come file di testo (tabella 5.1) Tabella 5.1: Comandi per importare e esportare file di testo con readr. Delimitatore per importare per esportare Commenti qualsiasi read_delim() write_delim() richiedono più configurazione tabulazione read_tsv() write_tsv() legge sia .tsv che .txt virgola read_csv() write_csv() è quello più comune punto e virgola read_cvs2() write_csv2() Tieni presente che la , è usata nei paesi che usano come delimitatore decimale il punto e il ; è usato nei paesi che usano come delimitatore decimale la virgola. Questi sono i comandi più comuni. I comandi di importazione hanno la struttura: il_mio_oggetto &lt;- read_delim(file, ...) dove ... sono le opzioni (leggi l’aiuto delle funzioni!). Come hai visto file può essere un percorso di file113 o anche una URL. Il risultato è una tibble114. Aprire file da una URL può essere particolarmente utile se lavori con una versione cloud di R]. I comandi per l’esportazione hanno la struttura: write_delim(il_mio_oggetto, file, ...) Fra le altre cose, offrono l’opzione append che, con append = T, permette di aggiungere dati alla fine di un file invece di sovrascriverlo. readr può importare e esportare file molto grandi (e mostrare una barra di avanzamento mentre lo fa), ma gli oggetti importati non possono eccedere il limite di RAM utilizzabile (vedi dopo per qualche alternativa). Infine, readr può importare file delimitati da spazi (read_table) o con campi di larghezza fissa (read_fwf) e molte altre cose. Vedi le pagine di aiuto o vai al sito di readr per saperne di più. 5.5 Tutti i comandi (o quasi) per importare file di testo… Esistono molti modi di pelare un gatto e con R, l’importazione e l’esportazione di file di testo possono essere ottenute con diversi pacchetti. La tabella successiva ti offre un piccolo confronto. Tabella 5.2: Comandi per importare e esportare file di testo in R. Delimitatore base/ultils readr data.table qualsiasi read.table() read_delim() fread() write.table() write_delim() tabulazione read.delim() read_tsv() write.delim() write_tsv() | virgola read.csv() read_csv() write.csv() write_csv() punto e virgola read.cvs2() read_csv2() write.csv2() write_csv2() L’uso del . invece di _ non è la sola differenza dei comandi base e quelli di readr. I comandi base: possono solo leggere da file creano data frame (e quindi conservano i nomi di riga) possono salvare sia matrici che data frame hanno dei default un pochino meno intuitivi Per esempio, read.csv2() assume, contemporaneamente, che il separatore sia il punto e virgola e che il delimitatore decimale sia il la virgola. Leggi l’aiuto dei singoli comandi per saperne di più. data.table::fread() è una funzione molto potente e veloce per l’importazione di file di testo da file o da URL. Esistono molti confronti fra questa funzione e quelle di R e base e readr: prova a cercare da sol* con Google. Come ultima cosa: in R è possibile aprire “connessioni” con file o URL per leggere o scrivere dati con vari sistemi. Questo argomento è un po’ oltre gli obiettivi di questo corso; consulta la Sezione 5.10 per saperne di più. 5.6 Altri formati di dati. Se collabori con altri analisti e ricercatori ti potrebbe capitare di dover importare ed esportare in altri formati. A parte formati specialistici (come i formati utilizzati per i network, gml, o quelli usati per gli alberi filogenetici), che sono gestiti da pacchetti specifici, è abbastanza frequente importare ed esportare dati in un formato leggibile da Microsoft Excel115 o formati specifici per altri software statistici (SPSS, SAS, Stata, Systat). A parte questo, R ha un’incredibile quantità di pacchetti e funzioni per importare dati da database in diversi formati e per ottenere dati da social media e dal web. Vedi nella Sezione 5.10 per qualche suggerimento specifico. 5.6.1 Da e per Excel. Il modo forse più efficiente e coerente con il tidyverse per importare tabelle da Excel è usare le funzioni read_excel() (giudica il formato dall’estensione), read_xls() o read_xlsx() (leggono i file del formato corrispondente) di readxl. Quest’ultimo è un pacchetto del tidyverse che non viene caricato esplicitamente con library(tidyverse) e va quindi installato e caricato a parte. Se hai salvato Arthritis in formato .xlsx prova a eseguire questi comandi116: &gt;arthritis_xlsx &lt;- read_excel(&quot;Arthritis.xlsx&quot;) &gt;arthritis_xlsx Come vedi, i comandi del tidyverse hanno bisogno di pochissima configurazione e producono delle tibble. Curiosamente, readxl non ha funzioni per esportare i dati in Excel: readr offre due funzioni, write_excel_csv() e write_excel_csv2() che permettono di produrre file .csv più compatibili con Excel (che in realtà può importare facilmente file di testo, ma è sicuramente preferibile farlo da menu). Il pacchetto openxlsx offre funzioni che permettono, in maniera più articolata di importare117 ed esportare file in formati .xls e .xlsx. Prevedibilmente, i nomi di questi funzioni sono read.xlsx() e write.xlsx(). Le opzioni di questi comandi sono piuttosto articolati. Prova a leggerne l’aiuto. Se non ricordi come, vai al Capitolo 3. 5.6.2 Altri formati: foreign e Hmisc e haven. I pacchetti foreign, Hmisc e haven forniscono vari comandi per importare file di dati da altri software di analisi statistica. La Tabella 5.3 mostra alcuni esempi. Tabella 5.3: Comandi per importare e esportare file di testo in R. Software foreign Hmisc haven STATA read.dta() read_dta() SPSS read.spss() spss.get() read_sav() Systat read.systat() SAS read.ssd() sas.get() read_sas() MINITAB read.mtp() Tutti questi comandi restituiscono data frame. foreign fornisce solo alcuni comandi per l’esportazione. Fai riferimento all’aiuto per la sintassi e le opzioni. Le funzioni di Hmisc hanno in genere default più semplici. haven è un pacchetto del tidyverse e quindi restituisce tibbles. 5.6.3 Un richiamo: file .Rdata e .rds R ha i propri formati per il salvataggio di file di dati in formati binari, estremamente compatti. Ne ho parlato in precedenza (Capitolo 4). Ecco un piccolo riassunto con esempi: save.image(file = \"ilmiofile.Rdata\"): salva un’immagine dell’ambiente di lavoro, con gli oggetti e i loro nomi save(Arthirtis, Arthritis_semicolon, file = \"imieioggetti.Rdata\"): salva una serie di oggetti (indicati con i loro nomi o come stringhe di caratteri118); gli oggetti vengono salvati con i loro nomi load(file = \"ilmiofile.Rdata\"): carica nell’ambiente di lavoro tutti gli oggetti contenuti nel file Rdata. copompresi i loro nomi saveRDS(Arthirtis, file = \"Arthritis.rds\"): salva un singolo oggetto. L’oggetto salvato può essere ricaricato attribuendogli un altro nome readRDS(file = \"Arthritis.rds\"): legge un singolo oggetto, che di solito viene attribuito a un nome, per esempio arthritis_2 &lt;- readRDS(file = \"Arthritis.rds\") Nota che readr fornisce due versioni alternative a readRDS() e saveRDS(), rispettivamente read_rds() e write_rds()119. 5.6.4 E’ andato tutto bene? Ma come si fa a sapere se l’importazione è andata bene? Se tutte le variabili sono state importate nel formato (numerico, testo, logico, etc.) corretto? Se dati mancanti, commenti o righe vuote iniziali, finali etc. hanno causato problemi? Se ci sono spazi vuoti prima e dopo il testo di una colonna? Se i caratteri speciali sono stati improtati correttamente? Innanzitutto, se non conosci con certezza la struttura della tabella che vuoi importare (magari semplicemente perché la ha creata qualcun altro) è sempre una buona idea dare una sbirciatina usando un programma di lettura di semplici file di testo (come Textedit in MacOS) Per tabelle molto piccole (&lt;1000 righe, qualche decina di colonne) è abbastanza facile aprire la tabella nel Viewer120 dopo l’importazione. Per tabelle più grandi ci sono varie strategie (e stampare la tabella in console non è una di quelle): usare il comando pillar::glimpse()121, che fornisce una rappreentazione compatta mostrando i tipi delle variabili e alcune osservazioni; usare il comando summary(), che fornisce alcune statistiche riassuntive sulle colonne (adattandole a seconda del tipo dei dati nella colonna) fare qualche elaborazione grafica (vedi Capitolo 6) Prova tu stess* scrivendo nella console i seguenti comandi e confrontandone l’output (ricorda che Arthritis è un data frame): &gt;View(Arthritis) &gt;Arthritis &gt;class(Arthritis) &gt;Arthritis_2 &lt;- as_tibble(Arthritis) &gt;Arthritis_2 &gt;glimpse(Arthritis_2) &gt;summary(Arthritis) 5.7 Lavorare con i nomi dei file e le directory. Capire l’uso dei percorsi per file e cartelle in R non è facile se sei abituat* a gestire questi compiti nelle interfacce grafiche del tuo sistema operativo. RStudio ti offre diverse opzioni per usare interfacce semplici e immediate (vedi sopra e vedi Capitolo 2). Anche se imparare a usare i percorsi dei file non è necessario se vuoi lavorare in modo interattivo, è essenziale sia per ottenere analisi riproducibili e generalizzabili (riutilizzabile con altri tipi di file dello stesso tipo) e per lavorare con i report di RMarkdown122. Nell’esempio successivo troverai un certo numero di comandi utili a gestire file e cartelle in maniera programmatica. Prova a usare questi comandi sul tuo sistema e nota le differenze nell’output. Se sei arrivat* fino a qui non sei del tutto pigr* e quindi dovresti fare, prima o poi, uno sforzo per leggere l’aiuto di questi comandi per sfruttarli al meglio. Prima di tutto, i percorsi di file e directory sono specifici per ogni piattaforma; prova questo: getwd() ## [1] &quot;/Users/eugenio/Library/CloudStorage/Dropbox/appunti e varie pigR/pigR_bookdown&quot; Come sono separati i nomi delle cartelle nel percorso? Con / (caratteristico dei sistemi Unix) o \\ (caratteristico dei sistemi Windows e usato come carattere escape in R)? L’uso di delimitatori diversi per i percorsi pone un problema: quando apri e salvi i file devi definire i percorsi. Ammettiamo che tu voglia preparare un esempio con una cartella contenente uno script e alcuni file: se tu definissi i percorsi, anche relativi (alla cartella di lavoro, vedi sopra), sul tuo sistema, lo script non funzionerebbe necessariamente in un altro sistema operativo. Un modo per definire i percorsi indipendente dalla piattaforma è file.path(). In questo comando gli elementi del percorso (a loro volta singole cartelle o gruppi di cartelle) sono separati da “,”. Prova ad eseguire il comando descritto nell’esempio successivo sul tuo sistema e osserva cosa succede. mypath &lt;- file.path(getwd(), &quot;DataL3&quot;) mypath ## [1] &quot;/Users/eugenio/Library/CloudStorage/Dropbox/appunti e varie pigR/pigR_bookdown/DataL3&quot; E’ particolarmente utile ottenere una lista dei file e cartelle in una determinata cartella. Il comando relativo è list.files(). Guarda gli esempi successivi e prova ad eseguire gli stessi comandi sul tuo sistema. la_mia_lista_di_file &lt;- list.files(getwd()) str(la_mia_lista_di_file) ## chr [1:23] &quot;_book&quot; &quot;_bookdown_files&quot; &quot;_bookdown.yml&quot; &quot;_main_files&quot; ... # che cos&#39;é? Che tipo di oggetto? Puoi immaginare comandi con cui usarlo? la_mia_lista_di_file ## [1] &quot;_book&quot; ## [2] &quot;_bookdown_files&quot; ## [3] &quot;_bookdown.yml&quot; ## [4] &quot;_main_files&quot; ## [5] &quot;_main.Rmd&quot; ## [6] &quot;01--Introduzione.Rmd&quot; ## [7] &quot;02--Interfacce-e-ambienti.Rmd&quot; ## [8] &quot;03--Chiedere-aiuto.Rmd&quot; ## [9] &quot;04--Dati_oggetti_funzioni_linguaggio.Rmd&quot; ## [10] &quot;05--Dentro_e_fuori.Rmd&quot; ## [11] &quot;06--Grafica.Rmd&quot; ## [12] &quot;07--Descrivere-con-i-numeri.Rmd&quot; ## [13] &quot;08--Creare_report.Rmd&quot; ## [14] &quot;09--Lottare_con_i_dati.Rmd&quot; ## [15] &quot;10--Credits.Rmd&quot; ## [16] &quot;images&quot; ## [17] &quot;index.Rmd&quot; ## [18] &quot;lavori&quot; ## [19] &quot;pigR_bookdown.Rproj&quot; ## [20] &quot;pigR_epub_book&quot; ## [21] &quot;pigR_gitbook&quot; ## [22] &quot;pigR_reviewer&quot; ## [23] &quot;renderepub.R&quot; # ora uso . per accedere gerarchicamente i livelli del file system # nella cartella di lavoro list.files(&quot;.&quot;) ## [1] &quot;_book&quot; ## [2] &quot;_bookdown_files&quot; ## [3] &quot;_bookdown.yml&quot; ## [4] &quot;_main_files&quot; ## [5] &quot;_main.Rmd&quot; ## [6] &quot;01--Introduzione.Rmd&quot; ## [7] &quot;02--Interfacce-e-ambienti.Rmd&quot; ## [8] &quot;03--Chiedere-aiuto.Rmd&quot; ## [9] &quot;04--Dati_oggetti_funzioni_linguaggio.Rmd&quot; ## [10] &quot;05--Dentro_e_fuori.Rmd&quot; ## [11] &quot;06--Grafica.Rmd&quot; ## [12] &quot;07--Descrivere-con-i-numeri.Rmd&quot; ## [13] &quot;08--Creare_report.Rmd&quot; ## [14] &quot;09--Lottare_con_i_dati.Rmd&quot; ## [15] &quot;10--Credits.Rmd&quot; ## [16] &quot;images&quot; ## [17] &quot;index.Rmd&quot; ## [18] &quot;lavori&quot; ## [19] &quot;pigR_bookdown.Rproj&quot; ## [20] &quot;pigR_epub_book&quot; ## [21] &quot;pigR_gitbook&quot; ## [22] &quot;pigR_reviewer&quot; ## [23] &quot;renderepub.R&quot; # un livello superiore list.files(&quot;..&quot;) ## [1] &quot;bookdown-demo-main&quot; ## [2] &quot;BUP-Scheda_Autore_pigR.docx&quot; ## [3] &quot;BUP-Scheda_Autore.docx&quot; ## [4] &quot;capitolo_2_le_GUI.docx&quot; ## [5] &quot;Capitolo_3_aiutoR.docx&quot; ## [6] &quot;capitolo_4_elementi_base_linguaggio.docx&quot; ## [7] &quot;da_spostare_in_pigR_bookdown&quot; ## [8] &quot;Errori battitura.docx&quot; ## [9] &quot;immagini_dim_originali&quot; ## [10] &quot;Indice pigR.docx&quot; ## [11] &quot;notabene.rtf&quot; ## [12] &quot;pexels-mark-stebnicki-2252541 small.jpeg&quot; ## [13] &quot;pexels-mark-stebnicki-2252541_300.jpg&quot; ## [14] &quot;pexels-mark-stebnicki-2252541.jpg&quot; ## [15] &quot;pigR_bookdown&quot; ## [16] &quot;pigR_note.docx&quot; ## [17] &quot;pigR_Rmd&quot; ## [18] &quot;Proposta di pubblicazione, tempi rapidi.rtf&quot; ## [19] &quot;PROPOSTA EDITORIALE HOEPLI.pdf&quot; ## [20] &quot;Re_ proposta editoriale per BUP.rtf&quot; ## [21] &quot;screenshotsRstudio&quot; Prova ad eseguire il comando successivo dalla console: &gt; list.files(&quot;.&quot;, recursive = T) Cosa succede? Prova ad attribuire il risultato di questo comando ad un nome. Che oggetto è? Che usi potresti farne? Determinare con esattezza il percorso di un file può essere difficile, specialmente se il file si trova “annidato” molto profondamente nel tuo sistema. A parte le funzionalità del pannello dell’ambiente aprire e salvare file e quelle del pannello File di RStudio per esplorare il tuo file system, un comando interessante è file.choose(), che apre un menu interattivo per la scelta di un file e ne restituisce il percorso. Prova ad eseguire questi comandi nella tua console: &gt; il_nome_del_file &lt;- file.choose() Due comandi interessanti per ottenere, dato un percorso, la directory che contiene il file di interesse e il nome del file sono: &gt; dirname(il_nome_del_file) &gt; basename(il_nome_del_file) Guarda che succede ora. Prova a ricostruire quello che fanno questi comandi usando l’aiuto: head(la_mia_lista_di_file) ## [1] &quot;_book&quot; &quot;_bookdown_files&quot; &quot;_bookdown.yml&quot; ## [4] &quot;_main_files&quot; &quot;_main.Rmd&quot; &quot;01--Introduzione.Rmd&quot; la_mia_wd &lt;- getwd() il_nome_della_mia_wd &lt;- basename(la_mia_wd) # la tilde abbrevia il percorso a una cartella, path.expand() lo espande file.path(&quot;~&quot;,&quot;il_nome_della_mia_wd&quot;) ## [1] &quot;~/il_nome_della_mia_wd&quot; path.expand(file.path(&quot;~&quot;,&quot;il_nome_della_mia_wd&quot;)) ## [1] &quot;/Users/eugenio/il_nome_della_mia_wd&quot; head(list.files(path.expand(file.path(&quot;~&quot;,&quot;il_nome_della_mia_wd&quot;))),5) ## character(0) R fornisce alcuni utili comandi per verificare l’esistenza di cartelle in una determinata posizione o per crearle. Prova a leggere l’aiuto: &gt;?dir.create Prova ad eseguire questo breve esempio: il codice cerca una cartella dal nome “lavori” all’interno della cartella di lavoro e, se non c’è, la crea: la_mia_wd &lt;- getwd() if(!dir.exists(file.path(la_mia_wd,&quot;lavori&quot;))) dir.create(file.path(la_mia_wd,&quot;lavori&quot;)) 5.8 Appendice 1. Un piccolo dettaglio sulla sintassi. Nei capitoli precedenti e in questo hai visto moltissimi comandi/funzioni, ciascuno dei quali può avere da poche a molte opzioni, alcune delle quali hanno dei valori default e altre no. Ovviamente le opzioni che non hanno un default vanno necessariamente fornite (come il percorso di un file in un comando che salva o apre un file). I valori di default, in genere sono abbastanza sensati e vanno cambiati solo se necessario. Curiosamente, i nomi delle opzioni non sono sempre necessari (anche se è meglio scriverli, per rendere più facilmente interpretabile il codice). Questi comandi sono equivalenti: write_tsv(Arthritis, file = &quot;Arthritis.tsv&quot;, append = F) write_tsv(Arthritis, &quot;Arthritis.tsv&quot;) write_tsv(Arthritis, na = &quot;NA&quot;, file = &quot;Arthritis.tsv&quot;) Non è necessario dare un nome ad un’opzione se compare esattamente nella sequenza prevista dal comando. E’ anche possibile indicare le opzioni in disordine, ma in questo caso è necessario usare il nome. 5.9 Appendice 2. Se sei arrivat* fin qui… La ragione principale per imparare a usare R dovrebbe essere quella di risolvere alcuni problemi in maniera efficiente ed automatizzata. Il numero di casi speciali che ti potresti trovare ad affrontare è praticamente infinito. E’ abbastanza comune trovarsi nella situazione di dover importare molti file con la stessa struttura in un unico data frame. L’operazione può essere condotta in maniera interattiva, ma con un elevato rischio di errore e poca riproducibilità. Cerca di capire cosa fa questo piccolo script (usando l’aiuto quando incontri un comando che non conosci) e poi prova ad eseguirlo (ometto il prompt per facilitarti le cose)123: # preparazione, divido Arthritis in k=5 pezzi j = 5 if(j&gt;nrow(Arthritis)) cat(&quot;\\nATTENZIONE: scegli un valore più piccolo per k\\n&quot;) # crea opzionalmente una directory per contenere i file if(!(&quot;kArthritis&quot; %in% list.files(file.path(&quot;.&quot;)))) dir.create(file.path(&quot;.&quot;,&quot;kArthritis&quot;)) # crea un indice per le righe dei pezzi da salvare indice &lt;- sort(gl(j, 1, nrow(Arthritis))) # creo una copia Arthritis_3 &lt;- Arthritis Arthritis_3$indice &lt;- indice # uso un loop (più avanti vedremo come questo può essere sostituito da un functional) per # salvare pezzi separati for (i in seq_along(1:j)){ minidf &lt;- dplyr::filter(Arthritis_3, indice == i) nome_file &lt;- str_c(&quot;Arthritis_&quot;,i,&quot;.tsv&quot;, sep =&quot;&quot;) write_tsv(dplyr::select(minidf, -indice), file = file.path(&quot;.&quot;, &quot;kArthritis&quot;, nome_file)) } # ora uso un loop per rimettere insieme i pezzi, usando i nomi dei file come indice # quanti file di tipo .tsv ci sono? nomi_file &lt;- list.files(file.path(&quot;.&quot;, &quot;kArthritis&quot;)) quali_sono_tsv &lt;- str_detect(nomi_file, &quot;\\\\.tsv&quot;) nomi_file&lt;-nomi_file[quali_sono_tsv] # creo una list vuota della lunghezza giusta lista_file &lt;- vector(&quot;list&quot;, length = length(nomi_file)) # questo loop legge i nomi dei file negli slot della lista for (i in seq_along(nomi_file)){ lista_file[[i]] &lt;- read_tsv(file.path(&quot;.&quot;,&quot;kArthritis&quot;, nomi_file[i])) names(lista_file)[i]&lt;-nomi_file[i] } # trasforma la lista in un data frame (e se si potesse fare con un loop?) # modo n. 1, bruttino Arthritis_frankenstein_brutto &lt;- do.call(rbind, lista_file) # modo n. 2 con map_dfr(), un functional, cioé un comando che applica una funzione a una lista # e restituisce un data frame Arthritis_frankenstein &lt;- map_dfr(lista_file, bind_rows) # senza conservare i nomi dei file Arthritis_frankenstein_nomi &lt;- map_dfr(lista_file, bind_rows, .id = &quot;nomi_file&quot;) # con i nomi dei file # e, per farla ancora più semplice percorsi &lt;- file.path(&quot;.&quot;,&quot;kArthritis&quot;, nomi_file) Arthritis_frankenstein_nomi_2 &lt;- map_dfr(percorsi, read_tsv, .id = &quot;nomi_file&quot;) Perché darsi tutta questa pena a scrivere tante righe di codice per fare una cosa che si poteva fare in modo interattivo? Intanto, si può scrivere codice in modo succinto. E poi, perché magari i file potevano essere 1000…, e anche perché magari ti potresti trovare a fare la stessa cosa cento volte e non la vuoi fare ogni volta in un modo diverso (in fondo, sei pigr*). E anche e soprattutto perché è più stimolante così. Naturalmente, nel mondo reale potevano andare male un sacco di cose e un programmatore prudente dovrebbe tenerne conto creando delle “trappole per gli errori”: se qualcosa non va come previsto, è bene che una funzione o una serie di comandi restituiscano il risultato che rappresenta il miglior compromesso possibile, magari insieme ad un messaggio di errore o warning facile da capire. 5.10 Altre risorse. Il materiale in questo capitolo è presentato in molte delle risorse citate nel Capitolo 4. Qui riporto solo le risorse nuove. 5.10.1 Risorse in inglese. Documenti e pagine web. Riporto qui alcuni libri e documenti disponibili online nei quali potrai trovare capitoli rilevanti per il contenuto di questo capitolo: Libri: provate questi questo capitolo riassume un po’ tutto quello che c’è da sapere sull’importazione (ordinata) di dati come sempre R for data science fornisce esempi ed esercizi interessanti documenti e siti web: questa guida ufficiale del CRAN all’importazione di dati è completa e aggiornata questo è un articolo interessante sul web scraping (come importare contenuti dal web) con R questo è uno dei tanti articoli avanzati per gestire data set molto grandi (e che potrebbero eccedere la RAM) con R. Con poca fatica potete trovare molte risorse simili. Anche questo articolo fornisce alcune soluzioni interessanti. Pacchetti o funzioni più o meno specializzate, come data.table::fread() o le funzioni di bigreadr possono servire per affrontare problemi di importazione veramente grossi. Questa è decisamente la scelta migliore per condividere file con altri.↩︎ è possibile cambiare questo default nelle preferenze di RStudio↩︎ ricordati di omettere il carattere per il prompt, &gt;↩︎ Attenzione a creare progetti in cartelle di Google Drive se usate l’app di Google drive: in qualche caso ci sono problemi di sincronizzazione, specialmente nella gestione di alcuni tipi di documenti dinamici, come i notebook. Dropbox funziona molto meglio↩︎ dovrebbe essere semplice e intuitivo ma, se non riesci, guarda questo video↩︎ o incollare direttamente il percorso del file↩︎ personalmente io preferisco settare l’intero sistema con un locale con punto decimale come US o UK↩︎ in effetti un vettore carattere con i tipi delle diverse colonne↩︎ e magari fare qualche sforzo in più per capire come usare i percorsi dei file↩︎ una tabella scaricata da uno dei miei repository su GitHub↩︎ se usi solo il nome del file con l’estensione appropriata il file verrà cercato nella working directory, vedi nei paragrafi precedenti. Puoi anche specificare un percorso diverso, vedi dopo. file è, in effetti, un vettore carattere di lunghezza 1 e puoi crearlo con una funzione!↩︎ se non la attribuisci ad un oggetto la visualizzi soltanto in console!↩︎ e quindi da quasi tutti gli altri software per fogli di calcolo, che in genere hanno funzioni di importazione per questo formato↩︎ come al solito, sia che tu li esegua dalla console che che li esegua come uno script ricordati di cancellare &gt;: il prompt appare automaticamente nella console e non è necessario negli script↩︎ in data frame↩︎ quindi con il nome fra virgolette; questo può essere comodo in alcune circostanze, quando i nomi vengono ricavati da un comando che produce, come risultato, una stringa di caratteri↩︎ come avrai potuto notare, i nomi delle funzioni del tidyverse sono un pochino più coerenti e facili da ricordare di quelli di R base: in readr, tutte le funzioni sono write_xxx e read_xxx: come conseguenza quando inizi a digitare in RStudio i suggerimenti che ottieni sono un pochino più appropriati↩︎ facendo doppio click sul nome dell’oggetto corrispondente nel pannello dell’ambiente o usando il comando View()↩︎ pillar viene caricato come dependency quando carichi il pacchetto tidyverse↩︎ se non usi menu interattivi nel report non è possibile aprire manualmente file o cambiare la cartella di lavoro↩︎ lo script assume che i file di testo che vuoi aprire abbiano tutti la stessa struttura in colonne↩︎ "],["grafica.html", "6 Introduzione alla grafica scientifica con R 6.1 Cosa c’è da imparare in questo capitolo. 6.2 I grafici, fatti bene. 6.3 I sistemi grafici in R. 6.4 Visualizzare o salvare i grafici: i device. 6.5 R, a colori. 6.6 La grammatica della grafica con ggplot2. 6.7 Grafici per variabili qualitative. 6.8 Grafici per variabili quantitative. 6.9 La grafica di base in R: un salvagente? 6.10 Altre risorse.", " 6 Introduzione alla grafica scientifica con R v1.1 4/11/2023 6.1 Cosa c’è da imparare in questo capitolo. In qualsiasi libro introduttivo su R il capitolo sulla grafica è probabilmente il più importante. I grafici (scientifici e non) sono sicuramente il modo più efficace di rappresentare i dati, viste le capacità degli esseri umani di percepire pattern in maniera prevalentemente visuale. R ha, senza dubbio, capacità di rappresentazione grafica dei dati (scientifici e non) molto superiori a quelle di altri ambienti e linguaggi per la data science. In aggiunta a questo, l’output grafico di R si presta bene ad essere inserito in documenti, app e dashboard interattive. Puoi avere un’idea rapida di quello che può fare la grafica di base di R con il seguente comando: &gt;demo(graphics) Un’idea migliore può dartela questa bella gallery di grafici con R (preparati a sopportare un bel po’ di pubblicità). Proprio per questo, è bene che tu dedichi un po’ di tempo a questo capitolo. Nella sezione 6.2 cercherò di dara qualche informazione di base sui principi della rappresentazione grafica dei dati. Leggere questa sezione potrebbe risparmiarti molti mal di testa in futuro124. Nella sezione 6.3 proverò a confrontare i diversi sistemi grafici disponibili in R: come sempre, con l’installazione base di R puoi fare molto (se non tutto) e molti pacchetti basano la loro grafica esclusivamente sulla grafica di base (6.9). D’altra parte, la grammatica della grafica, implementata da ggplot2, è sicuramente più semplice da imparare e si inserisce in maniera elegante nei flussi di lavoro tidy (ordinati). Per questa ragione, quasi tutto il capitolo sarà concentrato sulla grafica con ggplot2. Spenderò poi qualche parola sul salvataggio dei grafici in R, semplicissimo per la grafica generata da ggplot2, e appena un po’ più complicato (perché richiede il reindirizzamento dell’output dal display a un device o tipo di file, vedi sezione 6.4.1) con la grafica di base. Infine, mi concentrerò sulla grafica (o meglio sulla visualizzazione di dati) con ggplot2, illustrando i principali tipi di grafici per variabili qualitative e/o quantitative (e tutte le loro possibili combinazioni). Può sembrare strano, ma qualche cosina sulla grafica base R è necessario impararla (sezione 6.9): molti pacchetti importanti usano la grafica di base e personalizzare l’output richiede qualche conoscenza di questo sistema. La capacità di produrre visualizzazioni dei dati efficaci, eleganti e convincenti è essenziale per qualsiasi scienziat* o analista dei dati. Per questo sarebbe bene leggere con attenzione tutto il capitolo. In alternativa, puoi dare una lettura veloce alla sezione 6.2, alla sezione 6.6 sui principi dell’uso di ggplot2, e concentrarti su quelli fra i paragrafi successivi che illustrano i tipi di grafico che sono più importanti per te. Potrai tornare sugli altri argomenti quando serve. Come sempre, i paragrafi di approfondimento hanno un titolo in corsivo. 6.2 I grafici, fatti bene. La rappresentazione visuale dei dati è fondamentale il moltissimi campi e la cattiva rappresentazione dei dati è forse una delle basi principali delle diffidenza che molti nutrono per la statistica. L’ignoranza degli aspetti anche più elementari della visualizzazione dei dati da parte della stragrande maggioranza del pubblico è sicuramente un’altra ragione. Giornalisti (della carta stampata, del web e della televisione) ne fanno un largo (ab)uso e alcune infografiche sono talmente assurde da diventare dei veri e propri meme: questo articolo del blog Scienza in rete ne dà una rappresentazione, come dire, plastica. Non è detto, purtroppo, che gli scienziati facciano una lavoro migliore e, nella mia vita di ricercatore (e, purtroppo, di reviewer di articoli scientifici) ho visto cose che voi umani… Produrre delle buone visualizzazioni di dati (che forse è un modo migliore di dire rispetto a grafici scientifici, che sembra troppo limitato alle pubblicazioni scientifiche) è una cosa che si impara (purtroppo non nell’università della strada), e si impara studiando. Nella sezione 6.10 troverai qualche suggerimento125. A questo dovremmo forse aggiungere il fatto che, come scienziati abbiamo forse qualche responsabilità in più: i grafici che generiamo dovrebbero rappresentare la realtà nella maniera più fedele e oggettiva possibile, e al tempo stesso, rispondere alle esigenze di informare, motivare e convincere, che sono proprie di qualsiasi forma di comunicazione. Se poi riusciamo anche a produrre grafici belli da vedere126 è meglio, mi pare. Una trattazione estesa della tecnica e dell’arte della visualizzazione (scientifica) dei dati è decisamente al di là dello scopo di questo “libro”. Alcune cose però vanno dette. Innanzitutto, è impossibile astrarre completamente dai pregi e dai difetti del nostro sistema di percezione. Gli esseri umani processano buona parte dell’informazione che raggiunge i sensi attraverso la vista e, tipicamente, perché questa informazione “resti” nella nostra memoria sono necessari diversi passaggi127: lo stimolo visivo viene inizialmente processato dalla memoria iconica, per poi passare nella memoria a breve (che include la memoria di lavoro visiva) e infine in quella a lungo termine. Mentre i primi passaggi sono largamente inconsci, il passaggio nella memoria a lungo termine richiede un processo di creazione di relazioni con quella che è la nostra conoscenza del mondo. Stimoli visivi poco contrastati o poco intensi potrebbero essere difficili da processare e la memoria a breve termine sembra essere in qualche modo limitata: il numero di elementi diversi che possono essere conservati prima del passaggio alla memoria a lungo termine è compreso fra 4 e 9.128. Insomma, ritenere le informazioni che giungono al nostro sistema visivo richiede “lavoro” e ci sono dei limiti a quello che il nostro sistema di percezione può fare in un tempo limitato. Mentre se state leggendo un libro o un articolo scientifico potete dedicare quanto tempo volete ad un singolo grafico (o a una foto), se state guardando un video o una presentazione avete generalmente un tempo limitato. Pensate al fastidio che provate quando, dal fondo di un’aula o di una sala congressi affollata, guardate ad una presentazione con grafici troppo complessi, sfocati, poco contrastati o troppo ricchi di informazione, che magari restano sullo schermo 30 secondi. Difficilmente riuscirete a seguire ciò che chi parla vuole comunicare e entrambi avrete perso il vostro tempo. Inoltre, lo scopo della visualizzazione scientifica dei dati è fornire informazioni in modo corretto e questo, tipicamente, richiede dei confronti quantitativi. La gerarchia (da migliore a peggiore) della nostra capacità di fare confronti fra valori è129: posizione su una scala comune (per esempio quando si guarda alla posizione di diversi punti in un dot plot o linee in un rug plot, ma anche, per estensione, di punti in un grafico cartesiano) posizione su scale non comuni (per esempio quando si confronta la posizione di punti su due grafici con assi cartesiani diversi presenti nella stessa figura) lunghezza (quando per esempio si vuole confrontare la lunghezza dei box fra diversi box and whisker plot) angoli o pendenze (per esempio in un grafico a coordinate angolari) aree (per esempio quando si vuole confrontare la dimensione di punti in un bubble plot) e intensità di colore (usata per esempio per mappare una variabile quantitativa al colore di un punto) colori diversi (usati, male, in moltissime situazioni e spesso senza tener presente il fatto che molti non hanno una percezione corretta dei colori) E’ abbastanza ovvio che dovremmo attribuire le variabili più importanti alle posizioni gerarchiche più alte di questa scala. In molti grafici più complessi è necessario far percepire con chiarezza delle relazioni non quantitative, come relazioni di similarità (in un icon plot), inclusione (per esempio in una ellissi bivariata di densità), prossimità (in uno dei tantissimi grafici multivariati che servono a percepire la presenza di cluster nei dati), presenza di connessioni (per esempio in un dendrogramma o in un albero di decisioni o in un network), appartenenza allo stesso gruppo, etc. Se non conosci i tipi di grafici che ho nominato nel paragrafo precedente, non preoccuparti, li incontrerai presto. Progettare bene una visualizzazione scientifica non è quindi una cosa per niente banale: molto spesso ci si lascia guidare dall’istinto o dalle consuetudini di un determinato campo (nel mio, che mi occupo di ecologia microbica, sono abbastranza frequenti le visualizzazioni monstre, che richiederebbero parecchi minuti per cominciare, forse, a capirle, e che vengono mostrate per pochi secondi durante una presentazione). Se ti interessa approfondire questi argomenti dai (uno o più di) uno sguardo ai molti bei libri che richiamo nella sezione 6.10. Fortunatamente, i default della grafica di base e di ggplot2 in R sono “intelligenti” e ti impediranno (a meno che tu non ti impegni veramente tanto) di fare molte sciocchezze che sono invece frequentissime nei grafici generati con Microsoft Excel e molti altri fogli di calcolo. 6.3 I sistemi grafici in R. R ha tre sistemi grafici principali: base: è il sistema di default, e viene installato insieme a R con i pacchetti graphics e grDevices; ha un numero limitato di comandi per generare grafici (barplot, boxplot, hist, pairs, plot, etc.) e una serie di comandi complementari per personalizzare il grafico aggiungendo punti, modificando assi, legende, etc. I grafici sono inviati a “devices”, come lo schermo (il device di default)130 o file. lattice: richiede l’istallazione del pacchetto corrispondente131; il grafico viene creato da un unico comando (con un gran numero di parametri) e inviato a un device o a un file; è un sistema particolarmente adatto a grafici multivariati e alla creazione di sub-plot per gruppi di dati sulla base di variabili qualitative o quantitative (trellis plots). ggplot2: richiede l’istallazione del pacchetto corrispondente (o del tidyverse); i grafici vengono creati in “strati”, secondo il concetto della grammatica della grafica; una volta creato, il grafico, se assegnato ad un nome, può essere modificato con l’aggiunta di nuovi “strati” e salvato in una varietà di formati con un comando specifico (ggsave) Un confronto per un grafico a dispersione fra i tre sistemi, con la configurazione e personalizzazione minima, è mostrato dalle tre figure successive per il data set mpg, che è a sua volta incluso in ggplot2. La Figura 6.1 mostra la relazione fra il consumo (hwy, in galloni per miglio) di carburante in autostrada e la cilindrata (displ, in litri) ottenuta con il comando generico plot() della grafica di base. # se necessario carica la library tidyverse dopo aver rimosso il segno # di commento # library(tidyverse) data(mpg) plot(x = mpg$displ, y = mpg$hwy) Figura 6.1: Un grafico a dispersione ottenuto con la grafica di base di R. Qui vengono specificamente assegnati alle coordinate x e y due vettori, appartenenti allo stesso data set (in teoria possono essere 2 vettori numerici separati o addirittura due vettori in due data set diversi, ma della stessa lunghezza). Scale, etichette degli assi, simboli, titoli e sottotitoli, legende possono essere largamente personalizzati. Le funzioni della grafica di base permettono di creare rapidamente (con il minimo di comandi) molti grafici semplici, che possono essere ulteriormente personalizzati. Inoltre, gli oggetti prodotti da molte funzioni della statistica di base o aggiunte con i pacchetti possono essere direttamente utilizzati nella funzione generica plot() generando grafici dipendenti dal contesto. Personalmente, trovo la sintassi della grafica di base difficile da ricordare. In aggiunta a questo, la creazione del grafico può essere piuttosto verbosa (cioé richiede molti comandi) perché i grafici vengono creati aggiungendo ad un oggetto creato da un comando di base (per esempio plot()) una serie di altre cose create da altri comandi (points(), legend(), lines()). La Figura 6.2 mostra un trellis plot ottenuto con il comando xyplot di lattice. Qui la variabile qualitativa class è usata come variabile di gruppo. Fare la stessa cosa con la grafica di base è decisamente più complicato. Nota come in questo caso sto usando un’interfaccia formula, data, utilizzabile anche con plot. Le variabili dipendente e indipendente sono separate da una tilde ~ e la variabile di gruppo (quella che separa le singole osservazioni nei pannelli) è separata da una barra verticale | e il set di dati è indicato come data = mpg. library(lattice) xyplot(hwy ~ displ | class, data = mpg) Figura 6.2: Un grafico a dispersione ottenuto con lattice. Anche lattice è usato in molti pacchetti importanti (come per esempio car). Come gli altri pacchetti del tidyverse, ggplot2 è molto più intuitivo, anche se i comandi possono essere più “verbosi”. Le già ragguardevoli capacità di ggplot2 sono estese da un gran numero di pacchetti aggiuntivi. Infine, la figura 6.3 mostra l’equivalente della figura 6.2 ottenuto con ggplot2 (qui i pannelli sono generati dal comando facet_wrap()). # library(ggplot2) ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + facet_wrap(~class) Figura 6.3: Un grafico a dispersione ottenuto con ggplot2. Infine, quando diventerai più espert*, dovresti provare a esplorare i sistemi grafici interattivi, come ggvis e plotly. 6.4 Visualizzare o salvare i grafici: i device. In R i grafici vengono inviati a quelli che si chiamano device. Di default, il device è lo schermo e il comando che viene usato dietro le quinte è specifico per piattaforma. Prova a copiare e incollare in un nuovo script i seguenti comandi: library(tidyverse) # potrebbe non essere necessario, se hai già caricato tidyverse plot(x = mpg$displ, y = mpg$hwy) In RStudio, di default, i grafici prodotti da qualsiasi tipo di grafica vengono inviati al tab Plots del pannello Plot, ed è proprio in questo tab che dovresti vedere apparire il grafico. Se tu eseguissi lo stesso tipo di comando nella GUI di R, il grafico verrebbe inviato a una finestra che può aprirsi in un ambiente diverso (X11 su Mac)132. Il Plots tab di RStudio offre diverse funzionalità utili (vedi capitolo 2), ma può causare alcuni problemi, legati al fatto che i grafici vengono ridimensionati in maniera dinamica (mentre magari potrebbe interessarti vedere il grafico così come potrebbe apparire se lo salvassi, vedi dopo, e lo aprissi in un’altra applicazione)133. Il risultato dei comandi precedenti è questo: Figura 6.4: L’interfaccia di RStudio per MacOS. Prova a fare quanto segue: ridimensiona il tab “Plots” posizionando il puntatore sulla barra orizzontale o su quella verticale che delimitano il pannello: dovrebbe apparire una doppia frecccia, clicca con il mouse e ridimensiona il grafico; clicca sul pulsante per lo Zoom nella barra dei menu del tab Plots (quello con la lente di ingradimento): si apre una nuova finestra che puoi ridimensionare liberamente; clicca sul pulsante Export nella barra dei menu del tab Plots (quello con l’icona della piccola immagine); clicca su una delle opzioni, per esempio quella Save as image e scegli una delle opzioni. Se crei un’immagine bitmap (.tif, .jpg, .png, vedi dopo), e la apri con una app per la visualizzazione o modifica delle immagini, vedrai che la risoluzione è quella dello schermo (nel mio caso 96 dpi), che è ampiamente insufficiente per molte applicazioni. 6.4.1 Salvare i grafici: i file come device grafici. Come hai appena visto, la risoluzione dei grafici creati nel plot pane è insufficiente per molte applicazioni: per un lavoro scientifico, tipicamente, è necessario sottomettere i grafici in formato vettoriale (.eps o .pdf) o sotto forma di immagini bitmap ad alta risoluzione (300 o 600 dpi). Per farlo, occorre salvare i grafici nel formato opportuno. La tabella 6.1 riporta un elenco dei device per i formati più frequentemente usati nella grafica scientifica, con qualche nota importante sulle proprietà di ciascun formato134. Tabella 6.1: I più comuni formati grafici e i relativi device. Device Formato Estensione Tipologia Antialias Commenti png Portable Network Graphics .png bitmap sì adatto a siti web, supporta trasparenze jpeg Joint Photographic Experts Group .jpeg, .jpg bitmap sì permette una compressione (lossy) bmp Bitmap .bmp bitmap sì tiff Tagged Image Format .tif, .tiff bitmap sì consente diversi tipi di compressione pdf Portable Document Format .pdf vettoriale no flessibile, leggibile su tutti i device svg Scalable Vector Graphics .svg vettoriale sì addatto all’uso online I formati vettoriali producono immagini che, in teoria, possono essere ingrandite a piacere, senza perdita di risoluzione e senza determinare una “scalettatura” delle linee. I formati bitmap registrano le immagini come un insieme di punti: per questa ragione la dimensione e la risoluzione sono essenziali nel determinare la massima dimensione alla quale un’immagine può essere riprodotta a video o in stampa senza perdite significative di qualità. Ingrandire un’immagine bitmap a bassa risoluzione o di piccole dimensioni (in cm o pollici/ inches, pixel) risulta in significative perdite di qualità: i singoli pixel diventano chiaramente visibili e le linee possono apparire come scalettate. La scalettatura può essere in parte attenuata dall’antialiasing. Naturalmente il prezzo dell’aumento della risoluzione o della dimensione fisica è l’aumento della dimensione del file. Quest’ultima può essere in parte controllata con la compressione (per i formati che la consentono): la compressione determina una perdita di qualità generalmente irreversibile, specialmente per le compressioni “lossy” usate per esempio dal formato .jpeg. E allora, quale formato è meglio utilizzare? ogni volta che è possibile è meglio usare i formati vettoriali (.pdf per le applicazioni generali, .svg per le applicazioni su web). Tuttavia, non tutte le riviste scientifiche accettano grafici in formato .pdf e la resa di questo formato non è necessariamente uguale su tutti i sistemi per le altre applicazioni è meglio usare un formato bitmap, con una risoluzione sufficiente allo scopo: .png è un formato particolarmente adatto alle pagine web, che produce file di piccole dimensioni .bmp è un formato ingombrante ma piuttosto fedele .jpeg è sicuramente il formato preferibile per immagini leggere, specialmente se con gradienti di colore, ma ha una compressione lossy .tiff un formato molto fedele ma ingombrante, che però permette una compressione; non tutte le codicieh di questo formato funzionano su tutti i sistemi operativi. In generale, le riviste scientifiche richiedono una risoluzione di almeno 300 dpi (dot per inches) di dimensioni tali da occupare una o due colonne della “pagina” (ormai sempre più spesso virtuale, visto che quasi tutte le riviste sono on line). Per alcune applicazioni, e specialmente quando si usano gradienti di colore, potrebbe essere necessario usare una risoluzione di 600 dpi. I file prodotti dal formato preferito dalle riviste (.tif) possono essere veramente enormi (&gt;10 Mb). Per applicazioni che richiedono una visualizzazione su schermo o su pagina e per le quali non si prevede che l’utente debba ingrandire l’immagine una risoluzione di 150-220 dpi può essere sufficiente. La risoluzione dello schermo (tipicamente 72 o 96 dpi) è sufficiente solo per una visualizzazione grafica delle immagini. La figura 6.5, realizzata con ggplot2 con il dataset mpg può essere utilizzata come esempio per valutare l’effetto del tipo di formato o della compressione. mpg %&gt;% dplyr::filter(class %in% c(&quot;compact&quot;, &quot;suv&quot;, &quot;midsize&quot;, &quot;subcompact&quot;)) %&gt;% ggplot(mapping = aes(x = cty, y = hwy)) + geom_smooth(se = F) + geom_point(mapping = aes(shape = class, color = displ), size = I(2)) + labs(title = &quot;Consumo di carburante per 32 modelli di auto&quot;, subtitle = &quot;anni 1999 - 2008&quot;, x = &quot;miglia per gallone in città&quot;, y = &quot;miglia per gallone in autostrada&quot;, shape = &quot;categoria&quot;, color = &quot;cilindrata, L&quot;, caption = &quot;Fonte: EPA, https://fueleconomy.gov/&quot; ) + scale_shape_manual(values = c(16,17,15,18)) + scale_colour_continuous(type = &quot;viridis&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) Figura 6.5: Un grafico a dispersione, con annotazioni, realizzato con ggplot2. Nota come I(2) serva a assegnare uno degli elementi estetici ad un valore fisso (in questo caso la dimensione del simbolo) piuttosto che ad una delle variabili. Ora prova a copiare e incollare il seguente codice in un nuovo script e ad eseguirlo. Come risultato: prima creiamo il grafico e lo assegniamo ad un oggetto poi mandiamo il grafico al device corrente poi lo mandiamo ad un file .pdf (nella working directory), usando le opzioni di default # qual&#39;è il device attivo? dev.cur() # creiamo il plot e assegnamolo ad un oggetto mpg_plot &lt;- mpg %&gt;% dplyr::filter(class %in% c(&quot;compact&quot;, &quot;suv&quot;, &quot;midsize&quot;, &quot;subcompact&quot;)) %&gt;% ggplot(mapping = aes(x = cty, y = hwy)) + geom_smooth(se = F) + geom_point(mapping = aes(shape = class, color = displ), size = I(2)) + labs(title = &quot;Consumo di carburante per 32 modelli di auto&quot;, subtitle = &quot;anni 1999 - 2008&quot;, x = &quot;miglia per gallone in città&quot;, y = &quot;miglia per gallone in autostrada&quot;, shape = &quot;categoria&quot;, color = &quot;cilindrata, L&quot;, caption = &quot;Fonte: EPA, https://fueleconomy.gov/&quot; ) + scale_shape_manual(values = c(16,17,15,18)) + scale_colour_continuous(type = &quot;viridis&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) # inviamo il plot al device di default, il plot pane mpg_plot # ora inviamo ad un device pdf, con le opzioni di default ?pdf # ATTENZIONE IL FILE PDF VIENE SALVATO CORRETTAMENTE SOLO SE VENGONO ESEGUITI # ENTRAMBI I COMANDI SUCCESSIVI pdf(file = &quot;mpg_plot.pdf&quot;) mpg_plot # chiudiamo il device e restituisce l&#39;output al device di default (il plot pane) dev.off() # ora apriamo un device png con le opzioni di default e una risoluzione di 72 dpi ?png png(file = &quot;mpg_plot.png&quot;, width = 7, height = 5, res = 72, units = &quot;in&quot;) # la lista dei device si ottiene con dev.list() cat(&quot;the list of devices&quot;,&quot;\\n&quot;, dev.list()) dev_list &lt;- dev.list() # è un vettore con nomi dev_list # salviamo il grafico come .png, 72 dpi, 7x5 pollici mpg_plot # chiudiamo il device (non è necessario) dev.off() # ora .jpeg a due diverse risoluzioni, stessa dimensione, con la compressione # di default (quality = 75) jpeg(file = &quot;mpg_plot_150.jpg&quot;, res = 150, width = 7, height = 5, units = &quot;in&quot;) mpg_plot dev.off() jpeg(file = &quot;mpg_plot_300.jpg&quot;, res = 300, width = 7, height = 5, units = &quot;in&quot;) mpg_plot dev.off() # ora .tiff, non compresso, stessa dimensione tiff(file = &quot;mpg_plot_300.tiff&quot;, res = 300, width = 7, height = 5, units = &quot;in&quot;) mpg_plot dev.off() Prova a verificare la dimensione dei diversi file, ad aprirli con la tua applicazione di default per la grafica e a zoommare: cosa succede ai colori? ai punti? alle linee? 6.4.2 Salvare i grafici di ggplot2 con ggsave. I device funzionano con tutti i sistemi grafici, compreso ggplot2, che però mette a disposizione un sistema molto più semplice per salvare i grafici, il comando ggsave(). Prova ad eseguire questi comandi in uno script o nella console (è necessario aver creato l’oggetto grafico mpg_plot). # l&#39;aiuto su ggsave ?ggsave ggsave(mpg_plot, filename = &quot;mpg_plot_150.tiff&quot;, dpi = 150) ggsave() usa defualt intelligenti: determina il device dall’estensione del file e, se non si indica alcun oggetto da salvare, salva l’ultimo disponibile. 6.4.3 Le dimensioni del device e le opzioni grafiche. Il device deve avere spazio sufficiente ad “accogliere” il grafico e tutti i suoi elementi (titoli, titoli degli assi, legende). Mentre il plot pane di RStudio viene ridimensionato dinamicamente e può essere ingrandito a piacere dall’utente, lo stesso non vale per i device bitmap. Prova a vedere cosa succede con questi comandi: jpeg(file = &quot;mpg_plot_150_480.jpg&quot;, res = 150) mpg_plot dev.off() A causa della maggiore risoluzione gli elementi del grafico non “entrano” nello spazio disponibile (480x480 pixel). Un altro aspetto interessante è la personalizzazione delle diverse aree del device usando i parametri grafici. Una trattazione estesa di questo argomento va decisamente al di là degli obiettivi di pigR135. In breve: la dimensione del device può essere verificata usando dev.size()136 il device è diviso in due aree principali: i margini, che ospitano gli assi e le loro etichette e i titoli e possono essere fissati, in pollici con il comando par(mai = c(0.1,0.1,0.1,0.1)); i 4 numeri sono, in senso orario i margini inferiore, sinistro, superiore e destro; mar permette di fissare i margini in linee (lo spazio che ospita una linea o una colonna di testo) l’area del grafico, che può essere fissata, fra le altre cose fissando la dimensione per la larghezza e altezza in pollici: par(pin = c(6.5,4.5)) dà un’area grafica di 6,5 x 4,5 pollici In realtà, è possibile operare in maniera molto più fine e persino dividere il device in aree (anche di divese dimensioni). La figura 6.6 fornisce un esempio di come il device possa essere diviso in due (1 riga, due colonne) per ospitare due grafici diversi. # salva i parametri grafici correnti per poterli resettare facilmente opar &lt;- par(no.readonly = T) # dividi il device in una riga con due colonne e riempi per righe # (prima la prima colonna e poi la seconda) par(mfrow = c(1,2)) # un grafico a dispersione plot(hwy ~ cty, data = mpg) # un grafico a barre barplot(xtabs(~ class, data = mpg), las = 2) Figura 6.6: Dividere i devices. # resetta il device par(opar) Questo sistema permette una grande flessibilità nella divisione dell’area grafica ma richiede una buona conoscenza di tutti i parametri grafici. Ovviamente, come vedremo dopo, in R c’è sempre un sistema più semplice: il pacchetto cowplot, per esempio, permette di combinare gli oggetti grafici prodotti con ggplot2 con grande semplicità. 6.5 R, a colori. L’uso del colore è critico per ottenere buone visualizzazioni di dati (leggi la sezione 6.2 per qualche dettaglio in più) ed R fornisce, tramite il pacchetto grDevices e molti pacchetti aggiuntivi, moltissimi strumenti per gestire al meglio i colori. I colori possono essere utilizzati per: distinguere diverse categorie: in questo caso sono adatti a variabili qualitative e i colori della palette usati in un grafico dovrebbero essere ottimizzati per distinguere al meglio le diverse categorie (che, idealmente, dovrebbero essere non più di 12, meglio se meno di 7); rappresentare valori quantitativi; in questo caso si possono usare due tipi di scale cromatiche, con colori che formano un gradiente: sequenziali: adatti a valori uniformemente crescenti o decrescenti; divergenti: adatti a valori che divergono a partire da un valore centrale, tipicamente lo 0, come per esempio i valori di diversi indici di correlazione (che variano fra -1 e + 1) In R i colori possono essere indicati con i loro nomi o mediante codici esadecimali che rappresentano i tre valori della scala RGB (rosso, verde, blu, ciascuno dei quali può variare da 0, assente, a 255, massima intensità). Una ottima cheatsheet sull’uso dei colori in R è disponibile qui. Per visualizzare i nomi dei colori prova questi comandi nella console: # i primi 20 e gli ultimi 20 colori (cambia il codice per visualizzare un # elenco diverso dei 657 colori disponibili) colors()[c((1:20), (length(colors())-20):length(colors()))] # ottieni i nomi dei colori della palette in uso # (quella di default all&#39;avvio di R, può essere cambiata) palette() ?palette # per saperne di più sulle palette di grDevices ?rainbow La Figura 6.7 mostra 6 palette sotto forma di diagrammi a torta. opar &lt;- par(no.readonly = T) par(mfrow=c(2,3)) # la palette di default pie(rep(1, length(palette())), col = palette(), labels = palette(), main = &quot;la palette di default&quot;) # una palette arcobaleno a 6 colori palette(rainbow(6)) lamiapalette &lt;- palette() pie(rep(1, length(lamiapalette)), col = palette(), labels = lamiapalette, main = &quot;una palette arcobaleno&quot;) # una palette di 20 colori a gradiente di calore palette(heat.colors(20)) lamiapalette &lt;- palette() pie(rep(1, length(lamiapalette)), col = palette(), labels = lamiapalette, main = &quot;una palette a gradiente di calore&quot;) # una palette toporgrafica di 20 colori palette(topo.colors(20)) lamiapalette &lt;- palette() pie(rep(1, length(lamiapalette)), col = palette(), labels = lamiapalette, main = &quot;una palette topografica&quot;) # colori adatti per mappe palette(terrain.colors(20)) lamiapalette &lt;- palette() pie(rep(1, length(lamiapalette)), col = palette(), labels = lamiapalette, main = &quot;una palette &#39;terreno&#39;&quot;) # una palette ciano-magenta, adatta a daltonici palette(cm.colors(20)) lamiapalette &lt;- palette() pie(rep(1, length(lamiapalette)), col = palette(), labels = lamiapalette, main = &quot;una palette cyano-magenta&quot;) Figura 6.7: Sei palette di R rappresentate come diagrammi a torta. # resetla palette palette(&quot;default&quot;) # resetta i parametri grafici par(opar) Prova ad eseguire lo stesso codice con palette diverse. RColorBrewer è un pacchetto che fornisce diverse palette ottimizzate per dati qualitativi e quantitativi (sequenziali o divergenti). Per saperne di più scrivi nella console: ?RColorBrewer RColorBrewer fornisce molte palette ben fatte, ottimizzate anche per i diversi tipi di daltonismo. display.brewer.all(n=NULL, type=&quot;all&quot;, select=NULL, exact.n=TRUE, colorblindFriendly=FALSE) Figura 6.8: Le palette di RColorBrewer. 6.6 La grammatica della grafica con ggplot2. ggplot2 è sicuramente il sistema migliore, più flessibile e, probabilmente, più potente per produrre grafici scientifici in R. In più, il suo apprendimento è reso (relativamente) facile dall’organizzazione concettuale (creazione dei grafici in strati, usando i concetti della grammatica della grafica) e da un insieme di comandi dai nomi coerenti. Il materiale di riferimento per ggplot2 è disponibile qui e molti dei libri citati nella sezione 6.10 descrivono principalmente o esclusivamente la grafica con ggplot2. La realizzazione di un grafico con ggplot2 inizia sempre con il comando ggplot ed è seguita da uno o più strati, separati dal segno +137, che definiscono gli altri elementi del grafico. Il risultato è una lista, che può essere assegnata ad un nome. Se non lo si fa, il comando genera immediatamente il grafico nel device attivo (in RStudio il plot pane). Se il grafico viene assegnato ad un nome è possibile continuare a modificarlo, aggiungendo ulteriori strati. In entrambi i casi, è possibile salvare facilmente il grafico con ggsave (vai al paragrafo 6.4.2 per dettagli). La funzione qplot, che consentiva di produrre grafici molto rapidamente usando una sintassi vicina alla grafica di base, è ormai deprecata138, anche se è ancora possibile usare questo comando; qualche elemento lo trovi nel paragrafo 6.8.7. La grammatica della grafica è una rappresentazione strutturata degli elementi che compongono un grafico (scientifico) e delle loro relazioni: i dati: devono essere necessariamente sotto forma di data frame o tibble, vedi sezione 4.4, e possono essere “passati” tramite una pipe (%&gt;%) o inseriti nella funzione ggplot139; gli “estetici” (aesthetics in inglese) definiscono quali variabili dei dati verranno assegnate a posizioni in un sistema di coordinate (x, y), ad altri elementi quantitativi (dimensione, trasparenza), ad elementi qualitativi come la forma dei simboli o la tipologia delle linee, ad elementi qualitativi o quantitativi come il colore; i “geomi” (geoms in inglese) definiscono in che modo uno o più estetici vengono rappresentati (come grafico a barre, a dispersione, etc.) in uno strato (layer in inglese); lo strato eredita gli estetici dalla funzione ggplot o da uno strato precedente e, in alcuni casi, può utilizzare una trasformazione statistica o un aggiustamento di posizione (disposizione di elementi diversi che altrimenti si sovrapporrebbero nel grafico); le “annotazioni” (annotations in inglese) aggiungono uno strato con elementi fissi, come linee verticali, diagonali o orizzontali, mappe, etc.; le “scale” (sia quelle quantitative che qualitative) possono essere generate automaticamente o personalizzate in maniera molto fine; le “guide” di assi e legende servono al lettore ad interpretare correttamente un grafico; vengono generate automaticamente ma possono essere personalizzate in dettaglio (intervalli degli assi, trattini principali o secondari, etc.); le “facet” servono per suddividere, sulla base di una o più variabili, il grafico in sub-grafici; i “temi” (themes in inglese) consentono una personalizzazione molto fine di aspetti diversi del grafico (sfondo, colori delle guide, font, allineamento, etc.); esiste un gran numero di temi predefiniti e un certo numero di temi aggiuntivi forniti da pacchetti addizionali (come ggthemes). Descritto così, l’apprendimento di ggplot2 sembra un’impresa disperata. In realtà, nella maggior parte dei casi è possibile produrre grafici piacevoli ed efficaci con un minimo di opzioni: i default di ggplot2 sono “intelligenti” e spesso ggplot2 impedisce attivamente di fare cose sbagliate dal punto di vista della presentazione scientifica di dati (come per esempio produrre diagrammi a torte). La figura 6.9 mostra un piccolo esempio che ci permette di individuare facilmente i diversi elementi. # library(ggplot2) mpg %&gt;% dplyr::filter(class %in% c(&quot;compact&quot;, &quot;suv&quot;, &quot;pickup&quot;, &quot;subcompact&quot;)) %&gt;% ggplot(mapping = aes(x = displ, y = hwy)) + geom_smooth(se = F) + geom_smooth(method = &quot;lm&quot;, formula = y~x, color = &quot;red&quot;, linetype = 2, se = F) + geom_point(mapping = aes(size = cyl, shape = class)) + labs( title = &quot;Consumi in autostrada di alcuni modelli di autovetture, 1999 - 2008&quot;, caption = &quot;https://fueleconomy.gov/&quot;, x = &quot;cilindrata, litri&quot;, y = &quot;consumo in autostrada, km per gallone&quot;, size = &quot; n. cil.&quot;, shape = &quot;classe&quot; ) + scale_size(range = c(1,2.5)) + scale_x_continuous(limits = c (1,7), breaks = seq(1,7), minor_breaks = seq(1,7,0.5)) + scale_y_continuous(limits = c(10,50), breaks = seq(10,50,10), minor_breaks = seq(10,50,5)) + scale_shape_manual( values = c(15, 16, 17, 18)) + theme(title = element_text(hjust = 0.5)) Figura 6.9: Gli elementi della grammatica della grafica in un grafico generato da ggplot In questa figura: i dati sono forniti dal database mpg (filtrato), che viene “passato” al comando ggplot() con una pipe (%&gt;%) gli estetici sono: x = displ, y = hwy (indicati nella funzione ggplot ed ereditati dagli strati successivi, rappresentano le coordinate nello spazio cartesiano) size = cyl (influenza la dimensione dei punti) shape = class (influenza il tipo di simbolo utilizzato) i geomi sono: geom_smooth (passato due volte, con la creazione di uno strato con uno smoother non parametrico, in blu, e una regressione lineare, in rosso, con una linea tratteggiata) geom_point (che crea il grafico a dispersione) alcune etichette sono modificate rispetto ai default con il comando labs le scale sono modificate rispetto ai defaults con i comandi scale_ il tema utilizzato è quello di default, con una piccola modifica (allineamento del titolo al centro) ottenuta con il comando theme ggplot2 offre geomi adatti alla grande maggioranza dei grafici scientifici. In più, grafici più complessi e specializzati sono resi disponibili da altri pacchetti (le estensioni di ggplot2, vedi paragrafo 6.8.6). Imparare ad usarli tutti non è probabilmente necessario, anche se avere un’idea delle possibilità è utile e stimolante (vedi la sezione #ref(altrerisgraf)). Qui userò un approccio adatto a chi parte praticamente da 0, dividendo i comandi per generare grafici in due gruppi: quelli adatti alle sole variabili qualitative e quelli adatti alle variabili quantitative (se non ricordi cosa sono vai al paragrafo 4.1.2). In realtà, nel secondo caso si finisce spesso per usare combinazioni dei due tipi di variabili. Per semplicità, trascurerò alcuni tipi di grafici importanti, che saranno presentati in altri capitoli di questo testo (o di testi successivi, non ho ancora deciso). 6.7 Grafici per variabili qualitative. Le variabili qualitative, e in particolare le variabili qualitative nominali, possono assumere solo valori discreti: per questo è possibile solo classificare i valori nei diversi gruppi e contarli. Le variabili qualitative sono spesso usate per individuare gruppi e per questo sono molto utilizzate nei grafici per variabili quantitative (vedi sezione 6.8). Di fatto, il tipo di grafico più comune per sole variabili qualitative è il grafico a barre140. 6.7.1 Diagrammi a barre. In un grafico a barre si rappresentano tipicamente le conte o le proporzioni dei diversi livelli di una o più variabili qualitative. Come esempio, userò in set di dati Arthritis, disponibile nel pacchetto vcd. E’ un set di dati molto semplice, relativo ad un esperimento in cui, a gruppi diversi di pazienti, vengono somministrati un farmaco per il trattamento dell’artrite reumatoide o un placebo. Il set di dati ha 3 variabili qualitative (o fattori, Treatment, Sex, Improved, vedi paragrafo 4.1.2), una variabile quantitativa (Age) e un variabile (ID) che serve unicamente da identificativo del singolo paziente. Prima di procedere oltre, dovresti: leggere l’aiuto del set di dati (prova con ?Arthritis) esplorare brevemente il set di dati usando le funzioni e i menu di RStudio o i comandi illustrati nel capitolo 4 cercare di capire cosa potrebbe essere interessante visualizzare in un grafico141 Prima di tutto, creerò un nuovo set di dati, con alcune piccole modifiche: data(&quot;Arthritis&quot;) # creo un fattore che divide in pazienti in tre gruppi usando la variabile Age, # usando cut() # i gruppi, arbitrariamente, sono con Age&lt;=22, 22&lt;Age≤40, 40&lt;Age≤59, Age&gt;59 Arthritis2 &lt;- Arthritis Arthritis2$ageClass &lt;- cut(Arthritis2$Age, c(22, 40, 59, max(Arthritis$Age)), right = T, labels = c(&quot;young&quot;,&quot;middle aged&quot;, &quot;elder&quot;)) Qui e altrove, quando compare un comando che non conosci sarebbe prudente che tu ne leggessi, almeno superficialmente, l’aiuto. Non si sa mai, ti potrebbe essere utile in futuro… Ora creo un semplice grafico a barre impilate (le conte dei gruppi definiti dalla variabile assegnata a fill sono impilati), che mostra l’effetto del trattamento sui sintomi. Nota come i dati rappresentino le conte dei diversi gruppi o combinazioni di gruppi (Treated x Improved). Dietro le quinte, geom_bar() usa la trasformazione stat_count() che tabula i valori delle diverse combinazioni. # prima di tutto, creo una lista che può essere facilmente riciclata e che # contiene i dati e solo un estetico, quello che andrà sull&#39;asse delle x artbar1 &lt;- ggplot(data = Arthritis2, aes(x= Treatment)) # aggiungo il secondo strato con in geoma gem_bar, in cui passo un ulteriore # estetico, Improved, che verrà mappato sul colore artbar1 + geom_bar(mapping = aes(fill = Improved)) Figura 6.10: Un grafico a barre minimo. Bene, semplice, no? La stessa cosa poteva essere realizzata con i seguenti comandi, che puoi copiare e incollare nella console: ggplot(data = Arthritis2, aes(x= Treatment, fill = Improved)) + geom_bar() Nota come il secondo strato, quello del geoma, “eredita” gli estetici dallo strato precedente. Ora “migliorerò” un po’ il grafico, agendo su scale, colori, etichette, etc. Per farlo, parto comunque dal grafico creato in precedenza, che è nell’oggetto artbar1. artbar_semplice &lt;- artbar1 + geom_bar(mapping = aes(fill = Improved)) # uso il comando labs per cambiare l&#39;etichetta dell&#39;asse y, aggiungere un # titolo, sottotitolo e una legenda artbar_semplice &lt;- artbar_semplice + labs(y = &quot;Numero di pazienti&quot;, title = &quot;Effetto del farmaco x sui sintomi dell&#39;artrite reumatoide&quot;, subtitle = &quot;Un esperimento randomizzato, con placebo e doppio cieco&quot;, caption = &quot;Koch &amp; Edwards, 1988&quot;) # cambio le scale, per usare termini in Italiano, aggiungere dei trattini # diversi per l&#39;asse y e cambiare la palette dei colori artbar_semplice &lt;- artbar_semplice + scale_x_discrete(&quot;Trattamento&quot;, labels = c(&quot;Placebo&quot; = &quot;Placebo&quot;, &quot;Treated&quot; = &quot;Farmaco x&quot;)) + scale_y_continuous(limits = c(0, 50), breaks = seq(0,50,10), minor_breaks = seq(0,50,2)) + scale_fill_brewer(&quot;Miglioramenti&quot;, labels = c(&quot;None&quot; = &quot;0&quot;,&quot;Some&quot;=&quot;+&quot;, &quot;Marked&quot; = &quot;+++&quot;), type = &quot;qual&quot;, palette = &quot;Paired&quot;) # cambio il tema, e centro i titoli, cambiandone font e dimensione artbar_semplice &lt;- artbar_semplice + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;), plot.subtitle = element_text(hjust = 0.5, face = &quot;italic&quot;, size = 12)) artbar_semplice Figura 6.11: Un grafico a barre semplice. Nota come: avrei potuto produrre il grafico aggiungendo i vari strati in un solo comando multilinea, oppure tenere uno strato di base, con gli elementi minimi cui aggiungere le personalizzazioni tutti gli elementi passati ai comandi labs e scale potevano essere definiti “esternamente” al comando, p.es. usando dei vettori con (nell’opzione labels di scale_x_discrete) o senza nomi (negli altri casi); ciascuno di questi elementi poteva essere persino il risultato di una funzione benché si possa personalizzare praticamente tutto, con pochissimi comandi è possibile usare un grafico accettabile e gradevole Prova tu stess*! Ora, consentimi una piccola digressione. Dirai tu, se posso ottenere un buon risultato con pochi comandi o, meglio ancora, usando un software con un’interfaccia “punta e clicca”, perché devo fare tutta questa fatica ad imparare ad usare R e ggplot2? È un’ottima domanda, ma ti consiglio di rileggere bene l’introduzione a questo testo (capitolo 1). Inoltre, i grafici realizzati con R hanno due caratteristiche fondamentali per la scienza moderna: la trasparenza (è sempre molto chiaro cosa hai fatto per ottenere un grafico) e la riproducibilità (chiunque, anche su un’altra piattaforma, può riprodurre esattamente lo stesso grafico). Infine (e questo credo sia un buon argomento), se un revisore maligno ti chiede di modificare un grafico è molto più facile farlo se lo hai realizzato con R. Per cambiare la disposizione del grafico a barre è possibile usare l’argomento position in geom_bar: Nella figura 6.12 ho usato i tre possibili valori: stack, il default, produce diagrammi a barre impilate: hanno il vantaggio di permettere di confrontare facilmente i valori delle categorie definite dalla variabile cui è stato attribuito il riempimento (fill)142 come aesthetic, ma, quando la conta dei valori per le categorie definite dall’asse delle x è molto diversa diventa difficile confrontare l’effetto della variabile assegnata all’asse delle x su quella assegnata al fill dodge: produce diagrammi a barre affiancate: anche in questo caso, mentre è facile il confronto delle diverse categorie all’interno di uno stesso gruppo definito da un valore sull’asse delle x, non è altrettanto facile confrontare l’effetto della variabile sull’asse delle x sulla distribuzione della variabile assegnata al riempimento; rispetto a stack è possinbile ottenere con maggiore precisione i singoli valori per le diverse categorie definite dal fill; fill: come stack, ma i valori della variabile assegnata al riempimento sono visualizzati come proporzioni (tutte le barre hanno altezza uguale e, se non lo si aggiunge come etichetta, è impossibile conoscere il valore della conta per ogni dato valore di x); utile quando l’enfasi è sul confronto di proporzioni; Nota inoltre come questa figura sia in realtà costruita affiancando 3 diversi elementi grafici usando la funzione plot_grid() del pacchetto cowplot143. Questo è molto diverso dal creare pannelli in un grafico usando un’altra variabile, come vedremo dopo per l’uso di facet_wrap e facet_grid. Inoltre, in tutti e tre i grafici la legenda è stata spostata sul fondo del grafico. Prova a esplorare altre posizioni della legenda. Nota anche come la legenda sia stata soppressa in due grafici e personalizzata in quello centrale. barre_impilate &lt;- artbar1 + geom_bar(mapping = aes(fill = Improved)) + labs(y = &quot;Numero di pazienti&quot;) + scale_x_discrete(&quot;Trattamento&quot;, labels = c(&quot;Placebo&quot; = &quot;Placebo&quot;, &quot;Treated&quot; = &quot;Farmaco x&quot;)) + scale_fill_brewer(&quot;Miglioramenti&quot;, labels = c(&quot;None&quot; = &quot;0&quot;,&quot;Some&quot;=&quot;+&quot;, &quot;Marked&quot; = &quot;+++&quot;), type = &quot;qual&quot;, palette = &quot;Paired&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;), plot.subtitle = element_text(hjust = 0.5, face = &quot;italic&quot;, size = 12), legend.position = &quot;none&quot;) barre_raggruppate &lt;- artbar1 + geom_bar(mapping = aes(fill = Improved), position = &quot;dodge&quot;) + labs(y = &quot;Numero di pazienti&quot;) + scale_x_discrete(&quot;Trattamento&quot;, labels = c(&quot;Placebo&quot; = &quot;Placebo&quot;, &quot;Treated&quot; = &quot;Farmaco x&quot;)) + scale_fill_brewer(&quot;Miglioramenti&quot;, labels = c(&quot;None&quot; = &quot;0&quot;,&quot;Some&quot;=&quot;+&quot;, &quot;Marked&quot; = &quot;+++&quot;), type = &quot;qual&quot;, palette = &quot;Paired&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;), plot.subtitle = element_text(hjust = 0.5, face = &quot;italic&quot;, size = 12), legend.position = c(0.50,0.85), legend.text = element_text(size = 6)) barre_proporzioni &lt;- artbar1 + geom_bar(mapping = aes(fill = Improved), position = &quot;fill&quot;) + labs(y = &quot;Frazione dei pazienti&quot;) + scale_x_discrete(&quot;Trattamento&quot;, labels = c(&quot;Placebo&quot; = &quot;Placebo&quot;, &quot;Treated&quot; = &quot;Farmaco x&quot;)) + scale_fill_brewer(&quot;Miglioramenti&quot;, labels = c(&quot;None&quot; = &quot;0&quot;,&quot;Some&quot;=&quot;+&quot;, &quot;Marked&quot; = &quot;+++&quot;), type = &quot;qual&quot;, palette = &quot;Paired&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;), plot.subtitle = element_text(hjust = 0.5, face = &quot;italic&quot;, size = 12), legend.position = &quot;none&quot;) plot_grid(barre_impilate, barre_raggruppate, barre_proporzioni, labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 3, nrow = 1) Figura 6.12: L’uso dell’argomento position nei diagrammi a barre. In tutti e tre i grafici è evidente come l’uso del farmaco x, rispetto al placebo, incrementi il numero dei casi con un marcato miglioramento dei sintomi e diminuisca il numero dei casi con sintomi gravi, anche se questo effetto è molto più evidente nel grafico C, dove l’altezza delle colonne è standardizzata. Nota come il codice sia molto verboso (moltissime linee di codice per ottenere il grafico desiderato) e come i grafici B e C siano stati ottenuti, di fatto, facendo un copia e incolla del codice del primo grafico e modificando due elementi (l’argomento position di geom_bar e la legenda dell’asse delle y). Questa pratica, oltre che essere inelegante, è soggetta ad errore. Una soluzione più elegante è definire una funzione (vedi capitolo 4, paragrafo 4.10.4). Prova tu stesso con il codice che segue: è sufficiente cambiare gli argomenti bpos, yl e lpos della funzione per ottenere l’effetto desiderato: Genera_bar_plot &lt;- function(bpos = &quot;stack&quot;, yl = &quot;Numero di pazienti&quot;, lpos = &quot;right&quot;){ artbar1 + geom_bar(mapping = aes(fill = Improved), position = bpos) + labs(y = yl) + scale_x_discrete(&quot;Trattamento&quot;, labels = c(&quot;Placebo&quot; = &quot;Placebo&quot;, &quot;Treated&quot; = &quot;Farmaco x&quot;)) + scale_fill_brewer(&quot;Miglioramenti&quot;, labels = c(&quot;None&quot; = &quot;0&quot;,&quot;Some&quot;=&quot;+&quot;, &quot;Marked&quot; = &quot;+++&quot;), type = &quot;qual&quot;, palette = &quot;Paired&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;), plot.subtitle = element_text(hjust = 0.5, face = &quot;italic&quot;, size = 12), legend.position = lpos) } # cambia gli argomenti della funzione fra parentesi; # yl può essere qualsiasi testo, # bpos può essere &quot;stack&quot;, &quot;dodge&quot; o &quot;fill&quot; # lpos può essere &quot;bottom&quot;, &quot;top&quot;, &quot;right&quot;, &quot;left&quot; # o un vettore numerico di lunghezza 2 # che definisce la posizione della legenda # qui vengono usati gli argomenti di default il_mio_bar_plot &lt;- Genera_bar_plot() il_mio_bar_plot # qui invece viene generato l&#39;equivalente del grafico C nella figura precedente, il_mio_bar_plot &lt;- Genera_bar_plot(bpos = &quot;fill&quot;, yl = &quot;frazione dei pazienti&quot;, lpos = &quot;bottom&quot;) il_mio_bar_plot Dividere i grafici in subplot usando un’ulteriore variabile qualitativa può essere utile. Nella Figura 6.13 è possibile apprezzare come pazienti di sesso femminile o maschile reagiscano diversamente al trattamento farmacologico. Il grafico include anche le seguenti personalizzazioni: le etichette dei pannelli, che dovrebbero corrispondere ai livelli della variabile Sex sono state cambiate; il numero totale di casi per ciascuna barra impilata a proporzioni è stato aggiunto con geom_text i_nomi_dei_sessi &lt;- as_labeller( c(&quot;Female&quot; = &quot;Femmine&quot;, &quot;Male&quot; = &quot;Maschi&quot;)) ggplot(data = Arthritis2, aes(x= Treatment)) + geom_bar(mapping = aes(fill = Improved), position = &quot;fill&quot;) + geom_text(aes(label = after_stat(count)), stat = &quot;count&quot;, position = &quot;fill&quot;, colour = &quot;white&quot;, vjust = 1.5) + facet_wrap(~Sex, labeller = i_nomi_dei_sessi) + labs(y = &quot;Frazione dei pazienti&quot;) + scale_x_discrete(&quot;Trattamento&quot;, labels = c(&quot;Placebo&quot; = &quot;Placebo&quot;, &quot;Treated&quot; = &quot;Farmaco x&quot;)) + scale_fill_brewer(&quot;Miglioramenti&quot;, labels = c(&quot;None&quot; = &quot;0&quot;,&quot;Some&quot;=&quot;+&quot;, &quot;Marked&quot; = &quot;+++&quot;), type = &quot;qual&quot;, palette = &quot;Paired&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;), plot.subtitle = element_text(hjust = 0.5, face = &quot;italic&quot;, size = 12)) Figura 6.13: Un grafico a barre con facet La presenza dei numeri indica abbastanza chiaramente che l’esperimento è sbilanciato, con un numero di pazienti di sesso femminile molto più alto. E’ anche abbastanza chiaro perché sia necessario un esperimento con doppio cieco e placebo per testare un farmaco ;-) Incidentalmente, potrebbe essere interessante l’età dei pazienti come ulteriore variabile. Prova tu stess* a creare un grafico con il dataset Arthritis2 usando facet_grid(Sex ~ ageClass). Arthritis2 %&gt;% ggplot(mapping = aes(x=Treatment, fill = Improved)) + facet_grid(Sex ~ ageClass) + geom_bar() 6.7.2 Fare di più con i grafici per variabili qualitative. Il grafico a barre è sicuramente il grafico più efficace per rappresentare conte di variabili qualitative. I blocchi di codice successivo, che devi eseguire in uno script o nella console, ti permettono di sperimentare con alcune personalizzazioni utili. Trasporre gli assi può essere utile quando le etichette dell’asse delle x sono piuttosto lunghe: artbar1 + geom_bar(aes(fill = Improved)) + coord_flip() Esplora l’aiuto di theme per vedere come, con axis.text.x (o le funzioni equivalenti con gli altri elementi di testo del grafico) e element_text() è possibile personalizzare posizione, angolo, giustificazione delle etichette. Grafici trasposti possono essere ottenuti con il pacchetto estensione ggstance. ggplot2 non consente in maniera semplice di creare diagrammi a torta (pie charts), probabilmente perché sono uno dei tipi peggiori di rappresentazione dei dati. E’ possibile creare qualcosa di simile usando le coordinate polari: artbar1 + geom_bar(aes(fill= Improved), show.legend = F) + coord_polar() Oppure, se veramente sei testard*, prova i suggerimenti forniti da “R graphical cookbook” (vedi in altre risorse ***) o il pacchetto ggpie. O, ancora potresti provare i fan plot (plotrix::fan.plot()) o provare qualche alternativa, come i doughnut plot (grafici a ciambella), per esempio usando i pacchetti ggsector o ggpie. Altri tipi di grafici per variabili qualitative interessanti sono: i diagrammi a mosaico (clicca qui per qualche esempio o prova con ggmosaic) i treemaps con il pacchetto specializzato treemap o con treemapify 6.8 Grafici per variabili quantitative. Spesso ci interessa rappresentare la distribuzione o le relazioni fra una o più variabili quantitative, magari anche in funzione dei gruppi determinati dai livelli di una o più variabili qualitative. Le rappresentazioni grafiche per queste situazioni sono varie, e possono essere combinate: rappresentazioni della distribuzione o densità gli istogrammi (histogram) sono una versione continua dei diagrammi a barre: l’intervallo di valori di una singola variabile quantitativa viene diviso in un certo numero di intervalli più piccoli, di solito di uguali dimensioni; l’altezza delle barre per ciascun intervallo mostra la conta dei valori di ciascun gruppo. In questo caso (geom_histogram) è sufficiente una sola variabile x quantitativa (l’asse delle y mostra le conte), mentre altre variabili qualitative possono essere utilizzate per il colore dei bordi o il riempimento delle barre; è anche possibile ottenere equivalenti bi- o tridimensionali per 2 variabili quantitative (geom_bin2d o geom_hex) in cui l’intensità o la gradazione del colore rappresenta il numero di osservazioni per ciascuna combinazione di intervalli x e y; i poligoni di frequenza (frequency polygon, geom_freqpoly) o i diagrammi ad area (area plot, geom_area) sono due buone alternative agli istogrammi per la stessa tipologia dei dati, e usano rispettivamente una linea spezzata o un’area per rappresentare la distribuzione; analogamente agli istogrammi, colori dei bordi o riempimenti possono essere usati per mostrare l’effetto di variabili qualitative; i grafici a densità (geom_density) usano qualche sorta di approssimazione continua (smoother) per rappresentare la densità; anche per questi esistono equivalenti a due dimensioni; i box plot, ottenuti con geom_boxplot, e il loro analogo continuo, i violin plot (geom_violin) sono utili a rappresentare, in modo non parametrico (cioé senza fare ipotesi particolari sui parametri della distribuzione), la distribuzione di una variabile quantitativa (y) in funzione di uno o più valori di una variabile qualitativa (x) con qualche accorgimento, alcuni altri geomi (geom_point, geom_jitter, geom_rug) possono essere utilizzati, spesso in combinazione con altri geomi, per rappresentare densità e distribuzione di variabili quantitative rappresentazioni di indicatori di tendenza centrale e della relativa incertezza o variabilità: in molti casi è interessante riassumere una distribuzione unimodale rappresentandone qualche indicatore di tendenza centrale (media, mediana) con qualche indicatore di variabilià o incertrezza (deviazione standard, range interquartile, intervalli di confidenza). In genere, questi grafici hanno un’asse delle x qualitativo (diverse categorie di una variabile qualitativa) e una y quantitativa. Oltre ai boxplot, già descritti in precedenza, è possibile usare: diagrammi a rettangoli con barre di confidenza (geom_col combinato con geom_errorbar o geom_linerange) diagrammi a punti e barre di errore (geom_pointrange, o una combinazione di geom_point e geom_linerange), eventualmente rappresentati come rettangoli (geom_crossbar) rappresentazione delle relazioni quantitative fra 2 o più variabili quantitative (correlazione, relazione funzionale) o qualitative (distribuzione in gruppi): grafici a dispersione (scatterplot, geom_point), arricchiti con una varietà di altri elementi (colore, dimensione e forma dei punti) sono letteralmente il cavallo da lavoro della grafica scientifica e possono essere combinati con altre rappresentazioni (come le curve di interpolazione, gli smoothers, le curve di regressione) annotazioni rappresentanti l’andamento della relazione fra due variabili possono essere ottenute con geom_smooth che permette di usare smoothers parametrici e non parametrici o linee di regressione annotazioni rappresentanti la distribuzione bivariata possono essere ottenute con stat_ellipse (che permette di ottenere ellissi di confidenza) e stat_density2d 6.8.1 Istogrammi e altre rappresentazioni della densità. In molti casi, quello che ci interessa è mostrare la distribuzione di una singola variabile continua, per mostrarne i valori più frequenti, il range e, in qualche caso, per verificare se, in realtà si tratti di una distribuzione di valori estratti da più di una popolazione. Per costruire un istogramma l’intervallo dei valori viene diviso in tanti piccoli contenitori (bin), delimitanti intervalli più piccoli, di solito di dimensioni uguali, e si contano le osservazioni che ricadono in ogni singolo contenitore. Ovviamente, ha poco senso farlo quando si dispone di poche osservazioni (diciamo &lt;20). D’altra parte, quando si dispone di moltissime osservazioni potrebbe essere opportuno usare approssimazioni a distribuzioni continue, che potrebbero mostrare meglio la forma della distribuzione. Per questa piccola dimostrazione (e per altre relative alle distribuzioni di densità) userò alcuni data set: ggplot2::mpg ggplot1::diamonds datasets::iris MASS::survey Puoi usare l’aiuto per saperne di più. Cominciamo con i diamanti (i migliori amici delle ragazze). Prova, da sol*, a leggere l’aiuto di questo data set. Nel frattempo ecco la distribuzione del peso di circa 50.000 diamanti in carati. Nota come nella Figura 6.14 ho cambiato il valore di default del numero di bin (da 30 a 1000) data(&quot;diamonds&quot;) dfpoly &lt;- ggplot(data = diamonds, aes(x=carat)) dfpoly + geom_histogram(bins = 100) + labs(x = &quot;peso in carati&quot;, y = &quot;conta&quot;, title = &quot;distribuzione del peso in carati di diamanti&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Figura 6.14: Un istogramma mostrante la distribuzione del peso in carati di oltre 50000 diamanti La figura non è molto informativa: la scala dell’asse delle x è molto lunga ma, dato il numero ridottissimo di diamandi di grandi dimensioni è difficile apprezzare bene la distribuzione, anche se è chiaro che ci sono diverse sottopopolazioni. Una soluzione, in questo caso, potrebbe essere quella di trasformare uno degli assi. Prova questo piccolo trucco, che ti consente di usare una scala logaritmica per l’asse delle y e, contemporaneamente di usare dei tickmark appropriati144. dfpoly + geom_histogram(bins = 100) + labs(x = &quot;peso in carati&quot;, y = &quot;conta&quot;, title = &quot;distribuzione del peso in carati di diamanti&quot;) + scale_y_log10() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Noterai come il risultato è po’ meglio e un po’ peggio: trasformare le scale può rendere più difficile l’interpretazione, ma almeno qui si vedono i valori delle conte dei diamanti più grandi (una gran bella soddisfazione). Ovviamente, si può fare di meglio: possiamo annotare meglio le scale, cambiarne lo stile e usare un tema diverso (così iniziamo a fare pratica con le annotazioni). dfpoly + geom_histogram(bins = 100) + labs(x = &quot;peso in carati&quot;, y = &quot;conta&quot;, title = &quot;distribuzione del peso in carati di diamanti&quot;) + scale_y_log10(limits = c(1,10^4), breaks = scales::trans_breaks(&quot;log10&quot;, function(x) 10^x), labels = scales::trans_format(&quot;log10&quot;, scales::math_format(10^.x))) + scale_x_continuous(breaks = seq(0,5,0.5), minor_breaks = seq(0,5,0.1)) + annotation_logticks(sides = &quot;l&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) (#fig:log_carat_histo_2)Uso di scale logaritmiche: un’istogramma della dimensione di diamanti in carati. Prova qui per saperne molto di più sulle annotazioni di scale trasformate. Naturalmente, geom_histogram() capisce molti altri estetici, come fill e alpha. Prova questo codice che vedere anche la distribuzione del taglio (cut): dfpoly + geom_histogram(aes(fill = cut), bins = 100) + labs(x = &quot;peso in carati&quot;, y = &quot;conta&quot;, fill = &quot;taglio&quot;, title = &quot;distribuzione del peso in carati di diamanti&quot;) + scale_y_continuous(limits = c(0,6000), minor_breaks = seq(0,6000,200)) + scale_x_continuous(breaks = seq(0,5,0.5), minor_breaks = seq(0,5,0.1)) + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Oppure, prova ad aggiungere delle facet dfpoly + geom_histogram(bins = 100) + facet_grid(cut ~ clarity) + labs(x = &quot;peso in carati&quot;, y = &quot;conta&quot;, fill = &quot;taglio&quot;, title = &quot;distribuzione del peso in carati di diamanti, in funzione di taglio e chiarezza&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Un’applicazione interessante è aggiungere una funzione di densità teorica di probabilità all’istogramma. Proviamo con dei dati biologici, come l’altezza di studenti (che è più probabile siano normalmente distribuita). Qui usiamo MASS::survey. Qui ho anche aggiunto linee che mostrano la media (linea verticale continua) e ±sd (deviazione standard, linee tratteggiate). data(&quot;survey&quot;) male_students &lt;- dplyr::filter(survey, Sex == &quot;Male&quot; &amp; !is.na(Height)) ggplot(male_students) + geom_histogram(aes(x = Height, y = after_stat(density)), bins = 10) + stat_function(fun = dnorm, args = list(mean = mean(male_students$Height), sd = sd(male_students$Height))) + geom_vline(xintercept = mean(male_students$Height)) + geom_vline(xintercept = c(mean(male_students$Height)-sd(male_students$Height), mean(male_students$Height)+sd(male_students$Height)), linetype = I(2)) + labs(x = &quot;altezza, cm&quot;, y = &quot;densità&quot;) + theme_bw() (#fig:isto_norm)Istogramma e funzione di densità di probabilità per l’altezza di studenti universitari di sesso maschile Un’alternativa agli istogrammi sono i poligoni di frequenza. Il principio è lo stesso ma, invece di avere una serie di barre, una linea spezzata collega i punti corrispondenti alla conta delle osservazioni per ogni bin. Un vantaggio rispetto agli istogrammi è che è più facile sovrapporre diversi gruppi, magari usando colori diversi. dfpoly &lt;- ggplot(data = diamonds, aes(x=carat)) dfpoly + geom_freqpoly(aes(colour = cut)) + ggtitle(&quot;Distribuzione del peso di diamandi, carati, per diamanti con qualità di taglio diverso&quot;) + labs(x = &quot;carati&quot;, y = &quot;conta&quot;) + scale_colour_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Figura 6.15: Un esempio di poligoni di frequenza (la distribuzione del peso di diamanti di tagli diversi) Invece dei poligoni di frequenza (che al massimo possono usare linee di diverso colore, spessore o stile) è possibile usare grafici ad area (che possono usare riempimenti diversi). Nota che in questo caso stat = \"bin\" è usato per ottenere conte corrispondenti ai vari bin e position=\"stack\" è usato per impilare le conte. Prova a chiederti come è stato ottenuto l’ordine dei diversi livelli del taglio (cut). Prova anche, che non guasta mai, ad interpretare il grafico. dfpoly + geom_area(aes(fill= cut), stat = &quot;bin&quot;, position = &quot;stack&quot;) + ggtitle(&quot;Distribuzione del peso di diamandi, carati, in funzione del taglio&quot;) + labs(x = &quot;carati&quot;, y = &quot;conta&quot;) + scale_fill_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Figura 6.16: Un diagramma ad area impilata della distribuzione del peso di diamanti di taglio diverso in carati. Un equivalente 2D degli istogrammi sono le heatmap, che usano una gradazione di colore per rappresentare conte o densità diverse. Qui approfitto per mostrare come applicare una facet per taglio e usare una scala logaritmica per le conte. Vale appena la pena di ricordare che le gradazioni di colore non sono il modo migliore per fare confronti quantitativi. ggplot(diamonds, aes(x= carat, y = price)) + geom_bin2d(bins = c(20,20)) + facet_grid(~ cut) + ggtitle(&quot;distribuzione dei diamanti, per prezzo e peso in carati&quot;) + scale_fill_gradientn(colours = heat.colors(10), trans = &quot;log1p&quot;, breaks = scales::trans_breaks(&quot;log10&quot;, function(x) 10^x)) + labs(title = &quot;distribuzione dei diamanti, per prezzo e peso in carati&quot;, x = &quot;Prezzo, US$&quot;, y = &quot;Peso, carati&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;)) Figura 6.17: Un esempio di heatmap (mappa di calore). Approssimazioni continue della densità (in una o due dimensioni) possono essere ottenute utilizzando delle stime kernel della densità, con metodi parametrici o non parametrici: si tratta di funzioni che utilizzano la densità locale dei punti per ottenere una linea continua che approssima la densità145. ggplot2 consente di usare diversi kernel; il kernel di default è “gaussian”, ma altre opzioni sono, per esempio “epanechnikov”, “rectangular”, “triangular”. Confronta la figura successiva con l’istogramma o il poligono di frequenza delle figure 6.14 e 6.15. dfpoly + geom_density(aes(colour = cut), kernel = &quot;e&quot;) + labs(x = &quot;peso in carati&quot;, y = &quot;densità&quot;, colour = &quot;taglio&quot;) + scale_colour_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) + theme_bw() (#fig:densita_continua)Un grafico a desità della dimensione in carati di diamanti, per diamanti di taglio diverso. Prova in uno script o nella console il codice successivo per ottenere delle rappresentazioni in 2D e pensa a come migliorarle (p.es. cambiando le scale come mostrato negli esempi precedenti). Nota anche come qui ho usato un valore di trasparenza molto basso e una dimensione dei simboli molto piccola: questa pratica può essere conveniente quando ci sono moltissimi punti e si vuole mantenere una sensazione della densità senza rendere il grafico troppo “pesante”. # un grafico a dispersione con due rappresentazioni della densità: # dei rug plot sugli assi e un contour plot # prova a sperimentare con vari valori di n in geom_density_2d ggplot(dplyr::filter(diamonds, carat&lt;3), aes(x= carat, y = price)) + geom_point(size = I(0.05), alpha = 0.1) + geom_rug(sides = &quot;bl&quot;, alpha = 0.005) + geom_density_2d(n = 100, colour = &quot;red&quot;) + labs(x = &quot;peso in carati&quot;, y = &quot;densità&quot;) + theme_bw() # qui escludo i diamanti più grandi che sono pochissimi ggplot(dplyr::filter(diamonds, carat&lt;1.5, price &lt;5000), aes(x= carat, y = price)) + geom_density_2d_filled(alpha = 0.5, contour_var = &quot;count&quot;) + scale_x_continuous(limits = c(0,1.5), breaks = seq(0,1.5,0.1), minor_breaks = seq(0,3, 0.1))+ labs(x = &quot;peso in carati&quot;, y = &quot;prezzo, US$&quot;) + theme_bw() # un&#39;altra possibilità è usare una scala continua ggplot(dplyr::filter(diamonds, carat&lt;1.5, price &lt;5000), aes(x= carat, y = price)) + stat_density_2d_filled(geom = &quot;raster&quot;, aes(fill = after_stat(density)), contour = FALSE, n=200 ) + scale_fill_viridis_b(direction = -1, option = &quot;C&quot;)+ scale_x_continuous(limits = c(0,1.5), breaks = seq(0,1.5,0.1), minor_breaks = seq(0,3, 0.1))+ labs(x = &quot;peso in carati&quot;, y = &quot;prezzo, US$&quot;) + theme_bw() 6.8.2 Boxplot. I boxplot (o più propriamente, box and whiskers plots, che in italiano si traduce grafico a scatole e baffi) e le loro variazioni sono un altro modo per rappresentare la distribuzione delle osservazioni, oltre che per mostrare alcuni utili indicatori non parametrici (la mediana, il range interquartile vedi capitolo 7). Boxplot assolutamente dignitosi possono essere ottenuti usando la funzione boxplot() della grafica di base. La funzione geom_boxplot() fornisce flessibilità addizionale ma ha anche alcune particolarità noiose (richiede sia una variabile x, di solito qualitativa, che una variabile y, quantitativa, quella per la quale interessa analizzare la distribuzione). survey_dati_completi &lt;- survey %&gt;% tidyr::drop_na() ggplot(survey_dati_completi, aes(x=Sex, y=Height)) + geom_boxplot() + labs( title = &quot;Altezza in cm di studenti della Univ. Adelaide&quot;, caption = &quot;Venables, W. N. and Ripley, B. D. (2002) Modern Applied Statistics with S-PLUS. Fourth Edition. Springer.&quot;, x = &quot;Sesso&quot;, y = &quot;Altezza, cm&quot;) + scale_x_discrete(&quot;Sesso&quot;, labels = c(&quot;Female&quot; = &quot;Femmine&quot;, &quot;Male&quot; = &quot;Maschi&quot;)) + theme(plot.title = element_text(hjust = 0.5)) Figura 6.18: Distribuzione dell’altezza di studenti di psicologia dell’Università di Adelaide. La Figura 6.18 mostra un piccolo esempio creato usando il dataset MASS::survey. Sono evidenti gli elementi principali del box plot: la linea spessa orizzontale centrale mostra la mediana delle osservazioni (il secondo quartile, Q2) il box è delimitato dal 25° e 75° percentile (quantili Q1 e Q3); il range interquartile (IQR) si calcola facilmente come Q3-Q1 e, ovviamente, contiene il 50% delle osservazioni i “baffi” (le due linee che partono dal box) sono lunghi al più 1,5*IQR eventuali osservazioni che eccedono l’intervallo delimitato dai baffi sono rappresentate come cerchi neri pieni e, tendenzialmente, indicano dei valori estremi o outlier In sostanza, il box plot è ottenuto usando le statistiche che si possono ricavare dalla funzione fivenum(). Vale appena la pena di aggiungere che non ha molto senso usare un box plot con un numero ridotto di osservazioni (diciamo che già 10 possono essere pochine). Come esercizio mentale prova a pensare quali informazioni puoi ricavare da un box plot (e da questo in particolare) e in che modo ti possono servire a confrontare distribuzioni di un singolo gruppo di osservazioni o di più gruppi di osservazioni. Prova ora le seguenti opzioni (copiando il codice usato per generare la figura in uno script e cambiando i comandi): trasponi il grafico aggiungendo coord_flip() (può essere utile quando le etichette dell’asse delle x sono lunghe, anche se è possibile lavorare su questo aspetto usanto theme())146; prova ad aggiungere l’opzione geom_boxplot(notch = T) per aggiungere un intervallo di confidenza alla mediana (delimitato dalla zona a clessidra o da “spine” triangolari che si estendono oltre il range interquartile prova ad aggiungere colori dei bordi e riempimenti (in questo caso sono assolutamente inutili, ma potrebbero essere di qualche utilità se si desidera confrontare gruppi diversi delimitati da una seconda variabile qualitativa all’interno dei gruppi delimitati dalla variabile x) Un box plot può essere arricchito di molti altri elementi: le singole osservazioni, con una bassa trasparenza, in modo da poter avere una rappresentazione fedele della loro distribuzione un violin plot (che, in pratica, usa geom_density per ottenere una rappresentazione non parametrica della densità), in modo da poter evidenziare eventuali distribuzioni multimodali ed esaltare la presenza di asimmetrie nella distribuzione ggplot(survey_dati_completi, aes(x=Sex, y=Height)) + geom_violin() + geom_boxplot(width = 0.4, colour = &quot;blue&quot;, notch = T) + geom_jitter(colour = I(&quot;blue&quot;), alpha = I(0.2), width = 0.2) + labs( title = &quot;Altezza in cm di studenti della Univ. Adelaide&quot;, caption = &quot;Venables, W. N. and Ripley, B. D. (2002) Modern Applied Statistics with S-PLUS. Fourth Edition. Springer.&quot;, x = &quot;Sesso&quot;, y = &quot;Altezza, cm&quot;) + scale_x_discrete(&quot;Sesso&quot;, labels = c(&quot;Female&quot; = &quot;Femmine&quot;, &quot;Male&quot; = &quot;Maschi&quot;)) + theme(plot.title = element_text(hjust = 0.5)) Figura 6.19: Combinazione di box plot, violin plot e jitter plot. Ulteriori effetti “speciali” possono essere ottenuti con diverse estensioni di ggplot2; ggstatsplot, ggpubr, ggbeeswarm sono solo tre esempi. Per finire, questa cosa di cambiare le etichette per fare tutto in italiano sta diventando noiosa. Da adesso in poi, visto che hai sicuramente capito come si fa, lascerò tutto in inglese. 6.8.3 Rappresentazioni di indicatori di tendenza centrale e di variabilità. In diversi casi lo scopo di chi costruisce la visualizzazione dei dati è mostrare qualche indice di tendenza centrale (tipicamente la media o la mediana) accompagnato da un indice di dispersione, che mostri la variabilità o l’incertezza, spesso per più gruppi di osservazioni. ggplot2 offre una varietà di alternative che richiedono in genere una variabile x qualitativa, una variabile y quantitativa e dei valori di ymin e ymax che indicano i limiti inferiore e superiore dell’intervallo che rappresenta incertezza o variabilità. Per questo esempio userò ancora iris, anticipando alcune funzioni per calcolare statistiche riassuntive su gruppi di dati (vedi 7). Approfitto per mostrare l’uso di str_wrap, una funzione del pacchetto stringr, incluso nel tidyverse, utile per mandare a capo del testo molto lungo: # uso funzioni di `dplyr` per calcolare statistiche per gruppi con `summarise` # devst è la deviazione standard, IQR il range interquartile e n_oss il # numero di osservazioni, q25 e q75 il 25° e 75° quantile data(&quot;iris&quot;) iris_stat &lt;- iris %&gt;% group_by(Species) %&gt;% dplyr::summarise(mediaPW = mean(Petal.Width), medianaPW = median(Petal.Width), devstPW = sd(Petal.Width), q25 = quantile(Petal.Width, 0.25), q75 = quantile(Petal.Width, 0.75), n_oss = n()) # calcolo errore standard e limiti inferiori e superiori dell&#39;intervallo di # confidenza usando alpha = 0.05 # con gdl = n_oss-1 gradi di libertà alpha = 0.05 iris_stat &lt;- iris_stat %&gt;% mutate(errstPW = devstPW/sqrt(n_oss), gdl = n_oss-1) %&gt;% mutate(conf_min = mediaPW-qt(alpha/2, df = gdl, lower.tail = F)*errstPW, conf_max = mediaPW+qt(alpha/2, df = gdl, lower.tail = F)*errstPW ) # nota come è possibile anche ottenere l&#39;intervallo di confidenza della media # con t.test() ma occorre estrarre i risultati dalla lista ottenuta con il test # uso geom_point range con l&#39;intervallo di confidenza ggplot(iris_stat, aes(x = Species)) + geom_pointrange(aes(y = mediaPW, ymin = conf_min, ymax = conf_max), size = I(0.2)) + labs(x = &quot;Specie&quot;, y = str_wrap(&quot;Larghezza dei petali, media con intervallo di confidenza, alpha = 0.05&quot;, 50)) Figura 6.20: Rappresentazioni di indicatori di tendenza centrale e variabilità Prova ora a sostituire geom_pointrange con geom_crossbar, geom_linerange, geom_errobar (dopo aver dato uno sguardo all’aiuto, naturalmente). Prova anche a sostituire altri valori di y (mediana invece di media, per esempio) o dell’intervallo mostrante la variabilità (media ± deviazione standard, etc.) Un modo comune per fare la stessa cosa e sprecare molto inchiostro (virtuale) è usare una versione del grafico a barre che non usa conte, ma il valore fornito dalla variabile y, geom_col. Prova questo codice: # qui uso il colore ma sopprimo la legenda, perché inutile ggplot(iris_stat, aes(x = Species, y = mediaPW)) + geom_linerange(aes(ymin = conf_min, ymax = conf_max)) + geom_col(aes(fill = Species), alpha = 0.5, show.legend = F) + labs(x = &quot;Specie&quot;, y = str_wrap(&quot;Larghezza dei petali, media con intervallo di confidenza, alpha = 0.05&quot;, 50)) 6.8.4 Grafici a dispersione. I grafici a dispersione (scatterplot in inglese) sono il cavallo da tiro della visualizzazione scientifica dei dati. Sono usati principalmente per mostrare le relazioni fra due variabili continue. Variabili qualitative possono essere attribuite a vari elementi del grafico, come forme, colori (di bordo o riempimento), tipi di linea, facets. Altre variabili quantitative possono essere attribuite a colori e dimensioni (inclusi gli spessori delle linee). Linee di tendenza parametriche o non parametriche possono essere aggiunte con geom_smooth(). Per gli esempi userò alcuni dei data set già utilizzati in questo capitolo, ma potresti provare a usare dati dal pacchetto gapminder o uno dei numerosi data set di R o dei pacchetti. In ggplot2 il geoma che genera grafici a dispersione è geom_point(). Cominciamo con un esempio semplice semplice usando il classico data set Iris. Qui viene mostrata la relazione fra lunghezza e larghezza dei sepali per tre specie di Iris. Nota l’uso della pipe, %&gt;%, un’operatore creato dal pacchetto magrittr che viene caricato con il tidyverse, per passare i dati alla funzione ggplot() . irisggplot &lt;- iris %&gt;% ggplot(aes(x=Sepal.Length, y=Sepal.Width, shape = Species, colour = Species)) + geom_point() irisggplot Figura 6.21: Un semplice grafico a dispersione Semplice e senza fronzoli, no? Prova a pensare come potresti abbellire questo grafico usando i comandi presentati nelle sezioni precedenti. Prova anche a pensare come potresti rendere più evidenti (ricordati che una rappresentazione grafica di dati scientifici racconta una storia) alcuni aspetti biologicamente interessanti: la divisione in gruppi la relazione fra le due variabili Cominciamo ad aggiungere cose: prova questo codice (devi aver fatto girare quello di prima, se no non funziona: perché?): # un rugplot irisggplot + geom_rug(sides = &quot;tr&quot;) # uno smoother non parametrico diverso per ciascuno dei gruppi irisggplot + geom_rug(sides = &quot;tr&quot;) + geom_smooth() geom_smooth()è una delle funzioni più utili di ggplot2 quando si voglia evidenziare il trend dei dati. Ti consiglio vivamente di approfondire leggendo l’aiuto e studiando gli esempi. Qui ripropongo lo più o meno lo stesso codice aggiungendo un ulteriore strato con una regressione lineare e rimuovendo gli intervalli di confidenza e il rug plot: irisggplot + geom_smooth(se = F, linewidth = I(0.5)) + geom_smooth(method = &quot;lm&quot;, formula = y ~ x, se = F, linetype = I(2), linewidth = I(0.5)) Anche qui: prova ad interpretare il grafico: in che cosa questa rappresentazione dei dati migliora la tua comprensione del fenomeno biologico? Per esempio: i gruppi corrispondenti alle diverse specie sono ben separati? esiste una relazione fra le due variabili? É credibile che si tratti di una relazione lineare (anche se quest’ipotesi potrebbe essere dimostrata in maniera più efficace con un test inferenziale) Bene, ora proviamo a fare le cose per bene: aggiungo anche una rappresentazione della densità parametrica, le ellissi di confidenza. irisggplot + geom_smooth(se = F, linewidth = I(0.5)) + geom_smooth(method = &quot;lm&quot;, formula = y ~ x, se = F, linetype = I(2), linewidth = I(0.5)) + stat_ellipse( type = &quot;t&quot;, level = 0.95, linewidth = I(0.5) ) Figura 6.22: Un grafico a dispersione con smoother nn parametrico (loess) linee di regressione e ellissi di confidenza I parametri di default di stat_ellipse generano l’ellisse usando una distribuzione t di Student bivariata; è possibile usare type = \"norm\" per ottenere una distribuzione bivariata normale. C’è un po’ di dibattito sul fatto che il metodo scelto da ggplot2 generi effettivamente un’ellisse di confidenza. In ogni caso le cose che dovresti guardare sono: la dimensione dell’ellisse è in relazione con la variabilità dei dati (varianza della media o del campione); guardando la dimensione relativa ai due assi è possibile vedere quale delle due variabili ha una varianza maggiore l’inclinazione dell’ellisse è in relazione con la covarianza o la correlazione fra le variabili (se l’asse maggiore è molto inclinato la correlazione o la covarianza sono maggiori; se l’ellisse si approssima ad un cerchio le due variabili non sono correlate) Ora cambiamo data set per dimostrare alcune altri aspetti interessanti dei grafici a dispersione. ggplot2::mpg è un buon punto di partenza per la combinazione di variabili qualitative e quantitative. Userò una versione filtrata del data set perché, come richiamato nella sezione 6.2 non è opportuno usare troppe combinazioni diverse di colori e simboli. Cominciamo per dimostrare come una terza variabile quantitativa possa essere attribuita al colore (deve essere una variabile continua!) o alla dimensione del simbolo). In questo caso forzeremo un po’ la scelta dei simboli. Ah dimenticavo, R ti permette di usare 25 simboli grafici diversi, oltre alle lettere dell’alfabeto: se vuoi una lista cerca sul web o, meglio ancora, usa questi comandi install.packages(&quot;ggpubr&quot;) # necessario solo se non è già presente nella libreria library(ggpubr) ggpubr::show_point_shapes() Nota anche qui l’uso della funzione filter del pacchetto dplyr per selezionare in modo facile solo una parte delle osservazioni del data frame (le 6 classi di veicoli più numerose). Ricorda anche come gli estetici possono essere passati nel primo strato (quello con ggplot), e in questo caso sono ereditati dai geomi successivi, oppure direttamente nei geomi. Visto che ci siamo, mostro come si possa cambiare la posizione della legenda e il numero di colonne di alcuni elementi della legenda. Nel primo grafico in cui la dimensione del simbolo è in funzione della cilindrata e il colore in funzione del tipo di carburante, una variabile qualitativa; cambio i simboli con scale_shape_manual(), creando un vettore con nomi con le forme che voglio usare (cerchi, triangoli, quadrati, rombi). mpg_ridotto &lt;- mpg %&gt;% dplyr::filter(class %in% c(&quot;compact&quot;, &quot;midsize&quot;, &quot;subcompact&quot;, &quot;suv&quot;)) mpg_layer_base &lt;- ggplot(mpg_ridotto, mapping = aes(x=cty, y = hwy)) my_shapes &lt;- c(&quot;compact&quot; = 16, &quot;midsize&quot; = 17, &quot;subcompact&quot; = 15, &quot;suv&quot; = 18) mpg_cty_hwy_displ &lt;- mpg_layer_base + geom_point(aes(shape = class, size = displ, colour = fl)) + scale_shape_manual(values = my_shapes) + scale_colour_brewer(type = &quot;qual&quot;, palette = &quot;Paired&quot;) + labs(title = &quot;geom_point&quot;) + guides(size = guide_legend(ncol = 2), colour = guide_legend(ncol = 2)) + theme_bw() + theme(plot.title = element_text(hjust = 0.5), legend.position = &quot;right&quot;) mpg_cty_hwy_displ Figura 6.23: Un bubble plot Semplice, no? Questo grafico si chiama bubble plot ed è molto utilizzato, anche se la nostra capacità di comparare aree non è proprio il massimo. La relazione fra il consumo di carburante in città e in autostrada è praticamente lineare. Sapresti come aggiungere un’unica linea di regressione? Nota anche come ci sia un problema di “overplotting” (molti punti si sovrappongono), per risolvere il quale uso geom_jitter(), che aggiunge un piccolo spostamento casuale sulle x e sulle y (rischiando ovviamente di perdere un po’ di precisione). Infine, uso le scale del pacchetto viridis che forniscono gradienti ottimizzati per il daltonismo. mpg_cty_hwy_displ_2 &lt;- mpg_layer_base + geom_jitter(aes(shape = class, colour = displ)) + scale_shape_manual(values = my_shapes) + scale_colour_viridis(option = &quot;B&quot;) + labs(title = &quot;geom_jitter&quot;) + theme_bw() + theme(plot.title = element_text(hjust = 0.5), legend.position = &quot;bottom&quot;) mpg_cty_hwy_displ_2 *** Beh, nel frattempo ti starai chiedendo: e i grafici a dispersione in 3 dimensioni? Dimenticali, per molte ragioni è difficile estrarre informazioni quantitative affidabili da un grafico in 3D, specialmente se aggiungi colori, gradazioni, dimensioni, superfici etc. Ovviamente, se proprio insisti a volerli realizzare puoi cercare in una delle risorse che ti propongo nella sezione 6.10. Proviamo ora a spostare la variabile class sulle facet e usare il numero di cilindri per la forma dei simboli: prova a chiederti perché devo trasformare questa variabile in un fattore. mpg_cty_hwy_displ_3 &lt;- mpg_layer_base + facet_wrap(~class) + geom_jitter(aes(colour = displ, shape = as.factor(cyl))) + scale_colour_viridis(option = &quot;B&quot;) + labs(title = &quot;geom_jitter e facets&quot;, shape = &quot;cyl&quot;) + scale_shape_manual(values = c(16,17,15,18)) + theme(plot.title = element_text(hjust = 0.5)) mpg_cty_hwy_displ_3 Figura 6.24: Grafico a dispersione con facets. Insomma, ci sarebbe ancora molto da vedere, soprattutto in termini di geomi e annotazioni ma credo sia più semplilce e meno stancante mostrare nuovi esempi man mano che andiamo avanti. Incidentalmente, prova ad esplorare geom_text e geom_label, due interessanti alternative per etichettare i punti in un grafico a dispersione (che purtroppo possono rendere i grafici piuttosto ingarbugliati). Se hai fretta puoi cercare in una delle molte eccellenti risorse che ti propongo nella sezione 6.10. 6.8.5 Personalizzare i grafici con ggplot2. ggplot2 e le sue estensioni (vedi dopo) permettono un livello di personalizzazione veramente eccezionale dei grafici. Il modo più semplice per cambiare in gruppo una serie di elementi (assi, sfondo, etc.), è usare i temi. Prova per esempio a personalizzare l’ultimo grafico variando i temi: mpg_cty_hwy_displ_3 + theme_bw() mpg_cty_hwy_displ_3 + theme_classic() mpg_cty_hwy_displ_3 + theme_dark() mpg_cty_hwy_displ_3 + theme_light() mpg_cty_hwy_displ_3 + theme_minimal() Altri temi sono resi disponibili dall’estensione ggthemes. Inoltre, il comando theme() permette, come hai già visto, di cambiare praticamente tutti gli elementi (inclusi, fra le altre cose, orientazione e font delle etichette degli assi). I pacchetti addizionali come scales (che viene caricato con ggplot2) permettono di personalizzare in molti modi le scale come visto in alcuni esempi, e il comando annotate() permette di aggiungere uno strato con annotazioni (testo, segmenti, persino geomi). Insomma, tanta roba e qui non abbiamo spazio-tempo e, forse, non ne vale la pena: potrai sempre cercare fra le risorse che ti propongo (6.10) o semplicemente sfruttare una delle strategie per cercare aiuto in rete proposte nel 3. 6.8.6 Estensioni per ggplot2. Molti altri pacchetti forniscono funzionalità aggiuntive a ggplot2 o permettono di usare come input oggetti diversi dai dataframe (come alcune classi di oggetti prodotti da analisi statistiche). Una lista completa delle estenisoni è disponbile qui. Alcune estensioni sono state citate nei paragrafi precedenti. 6.8.7 Veloce veloce: qplot() Il comando qplot forniva, nelle versioni di ggplot2 precedenti alla 3.4, un’interfaccia rapida per la produzione di grafici in un solo comando. Nonostante questo comando sia deprecato (cioé non verrà più sviluppato a partire da questa versione) è ancora attivo, anche se genera degli avvisi (warning). La struttura generica dei comandi qplot è: qplot(x, y, ..., data, facets,margins, geom, xlim, ylim, log, main, xlab, ylab, asp) Molti di questi parametri hanno dei default e, tecnicamente, qplot è in grado di proporre il geom più adatto ad una data tipologia di dati, in base alla presenza/assenza delle variabili x e y e alla loro natura (qualitativa o quantitativa). Prova ad eseguire, nella console o in uno script, questi comandi # uno scatterplot (generato in automatico perché x e y sono quantitative) data(mpg) qplot(x = displ, y = hwy, data = mpg) # con qualche personalizzazione in più qplot(x = displ, y = hwy, shape = factor(cyl), data = mpg) # un barplot (il default per una sola variabile x qualitativa) qplot(x = class, data = mpg) # un istogramma (il default per una sola variabile x quantitativa) qplot(x = displ, data = mpg) # diventa un density plot se si indica il geoma qplot(x = displ, data = mpg, geom = &quot;density&quot;) # con facets qplot(x = displ, data = mpg, geom = &quot;density&quot;, facets = ~factor(cyl)) # altri estetici e etichette e titoli, qplot(displ, hwy, data = mpg, colour = factor(cyl), main = &quot;cilindrata e consumo in autostrada&quot;, xlab = &quot;cilindrata&quot;, ylab = &quot;miglia per gallone in autostrada&quot;) # un bubble plot qplot(displ, hwy, data = mpg, colour = factor(cyl), size = cty) # una combinazione di grafici qplot(class, hwy, data = mpg, geom = c(&quot;jitter&quot;, &quot;boxplot&quot;), alpha = I(0.6)) qplot(displ, hwy, data = mpg, geom = c(&quot;point&quot;, &quot;smooth&quot;)) Prova ad esplorare tu stess* con altre opzioni e combinazioni o a realizzare i grafici ottenuti nei paragrafi precedenti con ggplot. Ti renderai conto che qplot permette di ottenere scrivendo molto meno codice dei grafici accettabili per la fase esplorativa, ma che la flessibilità di ggplot è molto superiore. 6.9 La grafica di base in R: un salvagente? La grafica di base di R usa un numero limitato di funzioni per costruire visualizzazioni di dati. Esempi di queste funzioni sono: barplot(), costruisce barplot boxplot(), costruisce boxplot histogram(), costruisce istogrammi plot(), costruisce grafici a dispersione (e molto altro) pairs(), costruisce matrici di grafici a dispersione mosaicplot() grafici a mosaico Mentre i nomi delle funzioni possono essere intuitivi, i loro parametri sono molto difficili da memorizzare, anche se, come per ggplot2, consentono una personalizzazione molto fine della visualizzazione. Inoltre, realizzare grafici con diversi gruppi è spesso laborioso, perché occorre sovrapporre grafici diversi che usano ciascuno i punti del gruppo da plottare. Mostro qui solo due esempi. La figura 6.25 è un diagramma a barre che mostra i dati del data set Arthritis. E’ l’equivalente della Figura 6.10: # bisogna prima ricavare la tabella delle conte Arthritis_tabulazione &lt;- xtabs( ~ Improved + Treatment, data = Arthritis) # poi lo strato ocn il barplot barplot(Arthritis_tabulazione, col = rainbow(3), ylim = c(0,50)) # poi la legenda legend(x = &quot;top&quot;, legend = levels(Arthritis$Improved), pch = 15, col = rainbow(3), ncol = 3) Figura 6.25: Un grafico a barre realizzato con la grafica di base La figura 6.26 è invece analoga alla figura 6.22. Nota come qui i diversi gruppi sono aggiunti uno dopo l’altro allo strato di base: # puoi farti un&#39;idea del range ideale con # range(iris$Sepal.Length) # range(iris$Sepal.Width) plot(Sepal.Length ~ Sepal.Width, data = subset(iris, Species == &quot;setosa&quot;), pch = 16, col = &quot;red&quot;, las = 1, xlab = &quot;larghezza dei sepali&quot;, ylab = &quot;lunghezza dei sepali&quot;, main = &quot;relazione fra larghezza e lunghezza dei sepali in tre specie di Iris&quot;, xlim = c(2,5), ylim = c(4,8)) abline(lm(Sepal.Length ~ Sepal.Width, data = subset(iris, Species == &quot;setosa&quot;)), col = &quot;red&quot;, lty = 1) points(Sepal.Length ~ Sepal.Width, data = subset(iris, Species == &quot;versicolor&quot;), pch = 17, col = &quot;blue&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, las = 1) abline(lm(Sepal.Length ~ Sepal.Width, data = subset(iris, Species == &quot;versicolor&quot;)), col = &quot;blue&quot;, lty = 2) points(Sepal.Length ~ Sepal.Width, data = subset(iris, Species == &quot;virginica&quot;), pch = 15, col = &quot;cyan&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, las = 1) abline(lm(Sepal.Length ~ Sepal.Width, data = subset(iris, Species == &quot;virginica&quot;)), col = &quot;cyan&quot;, lty = 3) legend(x = &quot;bottomright&quot;, legend = levels(iris$Species), pch = c(16,17,15), col = c(&quot;red&quot;, &quot;blue&quot;, &quot;cyan&quot;)) Figura 6.26: Un grafico a dispersione realizzato con la grafica di base Perché fare tutta questa fatica per un risultato francamente bruttino? Beh, in molti casi i comandi della grafica di base di R consentono di ottenere delle visualizzazioni decenti con poco codice. Poi, e soprattutto, plot() è una funzione generica e serve a ottenere grafici specializzati da molti oggetti ottenuti da analisi statistiche. Prova il codice successivo, che permette di ottenere una in automatico i grafici che rappresentano i diagnostici dell’analisi della varianza per la lunghezza dei petali in iris: par(mfrow=c(2,2)) plot(aov(Petal.Length ~ Species, data = iris)) par(opar) Inoltre, molti pacchetti hanno funzioni che restituiscono grafici costruiti con la grafica di base (o, se è per questo, con lattice) e può tornare utile saperne qualcosina per poterli personalizzare al meglio (anche se, pian pianino, le estensioni di ggplot2 stanno rendendo più semplice il lavoro di rappresentare graficamente oggetti anche complessi derivanti da analisi statistiche). Comunque, vedremo diversi esempi più avanti. 6.10 Altre risorse. Il materiale in questo capitolo è presentato in molte delle risorse citate nel capitolo 4. In Italiano non c’è granché, se non la wiki Ricerca sociale con R. 6.10.1 Risorse in inglese. Di risorse sulla grafica (scientifica e per la data science) con R è pieno il mondo. In effetti, c’è solo da scegliere, e non è per niente facile. Riporto qui una selezione delle risorse che io ho trovato più utili. Un post interessante e visualmente molto ben organizzato sulla grammatica della grafica è qui. Documenti e pagine web. Libri: provate questi come sempre R for data science fornisce esempi ed esercizi interessanti i soliti libri introduttivi alla statistica e grafica con R (YaRrr!, Just enough R, etc.) un bel manuale dedicato a ggplot2 un libro molto completo sulla visualizzazione dei dati un libro di ricette per la grafica con R di R. Kabacoff: può essere un po’ noioso ma è ricchissmo di esempi e la sua organizzazione per tipologie di dati e grafici è utile per trovare rapidamente il tipo di grafico che fa per te; se te la senti, i molti libri di Edward Tufte, che spesso sono delle vere e proprie opere d’arte, o di Alberto Cairo. documenti e siti web: ovviamente, il sito di ggplot2 con link a tutto quello che vi può servire un interessante blog sulla grafica scientifica e non una bella gallery di grafici con R, forse con un po’ troppa pubblicità (ma è una buona fonte di ispirazione). Non dimenticate di dare uno sguardo alla pagina sui grafici interattivi la pagina di plotly, una library per grafici interattivi molto potente una cheatsheet interessante sull’uso dei colori in R http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf Video: un video grazioso sull’uso di grafici nella ricerca biologica un tutorial su ggplot2, parte 1 e parte 2 e d’altra parte, se sei un* student* di dottorato avrai sicuramente già letto qualche buon manuale di stile per la scrittura di articoli scientifici↩︎ in Italiano, al solito c’è poco, ma io trovo belli i libri di Emilio Matricciani, cercatelo in libreria o sulle principali piattaforme di vendita online.↩︎ in qualche modo, quando scriviamo o facciamo una presentazione vogliamo “intrattenere” il nostro pubblico e mantenerlo interessato, piuttosto che annoiarlo a morte↩︎ si veda Alberto Cairo, L’arte funzionale, Pearson↩︎ questa è una delle ragioni per cui usare troppi simboli diversi o troppi colori in un grafico scientifico, specialmente se deve essere mostrato per un tempo breve, non ha senso↩︎ Cleveland, W.S., McGill, R., 2012. Graphical Perception: Theory, Experimentation, and Application to the Development of Graphical Methods. J Am Stat Assoc 79, 531–554. https://doi.org/10.1080/01621459.1984.10478080↩︎ in RStudio i grafici compariranno nel riquadro Plots↩︎ viene installato come dependency da molti altri pacchetti importanti↩︎ oppure ad un file, vedi dopo↩︎ vedremo dopo che puoi agire con una certa precisione sulle dimensioni del device e, se lo desideri, dividerlo↩︎ una discussione molto chiara ed estensiva dei diversi formati è qui↩︎ però una descrizione dettagliata delle aree del device grafico è qui↩︎ prova a eseguire dev.size() e poi ridimensionare il plot pane ed eseguire di nuovo il comando↩︎ il segno + deve essere alla fine di ogni comando e non all’inizio della riga del comando successivo! Provare per credere!↩︎ deprecato significa che la funzione non viene più sviluppata negli aggiornamenti del pacchetto; tuttavia, le funzioni deprecate restano spesso disponibili, anche se possono generare dei messaggi di avviso (warning).↩︎ nota come i dati possono essere generati al volo, usando filtri, selezioni o applicando funzioni↩︎ altre possibilità, presenti nella grafica di base ma non in ggplot2, sono i diagrammi a torta e quelli a mosaico, vedi paragrafo 7.7.2↩︎ se proprio sei pigr*, alcune domande interessanti potrebbero essere: che tipo di miglioramento (variabile Improved) mostrano i due gruppi definiti dalla variabile Treatment? Il sesso e l’età dei pazienti hanno un effetto?↩︎ nota come in altri casi quando viene usato color, o colour, o fill da soli il colore viene attribuito al riempimento dell’elemento, p.es. il colore di un simbolo in un grafico a dispersione; se però si usano entrambi gli estetici, colour definisce il colore del bordo e fill il riempimento; nei diagrammi a barre bisogna esplicitamente indicare fill per il riempimento↩︎ per maggiori dettagli su cowplot clicca qui↩︎ potresti anche trasformare una delle variabili, come i carati, in log(carat), ma è sconsigliabile↩︎ se vuoi saperne di più leggi la relativa voce di Wikipedia in inglese↩︎ inoltre, è possibile ottenere versioni orizzontali di molti grafici generati con ggplot2 usando ggstance↩︎ "],["statdesc.html", "7 Esplorare con i numeri 7.1 Cosa c’è da imparare in questo capitolo. 7.2 Una piccola premessa: gruppi, livelli, sottoinsiemi. 7.3 Statistiche riassuntive per dati continui. 7.4 Altre funzioni utili. 7.5 Ma è normale? 7.6 Intervalli di confidenza. 7.7 Riassumere i dati per le variabili categoriche. 7.8 Veloce veloce 7.9 Altre risorse.", " 7 Esplorare con i numeri v1.1.1 5/11/2023 7.1 Cosa c’è da imparare in questo capitolo. In questo capitolo potrai imparare qualche concetto di base sull’a statistica descrittiva’analisi esplorativa dei dati e sui test delle ipotesi. In sostanza, quando abbiamo un insieme di dati, piccolo o grande che sia, il nostro scopo è, come minimo, descriverlo in maniera sintetica e cercare di estrarre informazioni che servano a supportare, contraddire o formulare ipotesi147. Nel capitolo 6 abbiamo visto come possiamo utilizzare diversi tipi di grafici per riassumere ed esplorare dati qualitativi o quantitativi, raggruppati o meno, e qualche funzione per calcolare statistiche riassuntive è già comparsa diverse volte. Come sempre cercherò di usare un approccio basato sull’uso degli strumenti, più “moderni”, del tidyverse, ma dovrò anche ricordare, quando possibile nelle note, l’uso delle funzioni di base. Infine, si assume che tu abbia una conoscenza almeno elementare della statistica: non mi soffermerò particolarmente sui concetti di statistica e parametro, campione e popolazione né sui pro e contro delle varie statistiche (descrittive)media, mediana, etc.). Se ne hai bisogno, suggerisco di fare riferimento alle numerose risorse più orientate alla statistica, segnalate nella sezione 7.9. Questo è un capitolo piuttosto corto (se ti sembra lungo è perché c’è parecchio codice), e credo tu possa fare uno sforzo per leggerlo tutto. In alternativa, ti consiglio una lettura delle Sezioni 7.3 e 7.7 “saltando” tutte le Sottosezioni che hanno titoli in corsivo. 7.2 Una piccola premessa: gruppi, livelli, sottoinsiemi. Quasi sempre, in una stessa tabella (data frame o tibble, ma lo stesso vale per altri tipi di oggetti a due dimensioni) troviamo osservazioni appartenenti a gruppi diversi (magari definiti, in maniera gerarchica148 da più variabili qualitative). In generale, una volta calcolate le statistiche riassuntive, ci può essere utile raccoglierle in una nuova tabella (che a sua volta potrebbe essere usata per nuove elaborazioni grafiche e statistiche), possibilmente in maniera tidy, vedi paragrafo 4.1.5. Le funzioni che useremo per riassumere ed esplorare i dati operano su vettori e tipicamente su vettori atomici, ma qualcuna opera su vettori generici, vedi sezione 4.4. Tutte restituiscono come risultato un valore singolo o un nuovo oggetto contenente più di un valore, che può essere stampato a console con il comando generico print(). Tuttavia, a noi interessa in genere riutilizzare i risultati o raccoglierli in una nuova tabella, che potrebbe a sua volta diventare l’oggetto di nuove elaborazioni. L’approccio che dobbiamo usare è quello di dividere il data set in gruppi, applicare la funzione e combinare i risultati in un nuovo oggetto (split - apply - combine). Farlo in maniera interattiva (operando nella console, un comando per volta) sarebbe lungho e soggetto ad errori. Per questo sia in R base, che nei pacchetti più antichi (come per esempio plyr, reshape e reshape2), che nei pacchetti più recenti (dplyr, purrr, broom), compaiono funzioni che in maniera rapida ed elegante fanno questo lavoro. Inoltre, altrettanto spesso siamo interessati ad applicare le funzioni non ad una singola variabile, ma a più variabili. Anche qui, esistono funzioni che permettono di farlo in maniera automatizzata. Comprendere bene questi approcci senza aver compreso gli elementi di data wrangling e programmazione che saranno descritti nel capitolo 9 non è facilissimo. Cercherò comunque di usare le funzioni più semplici e dirette. 7.3 Statistiche riassuntive per dati continui. Qui userò un data set piuttosto semplice (MASS::survey) che abbiamo già visto nel capitolo 6. Come esercizio, prova poi ad applicare lo stesso approccio ad altri data set (per esempio ggplot2::mpg oppure ai data set di R base mpg o women): cerca per favore di non eseguire meccanicamente i comandi ma di fare uno sforzo per interpretare i risultati. survey raccoglie dati ottenuti in un questionario somministrato a studenti dell’Università di Adelaide, in Australia. I dati non sono ordinati. Prova a visualizzarli ed esplorarli con i seguenti comandi: # ricordati di installare e caricare il pacchetto necessario # library(MASS) data(survey) View(survey) Il risultato dovrebbe essere più o meno quello della tabella 7.1. Tabella 7.1: Una parte dei dati del data frame survey. Risultati di un sondaggio fra studenti dell’Università di Adelaide. Consulta l’aiuto con help(survey) per dettagli Sex Wr.Hnd NW.Hnd W.Hnd Fold Pulse Clap Exer Smoke Height M.I Age Female 18.5 18.0 Right R on L 92 Left Some Never 173.00 Metric 18.250 Male 19.5 20.5 Left R on L 104 Left None Regul 177.80 Imperial 17.583 Male 18.0 13.3 Right L on R 87 Neither None Occas NA NA 16.917 Male 18.8 18.9 Right R on L NA Neither None Never 160.00 Metric 20.333 Male 20.0 20.0 Right Neither 35 Right Some Never 165.00 Metric 23.667 Female 18.0 17.7 Right L on R 64 Right Some Never 172.72 Imperial 21.000 Male 17.7 17.7 Right L on R 83 Right Freq Never 182.88 Imperial 18.833 Female 17.0 17.3 Right R on L 74 Right Freq Never 157.00 Metric 35.833 Male 20.0 19.5 Right R on L 72 Right Some Never 175.00 Metric 19.000 Male 18.5 18.5 Right R on L 90 Right Some Never 167.00 Metric 22.333 Il codice che segue ordina il data frame, ne estrae alcune righe e alcune colonne e usa due funzioni, una più “antica” e una più moderna, per riassumerli. I comandi utilizzati per filtrare e selezionare sono quelli di dplyr un pacchetto del tidyverse e sono collegati da pipes, un modo semplice per collegare catene i comandi reso disponibile dal pacchetto magrittr149. Procediamo prima con la funzione summary() survey_ridotto &lt;- survey %&gt;% dplyr::filter(Sex == &quot;Male&quot;) %&gt;% dplyr::select(Pulse, Exer, Smoke, Height, Age) surv_summary &lt;- summary(survey_ridotto) surv_summary ## Pulse Exer Smoke Height Age ## Min. : 35.0 Freq:65 Heavy: 6 Min. :154.9 Min. :16.75 ## 1st Qu.: 65.0 None:13 Never:89 1st Qu.:172.8 1st Qu.:17.92 ## Median : 72.0 Some:40 Occas:10 Median :180.0 Median :18.88 ## Mean : 73.2 Regul:12 Mean :178.8 Mean :20.33 ## 3rd Qu.: 80.0 NA&#39;s : 1 3rd Qu.:185.0 3rd Qu.:20.29 ## Max. :104.0 Max. :200.0 Max. :70.42 ## NA&#39;s :22 NA&#39;s :12 Il data frame che ho prodotto contiene solo gli studenti maschi (le osservazioni corrispondenti sono state estratte con dplyr::filter()) e solo 5 delle variabili originali (estratte con select(); se ne vuoi conoscere la natura prova con str(summary_ridotto)). Il risultato (che è stato assegnato ad un nome) è usato come argomento della funzione summary() e, come puoi facilmente vedere, è stato assegnato ad un nome, per poi essere “stampato” e mostra risultati diversi per i diversi tipi di colonna. per le due variabili qualitative, Exer e Smoke, viene mostrata la frequenza di ogni livello (si tratta di fattori) e il numero di dati mancanti (NA) per le tre variabili quantitative continue (Pulse, Height e Age) vengono mostrati la media e alcuni indicatori non parametrici (mediana, min, max e quartili)150 Ma di che natura è l’oggetto prodotto da summary()? Prova con &gt;str(surv_summary) Si tratta di un oggetto di classe table e, credimi, se volessi estrarre qualcuno dei valori sareppe più difficile che farlo da un vettore, una matrice o un data frame. Proviamo adesso con una funzione un po’ più moderna, skimr::skim() surv_skim &lt;- skim(survey_ridotto) kable(surv_skim, &quot;html&quot;) %&gt;% kable_styling(&quot;striped&quot;) %&gt;% scroll_box(width = &quot;100%&quot;) skim_type skim_variable n_missing complete_rate factor.ordered factor.n_unique factor.top_counts numeric.mean numeric.sd numeric.p0 numeric.p25 numeric.p50 numeric.p75 numeric.p100 numeric.hist factor Exer 0 1.0000000 FALSE 3 Fre: 65, Som: 40, Non: 13 NA NA NA NA NA NA NA NA factor Smoke 1 0.9915254 FALSE 4 Nev: 89, Reg: 12, Occ: 10, Hea: 6 NA NA NA NA NA NA NA NA numeric Pulse 22 0.8135593 NA NA NA 73.19792 11.999667 35.00 65.000 72.000 80.0000 104.000 ▁▃▇▅▁ numeric Height 12 0.8983051 NA NA NA 178.82604 8.380252 154.94 172.790 180.000 185.0000 200.000 ▁▅▇▇▁ numeric Age 0 1.0000000 NA NA NA 20.33196 6.069863 16.75 17.917 18.875 20.2915 70.417 ▇▁▁▁▁ Come puoi vedere facilmente, skim agisce sulle variabili quantitative producendo come risultato un data frame151 “tidy” (vedi paragrafo 4.1.5) con gli stessi risultati ottenuti per le variabili quantitative da summary, ma con una colonna in più che mostra un istogramma sparkline (un modo compresso per rappresentare grafici in una linea di testo o una cella di tabella). Per i fattori vengono calcolate le frequenze assolute dei livelli. Incidentalmente, skim() può essere collegato alle istruzioni precedenti con una pipe. Ora, pensa un attimo a quali grafici potrebbero essere utili per riassumere sia le variabili qualitative che quantitative di questa tabella e scrivi tu stesso i comandi usando ggplot2 come sistema grafico. 7.3.1 Misure di tendenza centrale e di variabilità. Al di là della esplorazione grafica di un campione (magari fosse una popolazione!) di osservazioni, l’obiettivo di un* scienziat* è generalmente quello di riassumere, con pochi numeri, tipicamente qualche misura di tendenza centrale e di variabilità o incertezza, i dati. Di seguito ti presento una lista delle funzioni più importanti152. Misure di tendenza centrale: hanno lo scopo di mostrare dove è localizzato il centro della distribuzione; misure diverse sono adatte a distribuzioni diverse e le diverse misure possono essere più o meno sensibili a dati estremi media aritmetica: mean(x, ...) adatta soprattuto a distribuzioni simmetriche e, in particolare a distribuzioni normali, può essere molto sensibile ai dati estremi (outlier) media winsorizzata: mean(x, trim = 0.05, ...) come la media aritmentica ma esclude i valori più estremi (in questo esempio il 5% per entrambi gli estremi); adatta quando si sospetta la presenza di outlier; in distribuzioni simmetriche coincide con la media aritmetica mediana: median(x, ...) un ottimo indicatore non parametrico, indica il valore al di sotto (o al di sopra) del quale si trova il 50% delle osservazioni Misure di variabilità: hanno lo scopo di mostrare la variabilità o l’incertezza della distribuzione (altrettanto importante della sua tendenza centrale) varianza: var(x, ...), è l’indicatore migliore ma non ha le stesse unità della media (è la somma degli scarti quadratici dalla media diviso i gradi di libertà); la funzione si applica anche a matrici e data frame153, ma in questo caso non restituisce un numero ma una matrice deviazione standard: sd(x, ...), un indicatore di dispersione molto usato, perché è nelle stesse unità della media e perché, combinato con la media, permette di individuare facilmente in una distribuzione normale deviazione mediana assoluta: mad() la mediana delle deviazioni assolute dal centro (tipicamente la mediana) della distribuzione; è un indicatore non parametrico robusto della variabilità o incertezza range: range(x, ...), restituisce un vettore numerico di lunghezza 2 con il minimo (min()) e il massimo (max()) range interquartile: IQR(x,...), una misura di variabilità non-parametrica meno robusta della deviazione mediana assoluta. 7.4 Altre funzioni utili. R base non ha funzioni specifiche per la media geometrica (adatta per esempio a distribuzioni log-normali), la media armonica (appropriata per calcolare la media di rapporti o proporzioni) e la moda (il valore più frequente di una distribuzione, corrisponde alla media in una distribuzione normale), il coefficiente di variazione (un modo comodo per esprimere la deviazione standard come frazione della media, adatto a valori continui per scala di rapporti, vedi paragrafo 4.1.2) e l’errore standard della media (una stima della variabilità delle medie campionarie)154. Puoi facilmente trovare in rete il modo per costruire funzioni che calcolano queste statistiche. Altre funzioni interessanti sono: weighted.mean(x, w, ...): restituisce la media pesata quantile(x, ...): restituisce uno o più (default) percentili di una distribuzione (quindi un vettore di lunghezza ≥1) fivenum(x, ...): la funzione che restituisce i 5 numeri di Tukey (se non ti ricordi che sono consulta il paragrafo 6.8.2) stem(x, ...): stem and leaf plots, un sistema molto preciso per mostrare la distribuzione di un campione in una maniera che combina elementi grafici e numerici t.test(x, ): è una funzione che consente di eseguire varie versioni del test t di Student per il confronto fra medie (dati appaiati o meno, con varianza costante o meno); se si indica solo il vettore numerico x restituisce un test che valuta l’ipotesi nulla che la media della popolazione non sia significativamente diversa da 0 e, fra le altre cose, permette di ricavare l’intervallo di confidenza della media; il risultato però è una lista di classe htest, dalla quale bisogna estrarre i valori di interesse; come molti altri test delle ipotesi, i risultati non sono tidy: nel paragrafo 7.5.3 vedremo come renderli più ordinati (e metterli sotto forma di data frame) Tieni presente che tutte queste funzioni, con l’eccezione di var(), usano come input un vettore numerico (vedi paragrafo 4.5.1155) e restituiscono vettori di lunghezza ≥ 1 (sapere cosa viene fuori da una funzione è piuttosto importante). Ricorda che questi possono essere all’interno di un oggetto più complesso. In ogni caso, se sono presenti missing data (NA in R, vedi 4.1.6) le statistiche non possono essere calcolate. Per poterlo fare è necessario escluderli, eliminandoli dal vettore (sconsigliato) o usando l’apposita opzione presente in molte funzioni (na.rm = T, attenzione ai default!). Nota anche che alcune funzioni permettono, di fatto, di ottenere una stima (campionaria) dei parametri di una distribuzione. Mentre questo è probabilmente vero per la distribuzione delle medie campionarie (ti ricordi del teorema del limite centrale? Se no prova a chiedere a chatGPT…), non lo è sempre, e media e deviazione standard hanno poco valore per distribuzioni asimmetriche o, peggio, multimodali. In molti casi è sicuramente meglio usare indicatori più robusti, non parametrici (mediana, mad). 7.4.1 Lavorare sui vettori. Giusto perché in qualche situazione può servire, ti mostro come usare le funzioni che ho appena illustrato lavorando su vettori (ma anche singole colonne di data frame). Prima di tutto, nota come R Markdown (il particolare tipo di dialetto di Markdown usato per scrivere questo testo) ti consente di usare funzioni in line per inserire dei risultati in un testo (una cosa piuttosto utile), per esempio media ± deviazione standard dell’altezza degli studenti di sesso maschile nel data set survey è 178.83 ± 8.38156. Le funzioni usate per ottenere questi risultati possono essere usate per mandare i risultati alla console. Guarda cosa fa il codice successivo: # applicare una singola funzione, una variabile alla volta può essere noioso ma utile mean(survey_ridotto$Height, na.rm = T) ## [1] 178.826 #se vuoi arrotondare round(mean(survey_ridotto$Height, na.rm = T), 2) ## [1] 178.83 # oppure with(survey_ridotto, mean(Height, na.rm = T)) sd(survey_ridotto$Height, na.rm = T) ## [1] 8.380252 # se tutte le variabili fossero numeriche potrei &quot;applicare&quot; una funzione ad # un margine medie &lt;- apply(survey_ridotto[, c(1,4,5)], 2, mean, trim = 0.1, na.rm = T) medie ## Pulse Height Age ## 72.88462 179.00326 19.15194 class(medie) ## [1] &quot;numeric&quot; # due alternative # sapply, una funzione di base che, a differenza di apply semplifica l&#39;output # e lavora per colonne # qui calcolo le medie winsorizzate medie_sapply &lt;- sapply(survey_ridotto[, c(1,4,5)], mean, na.rm = T, trim = 0.1) medie_sapply ## Pulse Height Age ## 72.88462 179.00326 19.15194 class(medie_sapply) ## [1] &quot;numeric&quot; # map_dbl, una funzione del pacchetto purrr del tidyverse medie_purrr &lt;- map_dbl(survey_ridotto[, c(1,4,5)], mean, na.rm = T, trim = 0.1) medie_purrr ## Pulse Height Age ## 72.88462 179.00326 19.15194 class(medie_purrr) ## [1] &quot;numeric&quot; Nota come in alcuni casi i parametri della funzione che viene “applicata” sono aggiunti dopo il nome della funzione stessa. In effetti, ogni volta che incontri ... significa che puoi passare altri argomenti. Ora prova tu con le funzioni presentate nel paragrafo 7.3.1. Incidentalmente, combinando varie funzioni in una funzione definita dall’utente è possibile ottenere una funzione che restituisce risultati multipli, magari sotto forma di un vettore con nomi, piuttosto utile in alcune situazioni. 7.4.2 Funzioni che producono statistiche riassuntive. Tre funzioni utili e con default piuttosto semplici per calcolare contemporaneamente i valori di più statistiche sono: Hmisc::describe(): applicabile a vari oggetti, ma restituisce una lista, scomoda pastecs::stat.desc(): restituisce un data frame, ma i risultati sono trasposti rispetto a come sarebbe carino averli per metterli in una tabella di dati riassuntivi psych::describe(): restituisce un data frame, molte opzioni utili (include per esempio la curtosi e l’asimmetria, skewness in inglese, due parametri utili per capire la forma della distribuzione), e i risultati sono orientati correttamente Prova tu stess* Hmisc::describe(survey_ridotto[, c(1,4,5)]) pastecs::stat.desc(survey_ridotto[, c(1,4,5)]) psych::describe(survey_ridotto[, c(1,4,5)]) Nota che due di queste funzioni hanno lo stesso nome: per essere sicuri di invocare quella giusta, se sono caricati entrambi i pacchetti, bisogna utilizzare anche il nome del pacchetto!!! 7.4.3 Statistiche, ordinate. Oltre a skim() è possibile usare il verbo summarise() di dplyr per calcolare diverse utili statistiche riassuntive. Come vedremo nel capitolo 9, summarise(), a differenza di mutate() prende un vettore di valori e restituisce un singolo valore. Inoltre, alcune funzioni helper, come across() possono servire per applicare facilmente più statistiche a variabili multiple. Il risultato di queste operazioni è sempre un data frame (o meglio, una tibble) ed è possibile usare le pipe. Nota come con dplyr non è necessario usare l’operatore $ per accedere alle variabili: # qui i risultati vengono solo stampati, non assegnati survey_ridotto %&gt;% dplyr::summarise(mpulse = mean(Pulse, na.rm = T, trim = 0.1), mheight = mean(Height, na.rm = T, trim = 0.1)) ## mpulse mheight ## 1 72.88462 179.0033 # ripetere i nomi delle variabili è tedioso survey_ridotto %&gt;% dplyr::summarise(across(where(is.numeric), ~mean(.x, na.rm = T, trim = 0.1))) ## Pulse Height Age ## 1 72.88462 179.0033 19.15194 # o, addirittura, con funzioni multiple, passate come lista media_sd &lt;- list( media_w = ~mean(.x, na.rm = T, trim = 0.1), sd = ~sd(.x, na.rm = T) ) survey_ridotto %&gt;% dplyr::summarise(across(where(is.numeric), media_sd)) ## Pulse_media_w Pulse_sd Height_media_w Height_sd Age_media_w Age_sd ## 1 72.88462 11.99967 179.0033 8.380252 19.15194 6.069863 # infine, con purrr; qui prima usiamo select per estrarre le colonne # numeriche, poi passiamo la funzione di interesse e restituiamo un # data frame; i parametri sono passati all&#39;esterno della funzione survey_ridotto %&gt;% dplyr::select(where(is.numeric)) %&gt;% map_df(mean, na.rm = T, trim = 0.1) ## # A tibble: 1 × 3 ## Pulse Height Age ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 72.9 179. 19.2 Insomma, molti modi per pelare un gatto… 7.4.4 Statistiche riassuntive per gruppi. I dati reali sono spesso raggruppati sulla base di variabili categoriche (che possono essere indicate da fattori). Nel capitolo 6 ho già mostrato come sia possibile esplorare, p.es. con dei box plot, istogrammi o grafici a densità, gruppi diversi di dati in un data frame. Qui ti mostrerò alcune funzioni che operano per gruppi doBy::summaryBy() psych::describeBy() dplyr con group_by() e summarise() Ovviamente, gli stessi risultati possono essere ottenuti, con qualche difficoltà in più, con R base: prova ad esplorare l’aiuto di aggregate() e by(). Cominciamo con doBy::summaryBy(), che ha il vantaggio di accettare funzioni multiple e restituire un data frame, ma ha una sintassi un po’ curiosa, con le variabili su cui fare i calcoli e quella che li raggruppa definite da una formula. Qui non abbiamo bisogno di selezionare uno dei due gruppi di survey # creo una funzione definita dall&#39;utente con le funzioni che mi interessano Fun_riass &lt;- function(x, ...){ c( media = mean(x, na.rm = T, ...), dev_st = sd(x, na.rm = T), num_non_na = length(!is.na(x)) ) } doBy::summaryBy(cbind(Pulse, Height, Age) ~ Sex, data = survey, FUN = Fun_riass) ## Sex Pulse.media Pulse.dev_st Pulse.num_non_na Height.media Height.dev_st ## 1 Female 75.12632 11.40664 118 165.6867 6.151777 ## 2 Male 73.19792 11.99967 118 178.8260 8.380252 ## 3 &lt;NA&gt; 73.00000 NA 1 172.0000 NA ## Height.num_non_na Age.media Age.dev_st Age.num_non_na ## 1 118 20.40753 6.906053 118 ## 2 118 20.33196 6.069863 118 ## 3 1 21.50000 NA 1 Oggettivamente bruttino, ma permette di fare cose interessanti ed è altamente personalizzabile. psych::describeBy() è un’estensione di psych:describe(); molto comodo, restituisce un data frame in un formato facile da utilizzare; anche qui è possibile usare una formula: psych::describeBy(Height + Pulse ~ Sex, data = survey) ## ## Descriptive statistics by group ## Sex: Female ## vars n mean sd median trimmed mad min max range skew ## Height 1 102 165.69 6.15 166.75 165.90 5.32 150 180.34 30.34 -0.33 ## Pulse 2 95 75.13 11.41 75.00 75.19 10.38 40 104.00 64.00 -0.14 ## kurtosis se ## Height -0.32 0.61 ## Pulse 0.41 1.17 ## ------------------------------------------------------------ ## Sex: Male ## vars n mean sd median trimmed mad min max range skew ## Height 1 106 178.83 8.38 180 179.00 7.41 154.94 200 45.06 -0.20 ## Pulse 2 96 73.20 12.00 72 72.88 11.86 35.00 104 69.00 0.11 ## kurtosis se ## Height -0.11 0.81 ## Pulse 0.24 1.22 Infine, ecco un po’ di soluzioni tidy, un pochino più verbose, ma con un codice più semplice da leggere157; i gruppi sono prodotti dalla funzione group_by(), che restituisce un grouped_df. Abbastanza prevedibilmente, per eliminare i gruppi, che restano nei risultati, si usa ungroup(). # cosa fa group_by? str(survey %&gt;% group_by(Sex)) ## gropd_df [237 × 12] (S3: grouped_df/tbl_df/tbl/data.frame) ## $ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 2 2 2 2 1 2 1 2 2 ... ## $ Wr.Hnd: num [1:237] 18.5 19.5 18 18.8 20 18 17.7 17 20 18.5 ... ## $ NW.Hnd: num [1:237] 18 20.5 13.3 18.9 20 17.7 17.7 17.3 19.5 18.5 ... ## $ W.Hnd : Factor w/ 2 levels &quot;Left&quot;,&quot;Right&quot;: 2 1 2 2 2 2 2 2 2 2 ... ## $ Fold : Factor w/ 3 levels &quot;L on R&quot;,&quot;Neither&quot;,..: 3 3 1 3 2 1 1 3 3 3 ... ## $ Pulse : int [1:237] 92 104 87 NA 35 64 83 74 72 90 ... ## $ Clap : Factor w/ 3 levels &quot;Left&quot;,&quot;Neither&quot;,..: 1 1 2 2 3 3 3 3 3 3 ... ## $ Exer : Factor w/ 3 levels &quot;Freq&quot;,&quot;None&quot;,..: 3 2 2 2 3 3 1 1 3 3 ... ## $ Smoke : Factor w/ 4 levels &quot;Heavy&quot;,&quot;Never&quot;,..: 2 4 3 2 2 2 2 2 2 2 ... ## $ Height: num [1:237] 173 178 NA 160 165 ... ## $ M.I : Factor w/ 2 levels &quot;Imperial&quot;,&quot;Metric&quot;: 2 1 NA 2 2 1 1 2 2 2 ... ## $ Age : num [1:237] 18.2 17.6 16.9 20.3 23.7 ... ## - attr(*, &quot;groups&quot;)= tibble [3 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ Sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 2 NA ## ..$ .rows: list&lt;int&gt; [1:3] ## .. ..$ : int [1:118] 1 6 8 11 13 14 16 17 25 31 ... ## .. ..$ : int [1:118] 2 3 4 5 7 9 10 12 15 18 ... ## .. ..$ : int 137 ## .. ..@ ptype: int(0) ## ..- attr(*, &quot;.drop&quot;)= logi TRUE # un primo esempio con un paio di funzioni e summarise survey %&gt;% group_by(Sex) %&gt;% dplyr::summarise( media_alt = mean(Height, na.rm = T), sd_alt = sd(Height, na.rm = T) ) ## # A tibble: 3 × 3 ## Sex media_alt sd_alt ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female 166. 6.15 ## 2 Male 179. 8.38 ## 3 &lt;NA&gt; 172 NA # un secondo esempio: elimino gli NA da Sex e uso due variabili per raggruppare survey %&gt;% dplyr::filter(!is.na(Sex) &amp; !is.na(Exer)) %&gt;% group_by(Sex, Exer) %&gt;% dplyr::summarise( media_alt = mean(Height, na.rm = T), sd_alt = sd(Height, na.rm = T) ) ## `summarise()` has grouped output by &#39;Sex&#39;. You can override using the `.groups` ## argument. ## # A tibble: 6 × 4 ## # Groups: Sex [2] ## Sex Exer media_alt sd_alt ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female Freq 167. 6.42 ## 2 Female None 163. 4.80 ## 3 Female Some 165. 5.89 ## 4 Male Freq 180. 7.94 ## 5 Male None 174. 9.62 ## 6 Male Some 178. 8.20 # un terzo esempio, con funzioni multiple e variabili multiple # selezionate sulla base del nome, non del tipo survey %&gt;% dplyr::filter(!is.na(Sex) &amp; !is.na(Exer)) %&gt;% group_by(Sex, Exer) %&gt;% dplyr::summarise(across(c(Height, Pulse), media_sd)) ## `summarise()` has grouped output by &#39;Sex&#39;. You can override using the `.groups` ## argument. ## # A tibble: 6 × 6 ## # Groups: Sex [2] ## Sex Exer Height_media_w Height_sd Pulse_media_w Pulse_sd ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female Freq 167. 6.42 73.5 12.5 ## 2 Female None 163. 4.80 71.4 11.4 ## 3 Female Some 165. 5.89 77.0 10.3 ## 4 Male Freq 180. 7.94 70.2 9.59 ## 5 Male None 174. 9.62 80.1 15.2 ## 6 Male Some 178. 8.20 75.9 13.5 Perché non provare a fare lo stesso con R base? In effetti, il codice non è altrettanto semplice da seguire e l’output è più bruttino. Prova questo nella console: aggregate(cbind(Pulse, Height) ~ Sex + Exer, data = survey, FUN = mean, na.rm = T) 7.5 Ma è normale? La distribuzione normale, o Gaussiana, è un tipo di distribuzione continua di probabilità piuttosto utile perché molte variabili che descrivono fenomeni naturali (e non solo) sono normalmente distribuite e perché, nota la media e la varianza, è facile calcolarne la distribuzione di densità di probabilità. Inoltre, nella statistica frequentista, è abbastanza comune che si assuma che le distribuzioni di variabili da sottoporre a test statistici siano normali e che da queste assunzioni dipenda quanto il livello di significatività al quale si rigetta un’ipotesi nulla corrisponda effettivamente a quello specificato158. Naturalmente, qui, come in molti altri casi, usiamo un modello (per esempio gli errori sono normalmente distribuiti, con media 0 e varianza \\(\\sigma\\)) e sarebbe opportuno verificare che questo modello sia aderente alla realtà. Per dimostrare alcuni metodi con i quali si può verificare graficamente e con test inferenziali che le osservazioni per una variabile siano normalmente distribuiti useremo Iris, un famoso data set storicamente utilizzato per illustrare l’analisi lineare discriminante159. Il data set mostra le misure per la lunghezza e la larghezza dei petali e dei sepali per tre specie di Iris ( I. setosa, I. versicolor e I. virginica), con campioni (si assume estratti in modo casuale da una popolazione più grande di fiori) di 50 osservazioni ciascuno. Possiamo usare il data set per: visualizzare le differenze fra le tre specie usare le statistiche (media e varianza) dei campioni per fare inferenze sulla media e varianza delle popolazioni da cui sono estratti controllare che l’assunzione che i dati siano normalmente distribuiti non possa essere rifiutata usando: dei (normal) probability plot un test delle ipotesi, per esempio il test Shapiro-Wilks shapiro.test(), il test di Anderson-Darling nortest::ad.test() o quello di Kolmogorov-Smirnov (Lilliefors) nortest::lillie.test() L’uso di questa funzione ci darà modo di esplorare l’uso dei test delle ipotesi in R e la natura degli oggetti che essi generano. Tutti e tre i test sono volti a rifiutare o accettare l’ipotesi nulla che i dati provengono da una distribuzione normale. Tuttavia, se l’ipotesi nulla H0 viene scartata non ci dicono nulla sulla forma reale della distribuzione. Naturalmente, prima di iniziare, dovresti provare a ricordare come, nel capitolo 6 ti ho mostrato alcuni tipi di rappresentazioni dei dati particolarmente adatti a mostrare la distribuzione delle osservazioni (istogrammi, box plot, density plot etc.). Prova quindi a calcolare statistiche di base per gruppi per almeno una variabile e a rappresentarne graficamente in uno o due modi la distribuzione delle osservazioni. Se proprio non ci riesci troverai esempi di codice nel paragrafo 7.8. 7.5.1 Normal probability plot. I probability plots della figura 7.1 sono grafici che confrontano la distribuzione campionaria dei quantili con quella attesa sulla base di una certa distribuzione di proabbilità. Qui userò le funzioni di ggplot2 (anche se R base mette a disposizione le funzioni qqnorm() e qqline()) iris %&gt;% ggplot(aes(sample = Sepal.Length, shape = Species)) + geom_qq() + geom_qq_line() + labs( x = &quot;quantili teorici&quot;, y = &quot;quantili del campione&quot;, caption = str_wrap(&quot;Fisher, R. A. (1936) The use of multiple measurements in taxonomic problems. Annals of Eugenics, 7, Part II, 179–188.&quot;,80) ) Figura 7.1: Normal probability plots con ggplot2: lunghezza dei sepali per diverse specie di Iris Naturalmente con l’opzione distribution = stats::qnorm è possibile scegliere distribuzioni parentali diverse dalla normale. 7.5.2 Test statistici per la normalità. R base mette a disposizione il test di Shapiro-Wilk per testare l’ipotesi nulla che le osservazioni in un dato vettore siano distribuite normalmente. La funzione da utilizzare è shapiro.test(). Prova prima di tutto ad esplorare l’aiuto con: &gt;?shapiro.test Come molti test statistici, la funzione restituisce una lista. Facciamo un piccolo esempio con il dataset ìris. Qui provo a testare l’ipotesi che i valori della lunghezza dei sepali per la specie setosa siano normalmente distribuiti. Per usare il test, devo prima di tutto estrarre il vettore di dati che mi interessa dal data frame. Nell’esempio successivo userò una combinazione di funzioni del tidyverse160. # estraggo il vettore test vettore_test &lt;- iris %&gt;% dplyr::filter(Species == &quot;setosa&quot;) %&gt;% dplyr::select(Sepal.Length) %&gt;% pull() # eseguo il test, assegnando i risultati ad un nome test_shapiro &lt;- shapiro.test(vettore_test) # stampo i risultati del test test_shapiro ## ## Shapiro-Wilk normality test ## ## data: vettore_test ## W = 0.9777, p-value = 0.4595 # la struttura dell&#39;oggetto str(test_shapiro) ## List of 4 ## $ statistic: Named num 0.978 ## ..- attr(*, &quot;names&quot;)= chr &quot;W&quot; ## $ p.value : num 0.46 ## $ method : chr &quot;Shapiro-Wilk normality test&quot; ## $ data.name: chr &quot;vettore_test&quot; ## - attr(*, &quot;class&quot;)= chr &quot;htest&quot; I singoli elementi della lista possono essere facilmente estratti usando i metodi descritti nella sezione 4.8. Per esempio, per estrarre il valore p (la probabilità con la quale, se l’ipotesi nulla è vera, possono essere ottenuti valori valori uguali o più estremi della statistica test), puoi usare test_shapiro$p.value. Riportare in maniera chiara, esaustiva e trasparente i risultati di un test statistico è importante. Per esempio, nel caso precedente avremmo potuto scrivere: volendo essere logorroici: usando il test di Shapiro-Wilk per la normalità, non è stato possibile scartare l’ipotesi nulla che i dati per la lunghezza dei sepali per la specie Iris setosa siano normalmente distribuiti (W = 0.978, p = 0.46) In maniera più sintetica: i dati per la lunghezza dei sepali per la specie Iris setosa sono normalmente distribuiti (test di Shapiro-Wilk per la normalità, W = 0.978, p = 0.46) Nella sezione 7.9 troverai un link ad un documento con diversi esempi. Prova ora a fare la stessa cosa con i due test offerti dal pacchetto nortest, il test di Anderson-Darling (ad.test()) e il test di Lilliefors (lillie.test()). 7.5.3 Come fare di meglio con i risultati dei test. Come avrai notato, i risultati del test non sono tidy, nel senso descritto nel paragrafo 4.1.5, e, benché la stampa a console sia piuttosto chiara, non è utile se vuoi presentare i dati di più gruppi (è il caso nostro). Usando R base potremmo per esempio usare un loop per eseguire il test sui tre livelli del fattore Species in iris. Prova ad eseguire questo codice in uno script: # prima di tutto creo una lista per ospitare i risultati del test test_shapiro_multipli &lt;- vector(mode = &quot;list&quot;, length = nlevels(iris$Species)) for (i in 1:nlevels(iris$Species)){ # assegno i risultati del test allo slot test_shapiro_multipli[[i]] &lt;- shapiro.test(iris$Sepal.Length[iris$Species==levels(iris$Species)[i]]) # dò il nome corretto allo slot della lista names(test_shapiro_multipli)[i] &lt;- levels(iris$Species)[i] } # stampo la lista test_shapiro_multipli Il risultato nella console è piuttosto bruttino da vedere (ma ci si può lavorare), ma i risultati sono stati conservati in una lista dalla quale possono essere estratti e riutilizzati per ulteriori analisi. Un modo più elegante usare i pacchetti purrr e broom con dplyr per produrre un data frame ordinato con i risultati del test: iris %&gt;% nest(data = -Species) %&gt;% mutate( test = map(data, ~ shapiro.test(.x$Sepal.Length)), ordinato = map(test, tidy) ) %&gt;% unnest(ordinato) ## # A tibble: 3 × 6 ## Species data test statistic p.value method ## &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 setosa &lt;tibble [50 × 4]&gt; &lt;htest&gt; 0.978 0.460 Shapiro-Wilk normality… ## 2 versicolor &lt;tibble [50 × 4]&gt; &lt;htest&gt; 0.978 0.465 Shapiro-Wilk normality… ## 3 virginica &lt;tibble [50 × 4]&gt; &lt;htest&gt; 0.971 0.258 Shapiro-Wilk normality… Queste cose diventeranno più chiare se vorrai arrivare al capitolo 9. Ecco però una descrizione passo passo del codice161 da usare in uno script per capire un po’ meglio cosa succede. Nota come .x$Sepal.Length venga usato qui per “pescare” la variabile che ci interessa dai data frame contenuti nella colonna data. # creo una tibble annidata che contiene una colonna con le specie # e una colonna con delle tibble contenenti i dati per ciascuna specie tibble_annidata &lt;- iris %&gt;% nest(data = -Species) # uso mutate con la funzione map() di purrr per applicare il # test ai tre livelli delle specie e poi uso tidy() di broom # per rioridinare i risultati del test tibble_risultati &lt;- tibble_annidata %&gt;% mutate( test = map(data, ~ shapiro.test(.x$Sepal.Length)), ordinato = map(test, tidy) ) # uso unnest() per estrarre i risultati in un data frame tibble_risultati %&gt;% unnest(ordinato) Insomma, mi verrebbero in mente altri modi per fare la stessa cosa, più o meno utili in diverse situazioni. Prova a pensarci anche tu. 7.6 Intervalli di confidenza. La media e la varianza ottenute usando le osservazioni in uno specifico campione sono delle stime puntuali dei veri parametri della popolazione da cui quel campione è stato estratto. Un altro ipotetico campione risulterebbe in una stima diversa. Prova tu stesso con questo codice, che mostra come campioni di numeri casuali estratti da una distribuzione normale con media 5 e deviazione standard 2 abbiano tutti medie e deviazioni standard diverse. # estraggo 10000 numeri casuali da una distirbuzione normale con media 5 e # deviazione standard 2 numeri_casuali &lt;- rnorm(10000, mean = 5, sd = 2) # calcolo media e deviazione standard mean(numeri_casuali) sd(numeri_casuali) # faccio lo stesso, con campioni più piccoli, creando un data frame con una # funzione di purrr numeri_casuali &lt;- map(rep(100,5), rnorm, mean = 5, sd = 2) medie_sd &lt;- tibble( medie = map_dbl(numeri_casuali, mean), devst = map_dbl(numeri_casuali, sd) ) Nota come il codice è sufficientemente generico da poter generare vettori di numeri casuali di qualsiasi lunghezza e con qualsiasi media e deviazione standard. Nella statistica frequentista, un modo per rappresentare l’incertezza della stima della media è quella di mostrarne l’intervallo di confidenza. Qui proveremo a farlo con la funzione t.test() e alcune utilissime funzioni di broom. Quando viene usata con i parametri di default su un vettore, t.test() restituisce, fra le altre cose l’intervallo di confidenza della media (ben nascosto nella lista!). Guarda questo esempio con iris; qui uso vettore_test, che contiene i valori della lunghezza dei sepali per la specie Iris setosa (vedi paragrafo 7.5.2): t.test(vettore_test) ## ## One Sample t-test ## ## data: vettore_test ## t = 100.42, df = 49, p-value &lt; 2.2e-16 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 4.905824 5.106176 ## sample estimates: ## mean of x ## 5.006 Il test appena condotto è l’equivalente di valutare l’ipotesi nulla che la media non è significativamente diversa da 0, usando un test a due code con un livello di significatività \\(\\alpha\\) = 0.05. Come sempre, sarebbe bello avere i risultati ordinati: la funzione tidy() di broom lo fa per noi: tidy(t.test(vettore_test)) ## # A tibble: 1 × 8 ## estimate statistic p.value parameter conf.low conf.high method alternative ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 5.01 100. 2.11e-58 49 4.91 5.11 One Samp… two.sided Qui la variabile parameter contiene i gradi di libertà162. Ovviamente, usando il codice dimostrato nel paragrafo 7.5.3, possiamo operare in modo da ottenere i risultati per tutti i gruppi del nostro data frame e usare il data frame tidy che otteniamo per fare tabelle e grafici! medie_conf &lt;- iris %&gt;% group_by(Species) %&gt;% nest(data = - Species) %&gt;% mutate( test = map(data, ~ t.test(.x$Sepal.Length)), ordinato = map(test, tidy) ) %&gt;% unnest(ordinato) %&gt;% dplyr::select(Species, media = estimate, conf.low, conf.high) medie_conf ## # A tibble: 3 × 4 ## # Groups: Species [3] ## Species media conf.low conf.high ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 4.91 5.11 ## 2 versicolor 5.94 5.79 6.08 ## 3 virginica 6.59 6.41 6.77 O possiamo tirarne fuori un grafico come quello della figura 7.2… medie_conf %&gt;% ggplot(aes(x = Species)) + geom_pointrange(aes(y = media, ymin = conf.low, ymax = conf.high)) + labs(x = &quot;specie&quot;, caption = &quot;Fisher, R. A. (1936) The use of multiple measurements in taxonomic problems. Annals of Eugenics, 7, Part II, 179–188.&quot;) Figura 7.2: Media e intervallo di confidenza al 95% per la lunghezza dei sepali di divcerse specie di Iris. Se non ti senti troppo pigr* potresti provare a migliorare questo grafico o leggere questa vignetta che spiega bene come usare indieme dplyr e broom per ordinare i risultati di test statistici. Come la media, la varianza campionaria è il migliore stimatore lineare senza bias (BLUE) della varianza della popolazione. In pacchetto DescTools mette a disposizione la funzione VarCI() per calcolare l’intervallo di confidenza di una varianza. 7.7 Riassumere i dati per le variabili categoriche. I dati categorici possono essere classificati, contati e riassunti in grafici come grafici a barre, a torta, a ventaglio, a mosaico, etc. (vedi sezione 6.7) ma anche in tabelle di frequenza (a una via, one-way) o contingenza (due o più vie, two-, multi-way). In questa sezione useremo prevalentemente il data set Arthritis, ma un altro classico data set per dati categorici è Titanic, che mostra la sopravvivenza dei passeggeri del Titanic in funzione della classe in cui viaggiavano. L’array può essere “esplorato” e convertito in un data frame con i seguenti comandi: ?Titanic data(&quot;Titanic&quot;) class(Titanic) ## [1] &quot;table&quot; Titanic ## , , Age = Child, Survived = No ## ## Sex ## Class Male Female ## 1st 0 0 ## 2nd 0 0 ## 3rd 35 17 ## Crew 0 0 ## ## , , Age = Adult, Survived = No ## ## Sex ## Class Male Female ## 1st 118 4 ## 2nd 154 13 ## 3rd 387 89 ## Crew 670 3 ## ## , , Age = Child, Survived = Yes ## ## Sex ## Class Male Female ## 1st 5 1 ## 2nd 11 13 ## 3rd 13 14 ## Crew 0 0 ## ## , , Age = Adult, Survived = Yes ## ## Sex ## Class Male Female ## 1st 57 140 ## 2nd 14 80 ## 3rd 75 76 ## Crew 192 20 Titanic_df &lt;- as.data.frame.table(Titanic) Nota come i dati di Titanic siano già tabulati. 7.7.1 Tabelle di frequenza e contingenza. Anche se i diversi tipi di rappresentazione grafica per dati categorici ci possono dare un’eccellente idea d’insieme sulla distribuzione dei dati nei diversi gruppi, le tabelle di frequenza e contingenza ci danno un’idea precisa del numero di osservazioni in ogni categoria e ci permettono di eseguire test inferenziali (in genere per testare l’ipotesi che le variabili che raggruppano i dati non hanno un effetto significativo sulla frequenza dei dati in ogni cella della tabella). Le tabelle possono essere arricchite calcolando totali e frequenze di riga e colonna. Come sempre, ci sono diverse funzioni per ottenere lo stesso risultato: table(): è la funzione di base, molto flessibile (vedi dopo), restituisce una tabella di contingenza, un oggetto di classe table; xtabs(): funzione di base, usa un’interfaccia a formula (vedi dopo), più semplice da gestire di table(), restituisce lo stesso tipo di oggetti; gmodels::CrossTable(): ha un numero maggiore di opzioni e restituisce un output simile a quello prodotto da SPSS Prova il seguente codice in uno script per vedere come funziona table(); fai attenzione a cosa va nelle righe e colonne delle tabelle a più vie. Nota anche come gli oggetti di classe table possono essere usati direttamente per la stampa o per produrre grafici (a barre, a torta, a mosaico). ?table # nota l&#39;uso di with() # una tabella di frequenza, a una via una_tabella &lt;- with(Arthritis, table(Improved)) # in alternativa table(Arthritis$Improved) una_tabella class(una_tabella) # una funzione utile per aggiungere somme per le diverse vie o margini è ?addmargins addmargins(una_tabella,1) # invece, per trasformare le conte in proporzioni ?prop.table prop.table(una_tabella) # una tabella a due vie tabella_2_vie &lt;- with(Arthritis, table(Treatment,Improved)) # nota che con l&#39;opzione useNA puoi decidere se includere la conta degli NAs # con le opzioni &quot;no&quot;, &quot;ifany&quot;, &quot;always&quot;; &quot;ifany&quot; tabella_2_vie # per aggiungere margini margin.table(tabella_2_vie,1) margin.table(tabella_2_vie,2) # add sums to all margins addmargins(tabella_2_vie) # solo per Treatment addmargins(tabella_2_vie, 1) # le due funzioni possono essere combinate addmargins(prop.table(tabella_2_vie),c(1,2)) pie(una_tabella) barplot(tabella_2_vie, beside = T, legend = T) Personalmente, preferisco xtabs, perché secondo me l’interfaccia a formula rende più chiaro quello che si vuole fare: dopo la tilde si aggiungono, in sequenza, righe, colonne, strati, separati dal segno +. Se i dati sono già tabulati, come in Titanic_df, le conte vanno sul lato sinistro della formula. Nell’esempio successivo creo gli oggetti tabella senza assegnarli ad un nome. # con Arthritis tabella_3_vie &lt;- xtabs(~Treatment+Improved+Sex, data = Arthritis) tabella_3_vie ## , , Sex = Female ## ## Improved ## Treatment None Some Marked ## Placebo 19 7 6 ## Treated 6 5 16 ## ## , , Sex = Male ## ## Improved ## Treatment None Some Marked ## Placebo 10 0 1 ## Treated 7 2 5 # con il data frame ottenuto da Titanic xtabs(Freq~Survived+Class, data = Titanic_df) ## Class ## Survived 1st 2nd 3rd Crew ## No 122 167 528 673 ## Yes 203 118 178 212 Naturalmente, anche in questo caso è possibile usare addmargins(), proptable(), margin.table(), etc. Nota anche come un oggetto di classe table è un array, quindi è possibile accedere ai diversi strati usando []. Prova questi comandi nella console: &gt;tabella_3_vie &lt;- xtabs(~Treatment+Improved+Sex, data = Arthritis) &gt;is.array(tabella_3_vie) &gt;dim(tabella_3_vie) &gt;tabella_3_vie[1,,] &gt;tabella_3_vie[1,2,] Prova tu stess* a esplorare gmodels::CrossTable() con gli stessi data set. Quali sono le opzioni? Che tipo di output è possibile ottenere? Che oggetto restituisce la funzione? Che tipo di test inferenziali è possibile fare? 7.7.2 Grafici a mosaico. I grafici a mosaico sono un modo visualmente molto efficace di rappresentare dati tabulari. La funzione della grafica di base per ottenere questo tipo di grafici è mosaicplot() che prende come input un oggetto di classe table, che può essere anche creato “al volo”. Prova questo codice nella console: &gt;mosaicplot(xtabs(~Treatment+Improved+Sex, data = Arthritis), color = 2:3, main = &quot;Effetto del trattamento sui sintomi dell&#39;artrite&quot;) La funzione è utile, per esempio, per vedere rapidamente se un esperimento con diverse variabili esplicative è bilanciato (ogni gruppo individuato da una combinazione di variabili categoriche contiene lo stesso numero di casi). La funzione vcd::mosaic() è più efficace ma ha una sintassi un po’ più complessa (figura 7.3). mosaic(Titanic, shade = T, legend = T) Figura 7.3: I sopravvissuti al disastro del Titanic: un grafico a mosaico 7.8 Veloce veloce Un po’ di codice per la sezione 7.5. Il codice è un po’ ridondante, in modo che tu lo possa far girare indipendentemente da questo capitolo (ma è necessario che tu installi i pacchetti necessari) e ti permette di ottenere qualche grafico esporativo, senza troppi fronzoli, perché ti basta tornare al capitolo 6. library(tidyverse) library(car) data(&quot;iris&quot;) # esplora brevemente i dati # ometto questi comandi perché ti basta cliccare sulla riga corrispondente # nel tab Environment # View(iris) # str(iris) # una selezione casuale dei dati car::some(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 2 4.9 3.0 1.4 0.2 setosa ## 25 4.8 3.4 1.9 0.2 setosa ## 31 4.8 3.1 1.6 0.2 setosa ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 63 6.0 2.2 4.0 1.0 versicolor ## 72 6.1 2.8 4.0 1.3 versicolor ## 81 5.5 2.4 3.8 1.1 versicolor ## 122 5.6 2.8 4.9 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica # concentriamoci su una sola variabile ma il codice si applica anche alle altre iris %&gt;% ggplot(aes(x = Species, y = Sepal.Length)) + geom_boxplot(notch = T) + geom_jitter() iris %&gt;% ggplot(aes(x = Sepal.Length)) + facet_wrap(~Species) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. iris %&gt;% ggplot(aes(x = Sepal.Length, color = Species)) + geom_density() 7.9 Altre risorse. 7.9.1 Risorse in italiano. Oltre alla wiki che ho citato molte volte potete provare a consultare questo libro che descrive abbastanza bene molti comandi per la statistica descrittiva con R. Per il resto, come di consueto è sufficiente usare le funzioni di ricerca di Google (prova con “statistica descrittiva con R”) per trovare moltissimo materiale (sono pigro anch’io, non mi va di leggerlo) prodotto generalmente a supporto di corsi universitari. 7.9.2 Risorse in inglese. In inglese c’è un’enorme quantità di materiale. Non credo valga nemmeno la pena di proporre le decinde e decine di pagine web e filmati. Se sei pigr*, oltre ai molti eccellenti testi di statistica di base (che richiedono un po’ di tempo e fatica, ma ne vale la pena), puoi consultare questi testi on line un eccellente manuale per la statistica nelle scienze biologiche e il suo companion con il codice R (che però usa prevalentemente funzioni di R base) se proprio vuoi essere minimalista puoi usare Just enough R o YaRrr! se vuoi guardare testi un pochino più completi prova: Statistical modeling (specialmente il capitolo 3) Modern statistics for modern biology è molto completo ma decisamente più difficile da leggere e digerire Resta fermo il fatto che per usare bene le funzioni di R ad un certo punto bisogna studiarne l’aiuto. Esempi su come riportare correttamente i risuyltati di un test statistico possono essere trovati qui. anche se sarebbe buona regola formulare solo ipotesi falsificabili, che restano accettabili finché non si prova che sono false↩︎ un gruppo può contenere dei sottogruppi↩︎ dalla versione 4.1 di R è disponibile una pipe nativa, |&gt;↩︎ quindi si combina il risultato delle funzioni mean() e fivenum()↩︎ anche qui, se usassi str(surv_skim) o leggessi l’aiuto di skim ne sapresti di più↩︎ fai riferimento ad un testo di statistica, anche per capire meglio le differenze fra statistiche, calcolate su un campione e parametri, che rappresentano la popolazione, che poi è quello che ci interessa↩︎ ovvimante a porzioni di data frame che contengono solo dati numerici↩︎ però ggplot2 ha una funzione mean_se() ;-)↩︎ e approfitta per domandarsi che succederebbe se facessi la media di una matrice numerica↩︎ questo risultato è ottenuto scrivendo nel testo le sue funzioni e mettendole fra “``”↩︎ incidentalmente qui non è necessario trasformare le variabili categoriche presenti come caratteri in fattori↩︎ se questo è arabo dovresti leggere un libro di statistica o, per esempio, leggere questo articolo↩︎ una tecnica di analisi statistica multivariata che permette di discriminare dei gruppi sulla base di un certo numero di proprietà↩︎ in R base avrei potuto usare vettore_test &lt;- iris$Sepal.Length[iris$Species == \"setosa\"], meno verboso ma anche più oscuro↩︎ per riprodurre i risultati ti basta far girare le istruzioni a gruppi, selezionando dalla prima fino ad arrivare prima del segno%&gt;% che segue l’ultima istruzione che vuoi testare↩︎ Sono 1 in meno del numero di osservazioni. Perché? Perché una volta fissata la media, solo n-1 dei valori possono variare liberamente, l’ultimo è determinato dal valore della media e dagli altri valori…↩︎ "],["reportR.html", "8 Creare report e notebook con R. 8.1 Cosa c’è da imparare in questo capitolo. 8.2 Il minimo indispensabile. 8.3 Gli elementi di un report in R Markdown. 8.4 Altri formati di documento con R Markdown. 8.5 Quarto. 8.6 Altre risorse.", " 8 Creare report e notebook con R. v1.0 9/9/2023 8.1 Cosa c’è da imparare in questo capitolo. Comunicare i risultati delle proprie analisi statistiche è, ovviamente, una necessità per qualsiasi ricercatore. Come avrai notato, l’output (grafici, tabelle, analisi statistiche) prodotto da questo libro compare nel testo, insieme a parti di testo o a immagini statiche disponibili su file: il libro è, in effetti, scritto con bookdown, un pacchetto di R creato apposta per facilitare la scrittura di libri o di articoli lunghi, che si appoggia largamente su rmarkdown, un pacchetto per la creazione di report in un gran numero di formati: notebook e documenti in .html: si possono aprire con qualsiasi browser e possono includere elementi interattivi, creati per esempio con shiny163; documenti in PDF; per questo tipo di documenti è necessario installare sul proprio sistema una implementazione di LaTeX: la versione suggerita è tinyTeX; documenti in MS Word (ma anche in altri formati per wordprocessor, come .odt e .rtf); presentazioni in HTML (con ioslides e Slidy), in PDF (con Beamer) e in powerpoint; una varietà di altri documenti interattivi, come libri e dashboard; rmarkdown è una versione di markdown, un linguaggio minimalista per creare testi contenenti codici di formattazione con dei semplici editor di testi (come per esempio gli script di R creati nel source pane di RStudio). Sia markdown che rmarkdown sono diversi dagli editor di testi cui siamo abituati sotto forma di software di wordprocessing come MS Word, Pages, Google Documents, etc. che dai campi di testo formattato che incontriamo nei moduli interattivi di molti siti web, che, utilizzano menu e barre di accesso rapido, consentono di avere un approccio WYSIWYG (what you see is what you get): se evidenziate una porzione di testo con il mouse e applicate il formato grassetto usando un menu o un comando rapido il testo vi apparirà immediatamente in grassetto. Con le varie versioni di markdown, invece, dovrai applicare dei codici di formattazione (p.es. un testo in grassetto è preceduto e seguito da due asterischi, vedi dopo)164. In questo breve capitolo proverò a fornire il minimo di informazioni per la creazione di semplici report come documenti in HTML e PDF (i due formati leggibili sostanzialmente su qualsiasi piattaforma e facilmente pubblicabili sul web), o in formato leggibile da MS Word (e altri wordprocessor capaci di importare file .docx). In realtà, se hai fretta, il paragrafo 8.2 ti fornisce abbastanza informazioni per creare, con pochissimo sforzo il tuo primo report. 8.2 Il minimo indispensabile. Per essere del tutto sincero con te, il modo più semplice di creare un report è usare la funzione File -&gt; Compile report... di RStudio con uno script di R. Prova tu stess* con questo codice che devi copiare e incollare in un nuovo script (e salvare): #&#39; uno script minimalista con commenti in stile ROxygen print(&quot;hello world!&quot;) #&#39; un riassunto summary(cars) #&#39; un piccolo grafico plot(pressure) File -&gt; Compile report... apre un piccolissimo menu che ti consente di salvare un report che include del testo (estratto dai commenti, vedi dopo), il codice e i risultati dell’analisi in un formato a scelta fra HTML, PDF e MS Word. I commenti scritti con #' sono commenti in stile ROxygen e vengono resi come testo nella compilazione del report. Se si crea un report in un formato editabile (MS Word) è poi facile aprirlo e arricchire i commenti e le discussioni. Tuttavia, il livello di controllo sulla formattazione e le opzioni sono decisamente limitati. Anche per * più pigr* meglio usare Rmarkdown. RStudio fornisce una semplicissima procedura guidata per la creazione di documenti rmarkdown: è sufficiente usare il menu File -&gt; New file -&gt; Rmarkdown... per vedere aprire una finestra interattiva che guida alla creazione di un documento minimo, come mostrato in figura 8.1. *** Figura 8.1: Creare un documento rmarkdown da menu. Il documento può poi essere facilmente modificato per aggiungere altre opzioni o elementi. A questo proposito le versioni più recenti di RStudio offrono 2 opzioni: l’uso di codici di formattazione (vedi figura 8.2) un editor visuale (vedi figura 8.3) Figura 8.2: Source: usare codici di formattazione per documenti RMarkdown. La prima opzione permette la massima flessibilità, con l’uso di codici di formattazione descritti p.es. nel menu Help -&gt; Markdown Quick Reference e dalle Cheat Sheets di RMarkdown (disponibili anche queste nel menu Help -&gt; Cheat Sheets). Per esempio, nella figura 8.2: lo YAML header, che fornisce opzioni generali sul documento è delimitato da --- i chunk di rodice in R sono delimitati tre virgolette singole con {r nomechunk} che indica il nome del chunk (deve essere unico) e le opzioni165 e intestazioni di 2° livello sono precedute da un doppio cancelletto il testo in neretto è preceduto e seguito da un doppio asterisco Inoltre i tasti di accesso rapido nella parte superiore del pane consentono di accedere a varie funzioni: salvare il documento eseguire correzione ortografica (purché la lingua sia impostata correttamente) o eseguire le funzioni cerca e cerca/sostituisci produrre il report (knit) in vari formati (quello definito dall’header, in questo caso .html, o altri), eseguendo il codice dei chunk cambiare le opzioni di visualizzazione inserire chunk di diversi tipi di codice passare da un chunk all’altro far girare uno o più chunk mostrare la struttura del documento166 D’altra parte, il visual editor facilita notevolmente la creazione di report con formattazioni complesse anche a chi proprio non vuole perdere tempo a imparare i codici di formattazione (figura 8.3) Figura 8.3: Visual: documenti RMarkdown usando il visual editor. Il significato dei menu e dei tasti di accesso rapido è molto intuitivo (in alcuni casi è necessario selezionare del testo per applicare uno stile). Usando il visual editor è possibile: applicare rapidamente stili al testo (neretto, italico, codice) applicare stili ai paragrafi (Normal, Heading 1, etc.) creare elenchi puntati e numerati inserire e formattare immagini esterne e link applicare formati addizionali a testi e blocchi inserire una varietà di elementi (figure, blocchi di codice, etc.) inserire e formattare tabelle Prova a creare un documento vuoto e usando File -&gt; New File -&gt; R Markdown ... ed esplora le opzioni dei diversi menu per familiarizzarti. Quanto hai fatto prova a cliccare su Knit nella barra dei menu del source pane o ad aprire il menu Knit e a scegliere un tipo di documento di destinazione. Bene, a questo punto dovresti essere in grado di creare dei semplici report. Prova a utilizzare codice dai capitoli precedenti per arricchirli di figure, tabelle e calcoli, e ad usare il visual editor per cambiare la formattazione. La creazione di presentazioni non è difficile: basta ricordare che le diverse diapositive sono individuate da intestazioni di primo livello (cancelletto singolo). 8.3 Gli elementi di un report in R Markdown. Un report (e più in generale un documento) di R Markdown è caratterizzato da diversi elementi principali: il YAML header: contiene i metadati di base del documento (titolo, autore, tipo di documento, etc.) intestazioni di diveso livello (precedute da uno o più #), che definiscono la struttura del documento blocchi di testo, contenenti opzionalmente formattazioni di diverso tipo, inclusi elenchi puntati e numerati, figure, hyperlink167, equazioni e altro codice in formato LaTeX blocchi di codice (tipicamente di r, ma non solo), delimitati da tre apostrofi singoli (figura 8.2) e da un’intestazione contenente ozioni: come minimo il tipo di blocco (r), il nome del blocco (che deve essere utile), seguiti eventualmente da una virgola che delimita le opzioni. Le opzioni sono numerosissime (vedi la cheat sheet e la chear sheet con il manuale di riferimento di R Markdown) e riguardano: opzioni sull’esecuzione del codice e sul suo inserimento nel documento definitivo: p.es. eval = F significa che il codice del chunk non verrà eseguito mentre include = F significa che il codice verrà eseguito ma non verrà inserito nel docuemnto finale. In generale un primo chunk con il nome setup può contenere opzioni globali che si applicano a tutti i chunk successivi. opzioni sulle figure: risoluzione (p.es. dpi = 96), dimensioni (fig.height, fig.width) e molte altre opzioni sui risultati: includono la possibilità di mostrare errori, warning, messaggi e molto altro etc. Un altro elemento importante è la presenza di codice in line: si tratta di brevi frammenti di codice delimitati da virgolette singole del tipo: “r mean(mpg$hwy, na.rm = F)” (qui ho usato le virgolette doppie per non far eseguire il codice). Questi frammenti di codice, di solito composti da un solo comando molto breve possono servire a inserire in modo riproducibile numeri all’interno del testo. Per esempio, ammettiamo che un dato documento riporti, fra le altre cose, dati metereologici di una determinata area per un determinato intervallo di tempo. Invece di dover inserire manualmente ogni volta che si aggiornano i dati la temperatura media, è sufficiente calcolarla in un frammento di codice in line. Le possibilità di formattazione di R Markdown sono veramente incredibili ed esulano dagli sopi di questo testo: per approfondire puoi usare il materiale citato nella sezione 8.6. 8.4 Altri formati di documento con R Markdown. Oltre che dei report contenenti testo e risultati di analisi R Markdown consente di produrre molti altri formati di documento. I principali sono: le presentazioni: PDF con beamer, HTML con ioslides, slidy o reveal.js, PowerPoint le dashboard: create con flexdashboard o altri strumenti, sono un modo flessibile per mostrare risultati di analisi statistiche e grafiche documenti interattivi con htmlwidgets e Shiny che permettono agli utenit di interagire con l’analisi tramite menu e campi di testo Inoltre, è possibile creare libri e documenti complessi con bookdown e creare persino siti web. La creazione delle presentazioni non è molto difficile. Usando le cheat sheet è relativamente facile creare delle semplici presentazioni, tenendo conto che le intestazioni di primo livello e secondo livello creano le slide, che possono anche essere separate manualmente da ---. Insomma, c’è un po’ da studiare, ma le possibilità di counicazione sono veramente notevoli (e vanno ben oltre lo scopo, limitato, di questo testo). 8.5 Quarto. Le versioni più recenti di RStudio supportano anche Quarto, un sistema di pubblicazione scientifica forse più complesso, articolato e flessibile di rmarkdown. Una guida completa è qui. 8.6 Altre risorse. 8.6.1 Risorse in italiano. Tranne qualche articolo di blog, che potete trovare facilmente con un ricerca con il vostro motore di ricerca preferito, francamente, non ho trovato niente di notevole. 8.6.2 Risorse in inglese. Come sempre, c’è a scegliere il punto di partenza migliore è sicuramente il menu Help di RStudio, con una quick reference su Markdown e un paio di utilissime cheatsheet, che è bene tenere sempre a portata di mano il sito di Posit fornisce un’eccellente introduzione a rmarkdown: un po’ lunghetta, ma vale la pena sul sito di bookdown, oltre a tante altre belle cose (si fa per dire) ci sono: un libro di ricette e una guida completa a rmarkdown, entrambe ottime guide di riferimento, ma un tantino pesanti da leggere un testo molto completo sulla pubblicazione di libri con bookdown: anche questo completo e autorevole, ma un tantino pesante la differenza fra i due tipi di documento è che i notebook sono più utili nella fase di scrittura e per persone più esperte nell’uso di R perché consentono di far girare indipendentemente i singoli “chunk” di codice producendo il loro output immediatamente sotto il chunk, mentre i documenti HTML sono destinati, come dire, agli utilizzatori finali, che possono anche non avere nessuna esperienza in R. Fra le altre cose, i notebook danno come risultato un file con estensione .nb.html, che contiene sia il documento definitivo che il file .Rmd, che può essere estratto e riutilizzato; tuttavia, i notebook potrebbero non funzionare correttamente se si lavora con alcuni sistemi di cloud, come Google Drive, che potrebbero creare difficoltà con la sincronizzazione della cache del notebook.↩︎ in realtà, le versioni più recenti di RStudio mettono a disposizione un editor visuale↩︎ è possibile inserire anche chunk di altri linguaggi, come Python, C++, Stan, etc.↩︎ è consigliabile uno schermo grande↩︎ un hyperlink ha il formato [testo](URL)↩︎ "],["wrangling.html", "9 Lottare con i dati. 9.1 Cosa c’è da imparare in questo capitolo. 9.2 Rendere tidy i dati. 9.3 il cavallo di battaglia del data wrangling: dplyr. 9.4 Strutture di controllo. 9.5 La soluzione dell’esercizio. 9.6 Altre risorse.", " 9 Lottare con i dati. v1.1.1 5/11/2023 9.1 Cosa c’è da imparare in questo capitolo. Partiamo da un fatto, del quale ti renderai conto appena inizierai ad usare R per analisi non interattive: le attività di preparazione e manipolazione (data wrangling in inglese: filtrare, ordinare, aggiungere e rimuovere colonne, unire file, cambiare la struttura di tabelle di dati, etc…) possono arrivare a “consumare” il 60% del tempo di un progetto di analisi (statistica) dei dati. È ovvio che sarebbe bene farlo in modo efficiente, trasparente e riproducibile. Eppure, questa è sicuramente l’attività più “respingente” per chi si accosta all’analisi statistica senza nessuna esperienza di programmazione. D’altra parte, proprio per l’importanza del data wrangling, e in generale, della programmazione in R, il materiale (ovviamente in inglese) disponibile, gratuitamente, in rete, sotto forma di filmati, libri, pagine web etc. è praticamente sterminato e, detto francamente, non credo proprio di poter fare di meglio. Quindi, come al solito, proverò ad indicare un percorso di apprendimento minimo, costruito attorno al tidyverse. La ragione è sempre la stessa: mentre tutte le operazioni di data wrangling possono essere realizzate con funzioni di R base (o con funzioni scritte dall’utente) la “logica” del tidyverse e della grammatica dei dati è sicuramente più vicina al linguaggio naturale. Se pensi di usare R prevalentemente in modo interattivo, e non hai una particolare necessità di automatizzare e rendere ripetibili i tuoi flussi di analisi, puoi tranquillamente saltare questo capitolo, senza rimorsi (ammesso che tu ne abbia mai avuti168). Altrimenti, ti tocca leggerlo più o meno tutto, magari scegliendo cosa approfondire in seguito, se e quando ti servirà169. Il capitolo è organizzato intorno alle principali operazioni di “manipolazione” dei dati, organizzati in data frame o tibble (vedi Paragrafo 4.6.1), che, in genere devono essere combinate in un flusso non sempre lineare: rendere “tidy” i dati (con tidyr in combinazione con dplyr) passare dai formati long a wide, e viceversa con pivot_wider e pivot_longer unire diverse colonne con unite o separare una colonna in più colonne con separate filtrare i dati (estraendo gruppi di osservazioni da un data frame o una tibble) con dplyr::filter selezionare o rinominare un sottoinsieme di colonne con dplyr::select o dplyr::rename riordinare i dati con dplyr::arrange trasformare i dati usando una varietà di funzioni native di R, o disponibili in pacchetti o create dall’utente con dplyr::mutate o dplyr::transmute riassumere più osservazioni in un’unica osservazione usando funzioni che prendono vettori come input (come per esempio mean(), sum(), etc.) unire diversi data frame usando variabili chiave con il gruppo di comandi join di dplyr E molto altro ancora… Questo approccio ha alcune cose in comune: si parte da un data frame o una tibble, in generale all’inizio di un percorso di comandi separati da pipe: è l’oggetto dell’analisi si applicano una serie di funzioni (i verbi), eventualmente operando su gruppi di dati (individuati da dplyr::group_by o dall’argomento .by) sottoinsiemi di colonne con una modalità chiamata tidy evaluation, che non richiede l’uso delle modalità di selezione di R base (vedi paragrafo 4.8); avverbi (come across e where) possono essere usati per individuare in maniera più generale le variabili su cui operare; incidentalmente, nei comandi dei pacchetti del tidyverse non è necessario usare le notazioni con il $ nè le virgolette per indicare le variabili, come del resto hai già visto nel Capitolo 6, il che è una gran bella comodità. il risultato di queste operazioni è, come sempre, un oggetto (spesso una tibble), che può essere assegnato ad un nome o inviato alla console o far parte di un effetto collaterale (come il salvataggio di un file o la produzione di un grafico) In definitiva, si usa una vera e propria grammatica dei dati che rende le serie di comandi (i periodi) molto più comprensibili. Ne vedrai diversi esempi nei paragrafi successivi. Se ve lo state chiedendo la pipe è un operatore che passa i dati dal comando a sinistra a quello a destra. Le pipe sono state introdotte originariamente con il pacchetto magrittr(https://magrittr.tidyverse.org) che usa come pipe principale %&gt;% (che hai visto già usare molto in questo libro). R 4.1 ha introdotto una pipe nativa, |&gt;, che si comporta in modo abbastanza simile alla pipe di magrittr. Ovviamente le strutture di dati di R non sono solo data frame, ed esistono strumenti molto più flessibili, come quelli di reshape2 (l’equivalente di tidyr) e plyr (l’equivalente di dplyr), che operano anche su matrici, array e liste, oppure i comandi di data.table, ottimizzati per oggetti di granid dimensioni. Infine, un flusso di lavoro può richiedere strutture di controllo che permettono di ripetere operazioni (i loop vedi Paragrafo 9.4.1) o svolgerle in modo condizionale (le strutture tipo if...else, vedi Paragrafo 9.4.3). I loop, che sono tipicamente lenti e verbosi intermini di codice, possono essere spesso sostituiti da “functionals” (vedi Paragrafo 9.4.2), funzioni che prendono come argomento altre funzioni e le applicano a vettori o strutture di altro tipo, spesso in maniera parallela. Cose utili, ma noiose: se vuoi puoi saltarle. 9.2 Rendere tidy i dati. Del concetto dei dati tidy ho già parlato altrove (vedi paragrafo 4.1.5). Mentre i dati tidy si riconoscono subito, quelli untidy possono avere moltissimi priblemi diversi (inclusa dati mancanti in maniera implicita vedi paragrafo 4.1.6). Prova a usare questo codice in uno script nel source pane: require(tidyverse) # tidyr fa fa parte del tidyverse data(cms_patient_care) ?cms_patient_care View(cms_patient_care) data(billboard) ?billboard View(billboard) data(who) ?who View(who) data(relig_income) ?relig_income View(relig_income) cms_patinet_care contiene più tipi di misure (measure_abbr) in una sola variabile (score) e dovrebbe essere trasformato da long a wide; billboard ha il problema inverso: i dati della posizione in classifica sono nelle variabili wk1-wk76: dovremmo creare una variabile wk e trasformare da wide a long; potremmo poi rimuovere “wk” dalle entries della variabile wk e trasformarla in numerica; who è un data set molto grande con una parte del report sulla tubercolosi della World Health Organization ed è letterlamente un incubo fatto di dati in formato sbagliato (wide, mentre dovrebbe essere long) e di nomi di variabili che contengono informazioni che dovrebbero formare altre variabili (metodi di diagnosi, genere, gruppo di età) relig_income è un incubo di variabili con nomi non sintattici (vedi paragrafo 4.3 con dati di una sola variabile, la conta delle persone che ricadono in una determinata combinazione di religione e classe di reddito, sparsi in più variabili La vignetta “pivot” di tidyr illustra come rendere ordinati molti di questi data frame. Prova ora a capire che operazioni dovresti compiere per rendere tidy i seguenti data set: tidyr::construction tidyr::us_rent_income tidyr::world_bank_pop (qui potresti anche pensare a come puoi ricavare dati da who) 9.2.1 Riordinare con tidyr e dplyr: esempio minimo. Ora creiamo due piccolissimi data set di esempio per illustrare alcune delle funzioni di tidyr e dplyr. mlab &lt;- tribble( ~Specie, ~Specie_b, ~Ceppo_specie, ~Repl, ~niente, ~H, ~HM, ~M, &quot;Lb_brevis&quot;, &quot;L_br&quot;, &quot;L_br_E06&quot;, &quot;a&quot;, 0.40, 0.40, 0.36, 0.41, &quot;Lb_brevis&quot;, &quot;L_br&quot;, &quot;L_br_E06&quot;, &quot;b&quot;, 0.30, 0.35, 0.35, 0.36, &quot;Leuc_mesenteroides&quot;, &quot;Le_me&quot;, &quot;Le_me_E08&quot;, &quot;a&quot;, 0.73, 0.82, 0.74, 0.76, &quot;Leuc_mesenteroides&quot;, &quot;Le_me&quot;, &quot;Le_me_E08&quot;, &quot;b&quot;, 0.63, 0.71, 0.61, 0.68, &quot;Leuc_mesenteroides&quot;, &quot;Le_me&quot;, &quot;Le_me_E09&quot;, &quot;a&quot;, 0.65, 0.78, 0.89, 0.63, &quot;Leuc_mesenteroides&quot;, &quot;Le_me&quot;, &quot;Le_me_E09&quot;, &quot;b&quot;, 0.62, 0.81, 0.82, 0.61, &quot;Leuc_citreum&quot;, &quot;Le_ci&quot;, &quot;Le_ci_E05&quot;, &quot;a&quot;, 0.65, 0.86, 0.86, 0.70, &quot;Leuc_citreum&quot;, &quot;Le_ci&quot;, &quot;Le_ci_E05&quot;, &quot;b&quot;, 0.79, 0.83, 0.86, 0.66 ) chiave_lab &lt;- tribble( ~abbr_genere, ~abbr_specie, ~genere, ~specie, &quot;L&quot;, &quot;br&quot;, &quot;Levilactobacillus&quot;, &quot;brevis&quot;, &quot;Le&quot;, &quot;me&quot;, &quot;Leuconostoc&quot;, &quot;mesenteroides&quot;, &quot;Le&quot;, &quot;ci&quot;, &quot;Leuconostoc&quot;, &quot;citreum&quot; ) E visualizziamo la prima tabella: require(kableExtra) knitr::kable(mlab, digits =2, caption = &quot;Crescita di batteri lattici (assorbanza a 650 nm) in presenza di diversi supplementi.&quot;, &quot;html&quot;) %&gt;% kable_styling(&quot;striped&quot;) %&gt;% scroll_box(width = &quot;100%&quot;) Tabella 9.1: Crescita di batteri lattici (assorbanza a 650 nm) in presenza di diversi supplementi. Specie Specie_b Ceppo_specie Repl niente H HM M Lb_brevis L_br L_br_E06 a 0.40 0.40 0.36 0.41 Lb_brevis L_br L_br_E06 b 0.30 0.35 0.35 0.36 Leuc_mesenteroides Le_me Le_me_E08 a 0.73 0.82 0.74 0.76 Leuc_mesenteroides Le_me Le_me_E08 b 0.63 0.71 0.61 0.68 Leuc_mesenteroides Le_me Le_me_E09 a 0.65 0.78 0.89 0.63 Leuc_mesenteroides Le_me Le_me_E09 b 0.62 0.81 0.82 0.61 Leuc_citreum Le_ci Le_ci_E05 a 0.65 0.86 0.86 0.70 Leuc_citreum Le_ci Le_ci_E05 b 0.79 0.83 0.86 0.66 La tabella 9.1 riporta alcuni dati di un esperimento in cui 2 supplementi (H emina, M menaquinone) sono stati aggiunti da soli o in combinazione, ad un substrato per la crescita di batteri lattici, appartenenti a diverse specie. Nei dati originali erano presenti più ceppi (entità al di sotto della specie) per ciascuna specie. Le prime tre colonne contengono informazioni in parte incomplete (manca un’indicazione estesa del nome di genere presente nella seconda tabella), in parte ridondanti (la combinazione dell’abbreviazione specie_genere compare due volte), in parte contenute in altre colonne (la sigla del ceppo, E06 etc. è presente in una colonna che include anche l’abbreviazione di genere e specie). Inoltre la variabile misurata è in realtà una sola (la crescita, misurata come assorbanza - una misura indiretta della torbidità di un substrato in seguito alla crescita di microrganismi - a 650 nm). Inoltre, i dati delle specie sono contenuti in una seconda tabella: knitr::kable(chiave_lab, caption = &quot;Abbreviazioni di genere e specie per alcuni batteri lattici.&quot;, &quot;html&quot;) %&gt;% kable_styling(&quot;striped&quot;) %&gt;% scroll_box(width = &quot;100%&quot;) Tabella 9.2: Abbreviazioni di genere e specie per alcuni batteri lattici. abbr_genere abbr_specie genere specie L br Levilactobacillus brevis Le me Leuconostoc mesenteroides Le ci Leuconostoc citreum Nota come nella tabella 9.2 manchi una colonna che unisca le abbreviazioni di genere e specie, in modo da fornire una chiave univoca che metta in corrispondenza le osservazioni di questa tabella con quelle della tabella 9.1. Qui potremmo essere interessati a compiere le seguenti operazioni: trasformare il file da formato “largo” (wide), a “lungo”, creando una variabile che contenga i nomi delle prime 4 colonne (i diversi tipi di substrato) e un’altra che contenga i valori; estrarre la sigla del ceppo creare nella tabella 9.2 una nuova colonna unendo le colonne con l’abbreviazione di genere e specie aggiungere (merge) le informazioni della tabella 9.2 alla 9.1 (lo faremo più avanti, vedi paragrafo 9.3.5) Questo formato ci permetterebbe, fra le altre cose di eseguire una serie di analisi statistiche (per esempio il calcolo della media, per gruppi, delle due repliche, o un’analisi della varianza). Ora dimostrerò le prime 2 operazioni, seguite dal calcolo della media, usando comandi di tidyre dplyr, due pacchetti del tidyverse. # da largo a lungo mlab_lungo &lt;- mlab %&gt;% pivot_longer(cols = niente:M, names_to = &quot;trattamenti&quot;, values_to = &quot;A650&quot;) # le prime 8 righe head(mlab_lungo, 8) ## # A tibble: 8 × 6 ## Specie Specie_b Ceppo_specie Repl trattamenti A650 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Lb_brevis L_br L_br_E06 a niente 0.4 ## 2 Lb_brevis L_br L_br_E06 a H 0.4 ## 3 Lb_brevis L_br L_br_E06 a HM 0.36 ## 4 Lb_brevis L_br L_br_E06 a M 0.41 ## 5 Lb_brevis L_br L_br_E06 b niente 0.3 ## 6 Lb_brevis L_br L_br_E06 b H 0.35 ## 7 Lb_brevis L_br L_br_E06 b HM 0.35 ## 8 Lb_brevis L_br L_br_E06 b M 0.36 # e ora le medie, creando, in più una variabile che contenga solo # la sigla del ceppo mlab_medie &lt;- mlab_lungo %&gt;% separate(Ceppo_specie, into = c(&quot;gen&quot;,&quot;sp&quot;,&quot;ceppo&quot;), remove = F) %&gt;% dplyr::summarise(mediaA650 = mean (A650), .by = c(&quot;Ceppo_specie&quot;, &quot;trattamenti&quot;)) # le prime 8 righe head(mlab_medie, 8) ## # A tibble: 8 × 3 ## Ceppo_specie trattamenti mediaA650 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 L_br_E06 niente 0.35 ## 2 L_br_E06 H 0.375 ## 3 L_br_E06 HM 0.355 ## 4 L_br_E06 M 0.385 ## 5 Le_me_E08 niente 0.68 ## 6 Le_me_E08 H 0.765 ## 7 Le_me_E08 HM 0.675 ## 8 Le_me_E08 M 0.72 Nota che qui l’argomento cols di pivot_longer individua le colonne da utilizzare nell’operazione di “fusione” del data frame mentre names_to e values_to indicano i nomi delle variabili che conterranno rispettivamente i nomi delle colonne che vengono “fuse” ho usato l’argomento .by per ottenere una media per gruppi con summarise ho separato la colonna Ceppo_specie in tre elementi usando separate, eliminando poi quelli che non servivano con select; consulta l’aiuto di separate per capire come è possibile omettere o indicare il carattere che separa gli elementi che vogliono disporre in colonne diverse Incidentalmente, quello che abbiamo creato è un minimal reproducible example che è molto utile per fornire un minimo di elementi riproducibili quando si chiede aiuto in un forum (vedi sezione 3.3). Abbastanza prevedibilmente, il comando che in tidyr fa la cosa opposta a separate è unite: chiave_lab &lt;- chiave_lab %&gt;% unite(col = &quot;gen_specie_abbr&quot;, abbr_genere:abbr_specie, remove = F, sep = &quot;_&quot;) chiave_lab ## # A tibble: 3 × 5 ## gen_specie_abbr abbr_genere abbr_specie genere specie ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 L_br L br Levilactobacillus brevis ## 2 Le_me Le me Leuconostoc mesenteroides ## 3 Le_ci Le ci Leuconostoc citreum Bene, ora proviamo a fare il contrario, passando dal formato “long” a quello “wide”. Prova prima di tutto questo codice, che restituirà un errore: mlab_lungo %&gt;% dplyr::select(!Repl) %&gt;% pivot_wider(names_from = trattamenti, values_from = A650) il problema è causato dalla rimozione della variabile Repl, che identificava in maniera unica i valori che devono essere inseriti nelle celle delle nuove variabili (i trattamenti). Infatti con valori unici il problema non si pone: mlab_medie %&gt;% pivot_wider(names_from = trattamenti, values_from = mediaA650) Fortunatamente, le ultime versioni di tidyr permettono di usare una funzione per aggregare dati multipli170. Nell’esempio che segue usiamo la media: mlab_lungo %&gt;% dplyr::select(!Repl) %&gt;% pivot_wider(names_from = trattamenti, values_from = A650, values_fn = mean) ## # A tibble: 4 × 7 ## Specie Specie_b Ceppo_specie niente H HM M ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lb_brevis L_br L_br_E06 0.35 0.375 0.355 0.385 ## 2 Leuc_mesenteroides Le_me Le_me_E08 0.68 0.765 0.675 0.72 ## 3 Leuc_mesenteroides Le_me Le_me_E09 0.635 0.795 0.855 0.62 ## 4 Leuc_citreum Le_ci Le_ci_E05 0.72 0.845 0.86 0.68 Naturalmente, ci sono molti più casi che tidyr può risolvere brillantemente, come la gestione dei dati mancanti oppure la gestione di colonne multiple durante il passaggio da “long” a “wide”. Se ne avessi bisogno, puoi consultare la vignetta “pivot” di tidyr scrivendo nella console: vignette(&quot;pivot&quot;, package = &quot;tidyr&quot;) 9.2.2 Funzioni avanzate con tidyr. tidyr, usato in combinazione con broom e dplyr può fare cose veramente pazzesche. Le operazioni per creare nested data frames (dataframe annidati, in cui una delle colonne è una colonna di data frames171) e trasformarli di nuovo in data frame convenzionali permettono di automatizzare molte analisi statistiche. I due comandi rilevanti sono nest() e unnest() Prova a vedere cosa succede con questo codice per capire cos’è un nested data frame: data(mpg) glimpse(mpg) mpg %&gt;% group_by(class) %&gt;% nest() # o anche mpg %&gt;% nest(.by = class) L’argomento va un po’ oltre quello che posso trattare qui, quindi, se sei interessat* ti consiglio di leggere le vignette di tidyr e broom, o, meglio, il capitolo sui tidy data della versione italaiana di “R for data science”. Un argomento correlato è il rectangling, cioè la trasformazione di liste annidate (che spesso derivano dall’importanzione di dati in formati JSON o XML): l’uso di comandi come unnest_wider() e hoist() può facilitare questi compiti, come dimostrato nella vignetta relativa: vignette(&quot;rectangle&quot;, package = &quot;tidyr&quot;) 9.3 il cavallo di battaglia del data wrangling: dplyr. dplyr, insieme a ggplot2 è decisamente il pacchetto del tidyverse che ti troverai ad usare più spesso. Le funzioni sono tantissime e, abbastanza ovviamente, hanno equivalenti nelle funzioni di R base e di alcuni pacchetti precedenti, come plyr. Per confrontare le funzioni prova a scrivere nella console: `library(dplyr) vignette(\"base\", package=\"dplyr\") Qui mi limiterò a darti qualche esempio delle funzioni principali, raggruppandole in maniera, spero, logica. Ti accorgerai come quasi tutte le funzioni che ti mostrerò qui sono comparse nei capitoli precedenti e, tanto per cambiare, userò il data set mpg. 9.3.1 Estrarre gruppi di righe o colonne. Abbastanza prevedibilmente il comando che si usa per filtrare le osservazioni in base ad uno o più criteri è dplyr::filter()172. Filter prende come argomento un data frame o una tibble, applica una condizione logica che individua una combinazione di osservazioni e restituisce (come tibble) il risultato. Guarda che succede: data(mpg, verbose = F) glimpse(mpg) ## Rows: 234 ## Columns: 11 ## $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… ## $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… ## $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… ## $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… ## $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, … ## $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… ## $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… ## $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… ## $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… ## $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… ## $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… Selezioniamo le auto con 4 cilindri prodotte da audi audi4 &lt;- mpg %&gt;% dplyr::filter(cyl == 4 &amp; manufacturer == &quot;audi&quot;) glimpse(audi4) ## Rows: 8 ## Columns: 11 ## $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… ## $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;a4 quattro&quot;, &quot;a4 q… ## $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 1.8, 1.8, 2.0, 2.0 ## $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 2008 ## $ cyl &lt;int&gt; 4, 4, 4, 4, 4, 4, 4, 4 ## $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;manu… ## $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot; ## $ cty &lt;int&gt; 18, 21, 20, 21, 18, 16, 20, 19 ## $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 25, 28, 27 ## $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot; ## $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… Selezioniamo le auto con che percorrono almeno 25 km con un gallone in autostrada hwy25 &lt;- mpg %&gt;% dplyr::filter(hwy &gt;= 25 ) glimpse(hwy25) ## Rows: 116 ## Columns: 11 ## $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… ## $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… ## $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… ## $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… ## $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 8, 8, 8, … ## $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… ## $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… ## $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… ## $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… ## $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… ## $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… dplyr::filter() quindi usa un’espressione che restituisce un vettore logico (contenente vero per le osservazioni che soddisfano l’espressione, e che verranno mantenute nel data frame filtrato, e falso per quelle che non la soddisfano, che verranno espluse). Gli operatori logici, che possono essere usati in combinazioni abbastanza complesse sono stati trattati nel paragrafo 4.10.1. Analoga alla necessità di estrarre alcune righe è quella di estrarre alcune colonne: il comando corrispondente è dplyr::select(). La sintassi, basata sulla non-standard evaluation, è molto più semplice di quella di R base (vedi sezione 4.8). Prova a usare i seguenti comandi in uno script: # selezionare le colonne per nome mpg %&gt;% dplyr::select(model, year, cyl) # selezionare per posizione (e riordinare le colonne) usando l&#39;operatore OR (|) mpg %&gt;% dplyr::select(11 | 2 | 9:8) # escludere colonne con l&#39;operatore NOT (!) mpg %&gt;% dplyr::select(!year &amp; !trans) # ma anche mpg %&gt;% dplyr::select(!c(year,trans)) # selezionare e rinominare mpg %&gt;% dplyr::select(modello = model, anno = year, cilindri = cyl) Incidentalmente, è possibile usare la funzione rename(nuovo_nome = vecchio_nome) per rinominare colonne, con lo stesso criterio che hai appena visto. Come altre funzioni, dplyr::select() può usare l’avverbio where() per selezionare colonne in modo programmatico. where() e alcune funzioni helper (contains, starts_with, etc.173) individuano delle condizioni logiche per la selezione di colonne in base a condizioni più specifiche. Ecco alcuni esempi, che puoi provare nella console o in uno script: # la colonna model e tutte le colonne numeriche mpg %&gt;% dplyr::select(model | where(is.numeric)) # le colonne che contengono la lettera y mpg %&gt;% dplyr::select(contains(&quot;y&quot;)) 9.3.2 Riordinare i dati. Ordinare le righe sulla base di uno o più criteri, in ordine discendente o ascendente, è facilissimo con dplyr::arrange(). L’ordinamento di default è ascendente; per ottenere un ordinamento in ordine decrescente si usa desc(). Si tratta di comandi molto intuitivi174 # non ordinato head(mpg, 10) ## # A tibble: 10 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # ordinato in ordine crescente di numero di cilindri e decrescente per # miglia per gallone in autostrada mpg %&gt;% arrange(cyl, desc(hwy)) %&gt;% head() ## # A tibble: 6 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen jetta 1.9 1999 4 manua… f 33 44 d comp… ## 2 volkswagen new beetle 1.9 1999 4 manua… f 35 44 d subc… ## 3 volkswagen new beetle 1.9 1999 4 auto(… f 29 41 d subc… ## 4 toyota corolla 1.8 2008 4 manua… f 28 37 r comp… ## 5 honda civic 1.8 2008 4 auto(… f 25 36 r subc… ## 6 honda civic 1.8 2008 4 auto(… f 24 36 c subc… 9.3.3 Trasformare con mutate(). Hai già visto parecchi esempi di come sia possibile trasformare una colonna con un’operazione più o meno complessa con dplyr::mutate(). L’approccio è molto più semplice di quello utilizzato in R base, anche perché è possibile trasformare diverse colonne creandone di nuove in un unico comando in maniera simile a base::transform(), ma con parecchie più opzioni (che puoi scoprire leggendo l’aiuto). Confronta questi tre esempi (che puoi eseguire in uno script): tutti e tre fanno la stessa cosa (trasformano i consumi in mpg da miglia per gallone a litri per 100 km). library(tidyverse) library(magrittr) # per la assignment pipe data(mpg, verbose = F) # usando $ mpg$hwyl100km &lt;- mpg$hwy*235.21 mpg$ctyl100km &lt;- mpg$cty*235.21 # usando transform mpg &lt;- base::transform(mpg, hwyl100km = 235.21/hwy, ctyl100km = 235.21/cty) # usando mutate mpg &lt;- mpg %&gt;% mutate( hwyl100km = 235.21/hwy, ctyl100km = 235.21/cty ) # usando la assignment pipe, anch&#39;essa disponibile nel pacchetto magrittr mpg %&lt;&gt;% mutate( hwyl100km = 235.21/hwy, ctyl100km = 235.21/cty ) # creando una nuova tibble in cui le colonne usate # per il calcolo sono rimosse (si potrebbe fare con select) mpg2 &lt;- mpg %&gt;% mutate( hwyl100km = 235.21/hwy, ctyl100km = 235.21/cty, .keep = &quot;unused&quot; ) L’opzione .keep è piuttosto flessibile e permette, utilizzando l’opzione “none” di sostituire il vecchio comando transmute(), che produceva una nuova tibble contenente solo le colonne risultanti dal calcolo. mutate() è un comando molto flessibile e trova applicazioni interessanti insieme ai comandi di broom, un pacchetto che, come ti ho già mostrato (paragrafo 7.5.3), piuttosto che rendere tidy i dati rende tidy i risultati delle analisi statistiche. Quando si desidera eseguire la stessa trasformazione su variabili multiple con mutate() è possibile utilizzare la combinazione di “avverbi” across() e where(). Ecco tre piccolissimi esempi (da eseguire alla console) Il primo esempio moltiplica per 1000 le prime due variabili numeriche e il secondo ne calcola il logaritmo decimale &gt;mpg3 &lt;- mpg %&gt;% mutate(across(displ:year, ~.x*1000)) &gt;mpg4 &lt;- mpg %&gt;% mutate(across(displ:year, log10)) ~.x*1000 definisce quella che si chiama lambda o funzione anonima. Qui ho usato la notazione del pacchetto purrr. Due alternative: &gt;mpg3 &lt;- mpg %&gt;% mutate(across(displ:year, function(x) x*1000)) &gt;mpg3 &lt;- mpg %&gt;% mutate(across(displ:year, \\(x) x*1000)) L’ultima opzione è stata introdotta con R 4.1 (ed è difficile dire se sia un miglioramento…). Infine, con where(), che hai già incontrato nel paragrafo 9.3.1 e che con mutate() si usa all’interno di across() possiamo, per esempio, trasformare in fattori le colonne che sono di tipo carattere: mpg5 &lt;- mpg %&gt;% mutate(across(where(is.character), as.factor)) L’argomento è un pochino complesso per questo libro, quindi, se sei interessat* ti consiglio di leggere l’aiuto di across(). 9.3.4 Riassumere i dati con summarise(). mutate() trasforma i dati creando una nuova osservazione per ciascuna osservazione presente nel data frame originale. summarise() invece, riassume gruppi di osservazioni in un unico valore, ed è particolarmente interessante per calcolare statistiche riassuntive come hai visto nel paragrafo 7.4.3. Qui ti faccio solo alcuni esempi, utilizzando fra le altre cose, l’opzione group_by(): mpg_riassunto &lt;- mpg %&gt;% group_by(manufacturer, class) %&gt;% dplyr::summarise( media_hwy = mean(hwy, na.rm = T), devst_why = sd(hwy, na.rm = T), media_cty = mean(hwy, na.rm = T), devst_cty_cty = sd(hwy, na.rm = T) ) %&gt;% ungroup() ## `summarise()` has grouped output by &#39;manufacturer&#39;. You can override using the ## `.groups` argument. mpg_riassunto ## # A tibble: 32 × 6 ## manufacturer class media_hwy devst_why media_cty devst_cty_cty ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 audi compact 26.9 2.02 26.9 2.02 ## 2 audi midsize 24 1 24 1 ## 3 chevrolet 2seater 24.8 1.30 24.8 1.30 ## 4 chevrolet midsize 27.6 1.82 27.6 1.82 ## 5 chevrolet suv 17.1 2.20 17.1 2.20 ## 6 dodge minivan 22.4 2.06 22.4 2.06 ## 7 dodge pickup 16.1 2.21 16.1 2.21 ## 8 dodge suv 16 2 16 2 ## 9 ford pickup 16.4 0.787 16.4 0.787 ## 10 ford subcompact 23.2 2.17 23.2 2.17 ## # ℹ 22 more rows Il comando ungroup() serve per rimuovere il raggruppamento. Un modo più semplice nelle versioni recenti di dplyr è usare l’opzione .by. mpg_riassunto &lt;- mpg %&gt;% dplyr::summarise( media_hwy = mean(hwy, na.rm = T), devst_why = sd(hwy, na.rm = T), media_cty = mean(hwy, na.rm = T), devst_cty_cty = sd(hwy, na.rm = T), .by = c(manufacturer, class) ) mpg_riassunto Incidentalmente, con across() e where() si possono fare cose interessanti. Prova questo: &gt;mpg %&gt;% dplyr::summarise(across(where(is.numeric), list(media = mean, devst = sd)), .by = class) Carino, no? Come esercizio, partendo da mpg, riusciresti a creare una tabella in cui, dopo aver calcolato (raggruppate per class) media e deviazione standard di hwy e cyl, arrotondare a due cifre decimali il risultato e poi unire media e dev. st. in un’unica colonna separandole con il carattere “±”? Come suggerimento: sevi usare una combinazione di summarise con across e .by, poi usare le funzioni round e unite... Se proprio non ce la fai, vai al paragrafo 9.5. 9.3.5 Database e tabelle relazionali: unire tabelle con _join. In molte situazioni i dati di cui abbiamo bisogno sono dispersi in più tabelle, collegate da una qualche chiave (per esempio un valore unico per una o più osservazioni presente in una colonna in due tabelle diverse). Unire tabelle per righe o colonne è possibile (con alcune limitazioni) usando comandi come bind_cols() e bind_rows() (due comandi di dplyr che corrispondono a cbind() e rbind()). Guarda questi due esempi, basati come al solito su Arthritis: data(Arthritis) # il comando slice() consente di selezionare righe A1 &lt;- Arthritis %&gt;% slice(1:52) A2 &lt;- Arthritis %&gt;% slice(53:84) A3 &lt;- bind_rows(A1,A2) head(A3) ## ID Treatment Sex Age Improved ## 1 57 Treated Male 27 Some ## 2 46 Treated Male 29 None ## 3 77 Treated Male 30 None ## 4 17 Treated Male 32 Marked ## 5 36 Treated Male 46 Marked ## 6 23 Treated Male 58 Marked identical(A3, Arthritis) ## [1] TRUE # è possibile perché sono presenti le stesse colonne A4 &lt;- Arthritis %&gt;% dplyr::select(ID:Sex) A5 &lt;- Arthritis %&gt;% dplyr::select(Age:Improved) A6 &lt;- bind_cols(A4,A5) head(A6) ## ID Treatment Sex Age Improved ## 1 57 Treated Male 27 Some ## 2 46 Treated Male 29 None ## 3 77 Treated Male 30 None ## 4 17 Treated Male 32 Marked ## 5 36 Treated Male 46 Marked ## 6 23 Treated Male 58 Marked identical(A6,Arthritis) ## [1] TRUE La situazione diventa un po’ più complessa se volessimo unire le informazioni presenti nei due file creati nel paragrafo 9.2.1. Per farlo, potremmo per esempio creare in chiave_lab una colonna contenente l’abbreviazione di genere e specie unite da “_” e poi usare questa colonna come chiave per aggiungere i nomi estesi di genere e specie. Per farlo, possiamo usare i verbi a due tabelle _join di dplyr. Guarda cosa succede: chiave_lab_2 &lt;- chiave_lab %&gt;% unite(&quot;Specie_b&quot;, abbr_genere, abbr_specie, sep = &quot;_&quot;) %&gt;% dplyr::select(Specie_b, genere, specie) mlab_2 &lt;- left_join(mlab,chiave_lab_2) ## Joining with `by = join_by(Specie_b)` head(mlab_2) ## # A tibble: 6 × 10 ## Specie Specie_b Ceppo_specie Repl niente H HM M genere specie ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Lb_brevis L_br L_br_E06 a 0.4 0.4 0.36 0.41 Levil… brevis ## 2 Lb_brevis L_br L_br_E06 b 0.3 0.35 0.35 0.36 Levil… brevis ## 3 Leuc_mesen… Le_me Le_me_E08 a 0.73 0.82 0.74 0.76 Leuco… mesen… ## 4 Leuc_mesen… Le_me Le_me_E08 b 0.63 0.71 0.61 0.68 Leuco… mesen… ## 5 Leuc_mesen… Le_me Le_me_E09 a 0.65 0.78 0.89 0.63 Leuco… mesen… ## 6 Leuc_mesen… Le_me Le_me_E09 b 0.62 0.81 0.82 0.61 Leuco… mesen… Specie_b è la chiave: è la chiave primaria in mlab e la chiave esterna in chiave_lab_2. La chiave primaria è, appunto, la colonna che si intende utilizzare nella tabella principlae per ottenere la corrispondenza dei casi, e ad essa devono corrispondere valori della chiave esterna nella seconda tabella. Non è necessario che le due chiavi abbiano lo stesso nome (ma almeno alcuni valori devono corrispondere), perché l’argomento by consente di usare colonne con nomi diversi; è anche possibile usare più di una colonna come chiave (in questo caso valgono le combinazioni delle colonne che si usano) Esistono due gruppi principali di _join: mutating joins: la tabella che ne risulta contiene una combinazione di tutte colonne delle due tabelle originali (la o le colonne chiave non sono duplicate) ìnner_join() conserva solo le osservazioni della tabella a sinistra che hanno una corrispondenza in quella a destra left_join() usa tutti i casi della tabella a sinistra (la prima tabella che si usa nell’espressione join) e i casi corrispondenti della tabella a destra right_join()` usa tutti i casi della tabella a destra (la seconda tabella che si usa nell’espressione join) e i casi corrispondenti della tabella a sinistra full_join()` usa tutti i casi di entrambe le tabelle filtering joins: contengono solo una parte dei casi delle due tabelle utilizzate: semi_join() conserva solo le osservazioni di x che hanno una corrispondenza nella tabella a destra anti_join() conserva solo le osservazioni della tabella a sinistra che non hanno una corrispondenza in quella a destra. Anche se l’uso dei _join è piuttosto intuitivo ci sono diverse sottigliezze: che succede se un’istanza della chiave non ha una corrispondenza in entrambele tabelle? che succede se ci sono valori multipli della chiave in una delle due tabelle? L’argomento è piuttosto complesso ed è trattato in maniera molto esaustiva in R4DS che ti consiglio di leggere se e quando ne avrai bisogno. Intanto, per farti un’idea prova a cercare di capire come sono collegati i diversi data frame del pacchetto nycflights13. Prova a dare uno sguardo facendo girare questo script: data(airlines) head(airlines) data(airports) head(airports) data(flights) head(flights) data(planes) head(planes) data(weather) head(weather) La tabella principale è chiaramente flights, che contiene i dati dei voli. Usando le altre è possibile ottenere dati ulteriori che, se fossero stati presenti in flights, avrebbero reso la tabella pesantissima, duplicando inutilmente molte informazioni. 9.4 Strutture di controllo. Come hai visto nel paragrafo 3.1.2 e in diversi altri punti di questo libro eseguire un gruppo di istruzioni può richiedere delle strutture di controllo che indirizzino il flusso o eseguano in maniera iterativa gruppi più o meno complessi di funzioni. R è un linguaggio interpretato e, durante l’esecuzione dello script, le istruzioni vengono eseguite una alla volta: le strutture di controllo permettono di: ripetere un gruppo di istruzioni in base ad una condizione (loop for, while, repeat, etc.) eseguire in maniera alternativa dei gruppi di istruzioni (if … else) 9.4.1 Loop (o cicli) e cose simili. loop for I loop più comuni sono sicuramente i loop for, presenti in praticamente tutti i linguaggi di programmazione. La loro struttura è semplice: l’istruzione for() crea una sequenza, utilizzando un indice: for(i in 1:10){corpo} genera una sequenza di 10 iterazioni con l’indice i che va da 1 a 10 all’interno della sequenza, generalmente fra parentesi graffe (che non sono necessarie se il corpo è composto da una sola espressione) c’è il corpo del loop, le operazioni che verranno eseguite una volta per ogni iterazione della sequenza Ecco un piccolo esempio, con un loop relativamente inefficiente che serve per calcolare l’età media di 50 campioni casuali di 10 osservazioni estratti dal data set Arthritis: # uso set.seed per impostare il seme del generatore di numeri casuali, # in modo che l&#39;operazione sia riproducibile (soltanto per scopi # didattici) set.seed(1234) # creo manualmente una prima iterazione, 10 righe, tutte con l&#39;indice 1 subsample10 &lt;- as.data.frame( cbind( indice = rep(1,10), eta = sample(Arthritis$Age, size=10, replace = T) ) ) for (i in 2:50){ # la sequenza subsample &lt;- cbind(indice = rep(i,10), eta = sample(Arthritis$Age, size=10, replace = T)) subsample10 &lt;- rbind(subsample10, subsample) # questo è il corpo del loop } subsample10$indice &lt;- as.factor(subsample10$indice) glimpse(subsample10) ## Rows: 500 ## Columns: 2 ## $ indice &lt;fct&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, … ## $ eta &lt;dbl&gt; 58, 66, 55, 63, 46, 68, 32, 32, 55, 65, 64, 70, 31, 46, 32, 32,… nota come l’indice ì è stato utilizzato all’interno del loop per tenere traccia dell’iterazione e aggiungerla al data frame. Questo codice è veramente brutto e verboso e, in teoria, lento (l’operazione di cbind richiede che per ogni ciclo tutti i dati vengano copiati in memoria). In generale è più efficiente creare un contenitore vuoto della lunghezza desiderata (una lista, che può essere poi trasformata in data frame) e poi riempirlo. Anche questo codice funziona: iterazioni &lt;- 50 subcampioni &lt;- 10 contenitore &lt;- vector(&quot;list&quot;, iterazioni) for(i in 1:iterazioni){ contenitore[[i]] &lt;- sample(Arthritis$Age, size=10, replace = T) } subsamples_2 &lt;- tibble( indice = rep(1:iterazioni, each = subcampioni), eta = unlist(contenitore) ) Un modo semplice per generare una sequenza senza conoscerne in anticipo la lunghezza è usare seq_along() seq_along(Arthritis$ID) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ## [76] 76 77 78 79 80 81 82 83 84 seq_along(Arthritis$Sex) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ## [76] 76 77 78 79 80 81 82 83 84 # ma che succede se genero una sequenza sui livelli di un fattore? seq_along(levels(Arthritis$Sex)) ## [1] 1 2 E’ possibile annidare loop uno dentro l’altro. Per esempio prova ad eseguire questo codice in uno script: for(i in 1:10){ for(j in 1:5){ for(k in 1:2) print(i*j*k) } } E’ possibile interrompere un loop utilizzando i comandi: next: passa immediatamente all’iterazione successiva break: esce dal loop while, repeat. Nei loop for la sequenza viene valutata alla fine del loop: se la sequenza ha lunghezza 1 il loop viene eseguito almeno una volta, se ha lunghezza 0 non viene eseguita; se anche si modifica l’indice della sequenza all’interno del loop il progresso del loop non cambia. Nei loop while il corpo della sequenza viene eseguito fin quando la condizione while(condition) è vera e questo può causare delle ripetizioni infinite. La condizione viene valutata all’inizio del loop. Prova il sequenge codice in uno script. E’ un loop testardo, che richiede interazione da parte dell’utente, e va eseguito un’istruzione per volta… Readanswer &lt;- function(){ ans &lt;- readline(prompt=&quot;Per favore, immetti la tua RISPOSTA: &quot;) } answer &lt;- as.character(Readanswer()) while(answer != 42){ cat(&quot;Scusa, ho bisogno della risposta alla domanda fondamentale sulla vita, l&#39;universo e tutto quanto&quot;, &quot;\\n&quot;,&quot;Riprova...&quot;, sep = &quot;&quot;) answer &lt;- as.character(Readanswer()) } ?cat Finché non darai la risposta giusta (notoriamente, 42) il loop andrà avanti all’infinito… repeat è n altro modo (stupido) per creare loop e richiede l’uso specifico di break (in genere in una condizione if()) per uscire dal loop. Ecco un loop piuttosto stupido che stampa buongiorno almeno 5 volte oppure si lamenta che sia già pomeriggio. n &lt;- 0 hour &lt;- as.numeric(format(Sys.time(),&quot;%H&quot;)) repeat { if (hour&lt;=12 &amp; n&lt;5){ print(&quot;Buongiorno!&quot;) hour &lt;- as.numeric(format(Sys.time(),&quot;%H&quot;)) n&lt;-n+1 } else { print(&quot;Accidenti, è già pomeriggio oppure ho eseguito il loop 5 volte!&quot;) break } } 9.4.2 Un’alternativa (veloce e ordinata) ai loop: i “functional”. Un’alternativa, veloce e ordinata, alla maggior parte dei loop sono i così detti funzionali (functionals in inglese): si tratta di funzioni che hanno come argomento delle funzioni. Ne hai già visto un esempio nel paragrafo 3.1.2. Ci sono molti tipi di funzionali in R: le funzioni di base del gruppo apply: apply(), lapply(), sapply(), tapply(), mapply() le funzioni del pacchetto plyr, estremamente flessibili negli input e output le funzioni del pacchetto purrr Per brevità, ti riporto una versione ridotta del codice presentato nel paragrafo 3.1.2: # creo un data frame (in realtà una tibble) con numeri casuali n_casi &lt;- 10000 df &lt;- tibble( a = rnorm(n_casi), b = rnorm(n_casi), c = rnorm(n_casi), d = rnorm(n_casi), e = rnorm(n_casi), f = rnorm(n_casi), g = rnorm(n_casi), h =rnorm(n_casi)) # calcolo le mediane con un loop output &lt;- vector(&quot;double&quot;, length = ncol(df)) for (i in seq_along(df)) { # la sequenza output[[i]] &lt;- median(df[[i]]) # il corpo del loop } output ## [1] 0.006402963 -0.007366067 -0.005574402 0.007971636 -0.017403041 ## [6] -0.015778585 -0.001770304 0.002987635 # uso apply() (mediane_apply &lt;- apply(df, 2, median)) ## a b c d e f ## 0.006402963 -0.007366067 -0.005574402 0.007971636 -0.017403041 -0.015778585 ## g h ## -0.001770304 0.002987635 # uso la funzione map_dbl() del pacchetto purrr # map_dbl &quot;applica&quot; la funzione median alle colonne di df (le_mie_mediane &lt;- map_dbl(df, median)) ## a b c d e f ## 0.006402963 -0.007366067 -0.005574402 0.007971636 -0.017403041 -0.015778585 ## g h ## -0.001770304 0.002987635 Le mediane, ovviamente, sono identiche, e il codice è più o meno elegante e comprensibile. Questo argomento è decisamente troppo complesso per gli scopi di questo testo. Per saperne di più consulta, fra le altre cose, R4DS, la vignetta che compara le funzioni di purrr con quelle di R base, o questo vecchio articolo su plyr. 9.4.3 Esecuzione condizionale. In molti casi ci si può traovare nella situazione di voler far eseguire pezzetti diversi di codice a seconda di una condizione. In molte occasioni abbiamo visto l’uso della struttura più semplice: if(condizione){ istruzioni se condizione è vera } else { istruzioni se condizione è falsa } Un esempio è la funzione Readanswer() proposta nel paragrafo precedente. La struttura è molto semplice: dopo if, fra le parentesi tonde c’è una condizione che deve restituire un vettore logico di lunghezza 1, con valore TRUE o FALSE se la condizione è TRUE viene eseguito il comando o il gruppo di comandi (in questo caso devono essere fra parentesi graffe) immediatamente successivo se la condizione è FALSE viene eseguito il comando o gruppo di comandi dopo else (se esiste) o l’esecuzione salta al comando dopo Naturalmente, bisogna stare molto attenti a non definire oggetti in condizioni che potrebbero non essere eseguite e richiamarli più tardi. Prova a seguire questo esempio, abbastanza stupido, che dimostra anche l’uso degli if annidati (un if all’interno di un altro if, può servire a gestire situazioni in cui ci sono più di due condizioni): if(exists(&quot;cinque&quot;)) rm(cinque) # per eliminare l&#39;oggetto col nome cinque, se esiste cinquenumeri &lt;- c(1,2,3,4,5) for(i in seq_along(cinquenumeri)){ if(cinquenumeri[i]%%2==0){ cat(&quot;la posizione&quot;, i, &quot;vale&quot;, cinquenumeri[i], &quot; ed è pari\\n&quot;, sep = &quot; &quot;) } else { cat(&quot;la posizione&quot;, i, &quot;vale&quot;, cinquenumeri[i], &quot;ed è dispari\\n&quot;, sep = &quot; &quot;) if(cinquenumeri[i] == 5) { cinque&lt;-&quot;cinque è il numero perfetto&quot; print(cinque) } } } ## la posizione 1 vale 1 ed è dispari ## la posizione 2 vale 2 ed è pari ## la posizione 3 vale 3 ed è dispari ## la posizione 4 vale 4 ed è pari ## la posizione 5 vale 5 ed è dispari ## [1] &quot;cinque è il numero perfetto&quot; Prova, in uno script, ad usare per cinquenumeri un vettore di cinque numeri che non contenga il 5: che pensi che succederà? Gli if() sono molto usati nell’error trapping, una tecnica usata per “intrappolare” eventuali errori causati dall’esecuzione di una funzione o uno script, ridirigendo il flusso di esecuzione o generando un messaggio di errore o un warning. Se vuoi saperne di più prova a leggere [questa sezione] (https://adv-r.hadley.nz/conditions.html) di Advanced R. In realtà, ci sono modi più semplici di gestire condizioni multiple, come il comando switch() di R base o il comando dplyr::case_when(): # cerca switch nell&#39;aiuto, se vuoi # ?switch xx &lt;- 1:15 # un altro esempio stupido con la funzione modulo case_when( xx %% 15 == 0 ~ &quot;divisibile per 15, 5 e 3&quot;, xx %% 5 == 0 ~ &quot;divisibile per 5&quot;, xx %% 3 == 0 ~ &quot;divisibile per 3&quot;, TRUE ~ as.character(xx) ) ## [1] &quot;1&quot; &quot;2&quot; ## [3] &quot;divisibile per 3&quot; &quot;4&quot; ## [5] &quot;divisibile per 5&quot; &quot;divisibile per 3&quot; ## [7] &quot;7&quot; &quot;8&quot; ## [9] &quot;divisibile per 3&quot; &quot;divisibile per 5&quot; ## [11] &quot;11&quot; &quot;divisibile per 3&quot; ## [13] &quot;13&quot; &quot;14&quot; ## [15] &quot;divisibile per 15, 5 e 3&quot; L’ultima istruzione serve, genericamente, per restituire il valore di xx come carattere. Infine, se si desidera operare con una condizione su un vettore di condizioni logiche di lunghezza maggiore di uno, è possibile usare il comando ifelse() o, meglio ancora, dplyr::if_else(): in entrambi i casi la struttura è: if_else(vettore_logico, esegui se vero, esegui se falso) x &lt;- c(-1,1,-1,1,0) y &lt;- ifelse(x&gt;0,1,0) z &lt;- if_else(x&gt;=0,&quot;positivo o zero&quot;,&quot;negativo&quot;) # nota che i due comandi trattano lo 0 in modi diversi y ## [1] 0 1 0 1 0 z ## [1] &quot;negativo&quot; &quot;positivo o zero&quot; &quot;negativo&quot; &quot;positivo o zero&quot; ## [5] &quot;positivo o zero&quot; # guarda come ifelse() o if_else() possono essere usati per gestire # condizioni che causano dei warning sqrt(x) # genera dei warning ## Warning in sqrt(x): NaNs produced ## [1] NaN 1 NaN 1 0 sqrt(ifelse(x&gt;=0,x,NA)) # niente warning, ma restituisce, NA per i valori negativi ## [1] NA 1 NA 1 0 9.5 La soluzione dell’esercizio. Prova questo codice in uno script: mpg %&gt;% summarise(across(c(hwy,cty), list(media = mean, devst = sd)), .by = class) %&gt;% mutate(across(where(is.numeric), ~round(.x, digits = 2))) %&gt;% unite(&quot;hwy&quot;,starts_with(&quot;hwy&quot;), sep=&quot;±&quot;) %&gt;% unite(&quot;cty&quot;,starts_with(&quot;cty&quot;), sep=&quot;±&quot;) Incidentalmente, questo è proprio i modo in cui mostreresti una tabella con media e deviazione standard in un lavoro scientifico: pensa che noia rifare la tabella a mano… 9.6 Altre risorse. 9.6.1 Risorse in italiano. Documenti e pagine web. 9.6.2 Risorse in inglese. Come sempre, c’è a scegliere il sito del tidyverse dà una visione organica dei pacchetti per la manipolazione “tidy” dei dati il concetto di “tidy data” è descritto in maniera eccellente da Hadley Wickham le vignette dei pacchetti del tidyverse sono un’ottima guida per approfondire gli aspetti dei singoli pacchetti un’ottima guida allo stile di programmazione è quella del tidyverse si sono diversi eccellenti libri che includono ampi capitoli sul data wrangling o sono specializzati sulla programmazione con R: il solito R for data science ormai disponibile anche in lingua italiana Hands on programming with R fornisce un’ottima introduzione per chi non è neanche abituato all’idea di ragionare per algoritmi R programming for data science sicuramente più articolato e completo e parecchio più noioso Advanced R è, ovviamente, la guida definitiva alla programmazione avanzata con R. rispetto all’analisi dei dati, è ovvio↩︎ e, indovina? Ti servirà sicuramente…↩︎ un po’ come accade nel vecchio pacchetto reshape2↩︎ ricorda, un data frame è una lista, quindi nulla vieta che una delle colonne sia una colonna di liste↩︎ ho usato questa sintassi perché come vedrai, in funzione dell’ordine di caricamento dei pacchetti il comando filter potrebbe essere “mascherato” da altri comandi.↩︎ scrivi nella console &gt;help(language, package = \"tidyselect\")↩︎ ma con qualche differenza dalle funzioni base: leggi l’aiuto, senti a me…↩︎ "],["citazioni-crediti-copyright-ringraziamenti..html", "10 Citazioni, crediti, copyright, ringraziamenti. 10.1 Citazioni. Credits e copyright.", " 10 Citazioni, crediti, copyright, ringraziamenti. v1.0.1 5/11/2023 10.1 Citazioni. Ecco una lista dei pacchetti usati in questo libro. Sono in ordine alfabetico, e non in ordine di importanza (almeno dal mio punto di vista). Qui ho usato il comando citation() per generare i riferimenti bibliografici che possono essere usati per citare i pacchetti nelle pubblicazioni. ## $base ## To cite R in publications use: ## ## R Core Team (2023). _R: A Language and Environment for Statistical ## Computing_. R Foundation for Statistical Computing, Vienna, Austria. ## &lt;https://www.R-project.org/&gt;. ## ## We have invested a lot of time and effort in creating R, please cite it ## when using it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for ## citing R packages. ## ## $beepr ## To cite package &#39;beepr&#39; in publications use: ## ## Bååth R (2018). _beepr: Easily Play Notification Sounds on any ## Platform_. R package version 1.3, ## &lt;https://CRAN.R-project.org/package=beepr&gt;. ## ## $broom ## To cite package &#39;broom&#39; in publications use: ## ## Robinson D, Hayes A, Couch S (2023). _broom: Convert Statistical ## Objects into Tidy Tibbles_. R package version 1.0.5, ## &lt;https://CRAN.R-project.org/package=broom&gt;. ## ## $car ## To cite the car package in publications use: ## ## Fox J, Weisberg S (2019). _An R Companion to Applied Regression_, ## Third edition. Sage, Thousand Oaks CA. ## &lt;https://socialsciences.mcmaster.ca/jfox/Books/Companion/&gt;. ## ## $cowplot ## To cite package &#39;cowplot&#39; in publications use: ## ## Wilke C (2020). _cowplot: Streamlined Plot Theme and Plot Annotations ## for &#39;ggplot2&#39;_. R package version 1.1.1, ## &lt;https://CRAN.R-project.org/package=cowplot&gt;. ## ## $data.table ## To cite package &#39;data.table&#39; in publications use: ## ## Dowle M, Srinivasan A (2023). _data.table: Extension of ## `data.frame`_. R package version 1.14.8, ## &lt;https://CRAN.R-project.org/package=data.table&gt;. ## ## $dplyr ## To cite package &#39;dplyr&#39; in publications use: ## ## Wickham H, François R, Henry L, Müller K, Vaughan D (2023). _dplyr: A ## Grammar of Data Manipulation_. R package version 1.1.3, ## &lt;https://CRAN.R-project.org/package=dplyr&gt;. ## ## $doBy ## To cite package &#39;doBy&#39; in publications use: ## ## Højsgaard S, Halekoh U (2023). _doBy: Groupwise Statistics, LSmeans, ## Linear Estimates, Utilities_. R package version 4.6.20, ## &lt;https://CRAN.R-project.org/package=doBy&gt;. ## ## ATTENTION: This citation information has been auto-generated from the ## package DESCRIPTION file and may need manual editing, see ## &#39;help(&quot;citation&quot;)&#39;. ## ## $foreign ## To cite package &#39;foreign&#39; in publications use: ## ## R Core Team (2023). _foreign: Read Data Stored by &#39;Minitab&#39;, &#39;S&#39;, ## &#39;SAS&#39;, &#39;SPSS&#39;, &#39;Stata&#39;, &#39;Systat&#39;, &#39;Weka&#39;, &#39;dBase&#39;, ..._. R package ## version 0.8-85, &lt;https://CRAN.R-project.org/package=foreign&gt;. ## ## $ggplot2 ## To cite ggplot2 in publications, please use ## ## H. Wickham. ggplot2: Elegant Graphics for Data Analysis. ## Springer-Verlag New York, 2016. ## ## $ggpubr ## To cite package &#39;ggpubr&#39; in publications use: ## ## Kassambara A (2023). _ggpubr: &#39;ggplot2&#39; Based Publication Ready ## Plots_. R package version 0.6.0, ## &lt;https://CRAN.R-project.org/package=ggpubr&gt;. ## ## $gmodels ## To cite package &#39;gmodels&#39; in publications use: ## ## Warnes GR, Bolker B, Lumley T, SAIC-Frederick RCJCfRCJaC, Program ## IFbtIR, NIH ot, Institute NC, NO1-CO-12400. CfCRuNC (2022). _gmodels: ## Various R Programming Tools for Model Fitting_. R package version ## 2.18.1.1, &lt;https://CRAN.R-project.org/package=gmodels&gt;. ## ## ATTENTION: This citation information has been auto-generated from the ## package DESCRIPTION file and may need manual editing, see ## &#39;help(&quot;citation&quot;)&#39;. ## ## $Hmisc ## To cite package &#39;Hmisc&#39; in publications use: ## ## Harrell Jr F (2023). _Hmisc: Harrell Miscellaneous_. R package ## version 5.1-1, &lt;https://CRAN.R-project.org/package=Hmisc&gt;. ## ## $knitr ## To cite package &#39;knitr&#39; in publications use: ## ## Xie Y (2023). _knitr: A General-Purpose Package for Dynamic Report ## Generation in R_. R package version 1.45, &lt;https://yihui.org/knitr/&gt;. ## ## Yihui Xie (2015) Dynamic Documents with R and knitr. 2nd edition. ## Chapman and Hall/CRC. ISBN 978-1498716963 ## ## Yihui Xie (2014) knitr: A Comprehensive Tool for Reproducible ## Research in R. In Victoria Stodden, Friedrich Leisch and Roger D. ## Peng, editors, Implementing Reproducible Computational Research. ## Chapman and Hall/CRC. ISBN 978-1466561595 ## ## $kableExtra ## To cite package &#39;kableExtra&#39; in publications use: ## ## Zhu H (2021). _kableExtra: Construct Complex Table with &#39;kable&#39; and ## Pipe Syntax_. R package version 1.3.4, ## &lt;https://CRAN.R-project.org/package=kableExtra&gt;. ## ## $magrittr ## To cite package &#39;magrittr&#39; in publications use: ## ## Bache S, Wickham H (2022). _magrittr: A Forward-Pipe Operator for R_. ## R package version 2.0.3, ## &lt;https://CRAN.R-project.org/package=magrittr&gt;. ## ## $MASS ## To cite the MASS package in publications use: ## ## Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with ## S. Fourth Edition. Springer, New York. ISBN 0-387-95457-0 ## ## $microbenchmark ## To cite package &#39;microbenchmark&#39; in publications use: ## ## Mersmann O (2023). _microbenchmark: Accurate Timing Functions_. R ## package version 1.4.10, ## &lt;https://CRAN.R-project.org/package=microbenchmark&gt;. ## ## $openxlsx ## To cite package &#39;openxlsx&#39; in publications use: ## ## Schauberger P, Walker A (2023). _openxlsx: Read, Write and Edit xlsx ## Files_. R package version 4.2.5.2, ## &lt;https://CRAN.R-project.org/package=openxlsx&gt;. ## ## $nortest ## To cite package &#39;nortest&#39; in publications use: ## ## Gross J, Ligges U (2015). _nortest: Tests for Normality_. R package ## version 1.0-4, &lt;https://CRAN.R-project.org/package=nortest&gt;. ## ## $nycflights13 ## To cite package &#39;nycflights13&#39; in publications use: ## ## Wickham H (2021). _nycflights13: Flights that Departed NYC in 2013_. ## R package version 1.0.2, ## &lt;https://CRAN.R-project.org/package=nycflights13&gt;. ## ## $pastecs ## To cite package &#39;pastecs&#39; in publications use: ## ## Grosjean P, Ibanez F (2018). _pastecs: Package for Analysis of ## Space-Time Ecological Series_. R package version 1.3.21, ## &lt;https://CRAN.R-project.org/package=pastecs&gt;. ## ## $plyr ## To cite package &#39;plyr&#39; in publications use: ## ## Hadley Wickham (2011). The Split-Apply-Combine Strategy for Data ## Analysis. Journal of Statistical Software, 40(1), 1-29. URL ## https://www.jstatsoft.org/v40/i01/. ## ## $psych ## To cite package &#39;psych&#39; in publications use: ## ## William Revelle (2023). _psych: Procedures for Psychological, ## Psychometric, and Personality Research_. Northwestern University, ## Evanston, Illinois. R package version 2.3.9, ## &lt;https://CRAN.R-project.org/package=psych&gt;. ## ## $purrr ## To cite package &#39;purrr&#39; in publications use: ## ## Wickham H, Henry L (2023). _purrr: Functional Programming Tools_. R ## package version 1.0.2, &lt;https://CRAN.R-project.org/package=purrr&gt;. ## ## $radiant ## To cite package &#39;radiant&#39; in publications use: ## ## Nijs V (2023). _radiant: Business Analytics using R and Shiny_. R ## package version 1.6.0, &lt;https://CRAN.R-project.org/package=radiant&gt;. ## ## $Rcmdr ## To cite the &#39;Rcmdr&#39; package in publications use: ## ## Fox, J., and Bouchet-Valat, M. (2023). Rcmdr: R Commander. R package ## version 2.9-1. ## ## Fox, J. (2017). Using the R Commander: A Point-and-Click Interface or ## R. Boca Raton FL: Chapman and Hall/CRC Press. ## ## Fox, J. (2005). The R Commander: A Basic Statistics Graphical User ## Interface to R. Journal of Statistical Software, 14(9): 1--42. ## ## $RColorBrewer ## To cite package &#39;RColorBrewer&#39; in publications use: ## ## Neuwirth E (2022). _RColorBrewer: ColorBrewer Palettes_. R package ## version 1.1-3, &lt;https://CRAN.R-project.org/package=RColorBrewer&gt;. ## ## $reshape2 ## To cite reshape2 in publications use: ## ## Hadley Wickham (2007). Reshaping Data with the reshape Package. ## Journal of Statistical Software, 21(12), 1-20. URL ## http://www.jstatsoft.org/v21/i12/. ## ## $rmarkdown ## To cite package &#39;rmarkdown&#39; in publications use: ## ## Allaire J, Xie Y, Dervieux C, McPherson J, Luraschi J, Ushey K, ## Atkins A, Wickham H, Cheng J, Chang W, Iannone R (2023). _rmarkdown: ## Dynamic Documents for R_. R package version 2.25, ## &lt;https://github.com/rstudio/rmarkdown&gt;. ## ## Xie Y, Allaire J, Grolemund G (2018). _R Markdown: The Definitive ## Guide_. Chapman and Hall/CRC, Boca Raton, Florida. ISBN ## 9781138359338, &lt;https://bookdown.org/yihui/rmarkdown&gt;. ## ## Xie Y, Dervieux C, Riederer E (2020). _R Markdown Cookbook_. Chapman ## and Hall/CRC, Boca Raton, Florida. ISBN 9780367563837, ## &lt;https://bookdown.org/yihui/rmarkdown-cookbook&gt;. ## ## $stringr ## To cite package &#39;stringr&#39; in publications use: ## ## Wickham H (2022). _stringr: Simple, Consistent Wrappers for Common ## String Operations_. R package version 1.5.0, ## &lt;https://CRAN.R-project.org/package=stringr&gt;. ## ## $skimr ## To cite package &#39;skimr&#39; in publications use: ## ## Waring E, Quinn M, McNamara A, Arino de la Rubia E, Zhu H, Ellis S ## (2022). _skimr: Compact and Flexible Summaries of Data_. R package ## version 2.1.5, &lt;https://CRAN.R-project.org/package=skimr&gt;. ## ## $tictoc ## To cite package &#39;tictoc&#39; in publications use: ## ## Izrailev S (2023). _tictoc: Functions for Timing R Scripts, as Well ## as Implementations of &quot;Stack&quot; and &quot;StackList&quot; Structures_. R package ## version 1.2, &lt;https://CRAN.R-project.org/package=tictoc&gt;. ## ## ATTENTION: This citation information has been auto-generated from the ## package DESCRIPTION file and may need manual editing, see ## &#39;help(&quot;citation&quot;)&#39;. ## ## $tidyr ## To cite package &#39;tidyr&#39; in publications use: ## ## Wickham H, Vaughan D, Girlich M (2023). _tidyr: Tidy Messy Data_. R ## package version 1.3.0, &lt;https://CRAN.R-project.org/package=tidyr&gt;. ## ## $tidyverse ## To cite package &#39;tidyverse&#39; in publications use: ## ## Wickham H, Averick M, Bryan J, Chang W, McGowan LD, François R, ## Grolemund G, Hayes A, Henry L, Hester J, Kuhn M, Pedersen TL, Miller ## E, Bache SM, Müller K, Ooms J, Robinson D, Seidel DP, Spinu V, ## Takahashi K, Vaughan D, Wilke C, Woo K, Yutani H (2019). &quot;Welcome to ## the tidyverse.&quot; _Journal of Open Source Software_, *4*(43), 1686. ## doi:10.21105/joss.01686 &lt;https://doi.org/10.21105/joss.01686&gt;. ## ## $vcd ## Meyer D, Zeileis A, Hornik K (2023). _vcd: Visualizing Categorical ## Data_. R package version 1.4-11, ## &lt;https://CRAN.R-project.org/package=vcd&gt;. ## ## To cite the strucplot framework (e.g., functions mosaic(), sieve(), ## assoc(), strucplot(), structable(), pairs.table(), cotabplot(), ## doubledecker()), additionally use: ## ## Meyer D, Zeileis A, Hornik K (2006). &quot;The Strucplot Framework: ## Visualizing Multi-Way Contingency Tables with vcd.&quot; _Journal of ## Statistical Software_, *17*(3), 1-48. doi:10.18637/jss.v017.i03 ## &lt;https://doi.org/10.18637/jss.v017.i03&gt;. ## ## If you use the residual-based shadings (in mosaic() or assoc()), please ## cite: ## ## Zeileis A, Meyer D, Hornik K (2007). &quot;Residual-based Shadings for ## Visualizing (Conditional) Independence.&quot; _Journal of Computational ## and Graphical Statistics_, *16*(3), 507-525. ## doi:10.1198/106186007X237856 ## &lt;https://doi.org/10.1198/106186007X237856&gt;. Credits e copyright. la Figura usata per la copertina è di Mark Stebnicki da Pexels Di alcune figure del capitolo 3 non sono riuscito a trovare una fonte precisa, neanche usando la ricerca per immaigni di Google. La figura 4.2 è stata modificata a partire dalla figura 1 di Szymańska, E., 2018. Modern data science for analytical chemical data - A comprehensive review. Anal Chim Acta 1028, 1–10.. Ho un debito con i reviewer di questo libro: ahnno avuto la pazienza di leggere tutto, cosa che non credo faranno tutt* quell* che, in un modo o nell’altro, lo avranno “fra le mani”. Gli script usati per generare questo libro sono stati creati da Eugenio Parente (eugenio.parente_at_unibas.it), Università degli Studi della Basilicata, 2021, 2022, 2023 https://github.com/ep142 Gli script sono stati testati (fino ad ottobre 2023) con R 4.0.5, 4.1, 4.2.2, 4.3.0, 4.3.1 (sia build per processori Intel che per arm64) su diversi personal computer Apple (con MacOS 10.14.6, 10.15.7, 13.6). Il codice è disponibile in un repository su GitHub (se proprio siete troppo pigr* per scrivere o fare il copia e incolla). Le parti di codice sono sotto licenza MIT Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Le parti di testo sono sotto licenza CC BY 4.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
